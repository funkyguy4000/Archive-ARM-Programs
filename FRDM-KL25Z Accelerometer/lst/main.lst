L 1 "src\main.c"
N/*----------------------------------------------------------------------------
N *----------------------------------------------------------------------------*/
N#include <MKL25Z4.H>
L 1 "C:\Keil_v4\ARM\Inc\Freescale\Kinetis\MKL25Z4.H" 1
N/*
N** ###################################################################
N**     Processors:          MKL25Z128FM4
N**                          MKL25Z128FT4
N**                          MKL25Z128LH4
N**                          MKL25Z128VLK4
N**
N**     Compilers:           ARM Compiler
N**                          Freescale C/C++ for Embedded ARM
N**                          GNU C Compiler
N**                          IAR ANSI C/C++ Compiler for ARM
N**
N**     Reference manual:    KL25P80M48SF0RM, Rev.3, Sep 2012
N**     Version:             rev. 1.4, 2012-11-22
N**
N**     Abstract:
N**         CMSIS Peripheral Access Layer for MKL25Z4
N**
N**     Copyright: 1997 - 2012 Freescale, Inc. All Rights Reserved.
N**
N**     http:                 www.freescale.com
N**     mail:                 support@freescale.com
N**
N**     Revisions:
N**     - rev. 1.0 (2012-06-13)
N**         Initial version.
N**     - rev. 1.1 (2012-06-21)
N**         Update according to reference manual rev. 1.
N**     - rev. 1.2 (2012-08-01)
N**         Device type UARTLP changed to UART0.
N**     - rev. 1.3 (2012-10-04)
N**         Update according to reference manual rev. 3.
N**     - rev. 1.4 (2012-11-22)
N**         MCG module - bit LOLS in MCG_S register renamed to LOLS0.
N**         NV registers - bit EZPORT_DIS in NV_FOPT register removed.
N**
N** ###################################################################
N*/
N
N/**
N * @file MKL25Z4.h
N * @version 1.4
N * @date 2012-11-22
N * @brief CMSIS Peripheral Access Layer for MKL25Z4
N *
N * CMSIS Peripheral Access Layer for MKL25Z4
N */
N
N#if !defined(MKL25Z4_H_)
X#if !0L
N#define MKL25Z4_H_                               /**< Symbol preventing repeated inclusion */
N
N/** Memory map major version (memory maps with equal major version number are
N * compatible) */
N#define MCU_MEM_MAP_VERSION 0x0100u
N/** Memory map minor version */
N#define MCU_MEM_MAP_VERSION_MINOR 0x0004u
N
N
N/* ----------------------------------------------------------------------------
N   -- Interrupt vector numbers
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup Interrupt_vector_numbers Interrupt vector numbers
N * @{
N */
N
N/** Interrupt Number Definitions */
Ntypedef enum IRQn {
N  /* Core interrupts */
N  NonMaskableInt_IRQn          = -14,              /**< Non Maskable Interrupt */
N  HardFault_IRQn               = -13,              /**< Cortex-M0 SV Hard Fault Interrupt */
N  SVCall_IRQn                  = -5,               /**< Cortex-M0 SV Call Interrupt */
N  PendSV_IRQn                  = -2,               /**< Cortex-M0 Pend SV Interrupt */
N  SysTick_IRQn                 = -1,               /**< Cortex-M0 System Tick Interrupt */
N
N  /* Device specific interrupts */
N  DMA0_IRQn                    = 0,                /**< DMA channel 0 transfer complete/error interrupt */
N  DMA1_IRQn                    = 1,                /**< DMA channel 1 transfer complete/error interrupt */
N  DMA2_IRQn                    = 2,                /**< DMA channel 2 transfer complete/error interrupt */
N  DMA3_IRQn                    = 3,                /**< DMA channel 3 transfer complete/error interrupt */
N  Reserved20_IRQn              = 4,                /**< Reserved interrupt 20 */
N  FTFA_IRQn                    = 5,                /**< FTFA command complete/read collision interrupt */
N  LVD_LVW_IRQn                 = 6,                /**< Low Voltage Detect, Low Voltage Warning */
N  LLW_IRQn                     = 7,                /**< Low Leakage Wakeup */
N  I2C0_IRQn                    = 8,                /**< I2C0 interrupt */
N  I2C1_IRQn                    = 9,                /**< I2C0 interrupt 25 */
N  SPI0_IRQn                    = 10,               /**< SPI0 interrupt */
N  SPI1_IRQn                    = 11,               /**< SPI1 interrupt */
N  UART0_IRQn                   = 12,               /**< UART0 status/error interrupt */
N  UART1_IRQn                   = 13,               /**< UART1 status/error interrupt */
N  UART2_IRQn                   = 14,               /**< UART2 status/error interrupt */
N  ADC0_IRQn                    = 15,               /**< ADC0 interrupt */
N  CMP0_IRQn                    = 16,               /**< CMP0 interrupt */
N  TPM0_IRQn                    = 17,               /**< TPM0 fault, overflow and channels interrupt */
N  TPM1_IRQn                    = 18,               /**< TPM1 fault, overflow and channels interrupt */
N  TPM2_IRQn                    = 19,               /**< TPM2 fault, overflow and channels interrupt */
N  RTC_IRQn                     = 20,               /**< RTC interrupt */
N  RTC_Seconds_IRQn             = 21,               /**< RTC seconds interrupt */
N  PIT_IRQn                     = 22,               /**< PIT timer interrupt */
N  Reserved39_IRQn              = 23,               /**< Reserved interrupt 39 */
N  USB0_IRQn                    = 24,               /**< USB0 interrupt */
N  DAC0_IRQn                    = 25,               /**< DAC0 interrupt */
N  TSI0_IRQn                    = 26,               /**< TSI0 interrupt */
N  MCG_IRQn                     = 27,               /**< MCG interrupt */
N  LPTimer_IRQn                 = 28,               /**< LPTimer interrupt */
N  Reserved45_IRQn              = 29,               /**< Reserved interrupt 45 */
N  PORTA_IRQn                   = 30,               /**< Port A interrupt */
N  PORTD_IRQn                   = 31                /**< Port D interrupt */
N} IRQn_Type;
N
N/**
N * @}
N */ /* end of group Interrupt_vector_numbers */
N
N
N/* ----------------------------------------------------------------------------
N   -- Cortex M0 Core Configuration
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup Cortex_Core_Configuration Cortex M0 Core Configuration
N * @{
N */
N
N#define __CM0PLUS_REV                  0x0000    /**< Core revision r0p0 */
N#define __MPU_PRESENT                  0         /**< Defines if an MPU is present or not */
N#define __VTOR_PRESENT                 1         /**< Defines if an MPU is present or not */
N#define __NVIC_PRIO_BITS               2         /**< Number of priority bits implemented in the NVIC */
N#define __Vendor_SysTickConfig         0         /**< Vendor specific implementation of SysTickConfig is defined */
N
N#include "core_cm0plus.h"              /* Core Peripheral Access Layer */
L 1 "C:\Keil_v4\ARM\CMSIS\Include\core_cm0plus.h" 1
N/**************************************************************************//**
N * @file     core_cm0plus.h
N * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
N * @version  V3.20
N * @date     25. February 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM0PLUS_H_GENERIC
N#define __CORE_CM0PLUS_H_GENERIC
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex-M0+
N  @{
N */
N
N/*  CMSIS CM0P definitions */
N#define __CM0PLUS_CMSIS_VERSION_MAIN (0x03)                                /*!< [31:16] CMSIS HAL main version   */
N#define __CM0PLUS_CMSIS_VERSION_SUB  (0x20)                                /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16) | \
N                                       __CM0PLUS_CMSIS_VERSION_SUB)        /*!< CMSIS HAL version number         */
X#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16) |                                        __CM0PLUS_CMSIS_VERSION_SUB)         
N
N#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "C:\Keil_v4\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 127 "C:\Keil_v4\ARM\CMSIS\Include\core_cm0plus.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "C:\Keil_v4\ARM\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.20
N * @date     05. March 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5030076 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/** \brief  Breakpoint
N
N    This function causes the processor to enter Debug state.
N    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N
N    \param [in]    value  is ignored by the processor.
N                   If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#define __CLREX                           __clrex
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/* Define macros for porting to both thumb1 and thumb2.
S * For thumb1, use low register (r0-r7), specified by constrant "l"
S * Otherwise, use general registers, specified by constrant "r" */
S#if defined (__thumb__) && !defined (__thumb2__)
S#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
S#define __CMSIS_GCC_USE_REG(r) "l" (r)
S#else
S#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
S#define __CMSIS_GCC_USE_REG(r) "r" (r)
S#endif
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
S  return __builtin_bswap32(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S  return (short)__builtin_bswap16(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S  return (op1 >> op2) | (op1 << (32 - op2)); 
S}
S
S
S/** \brief  Breakpoint
S
S    This function causes the processor to enter Debug state.
S    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
S
S    \param [in]    value  is ignored by the processor.
S                   If required, a debugger can use it to store additional information about the breakpoint.
S */
S#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex" ::: "memory");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S   uint32_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 128 "C:\Keil_v4\ARM\CMSIS\Include\core_cm0plus.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "C:\Keil_v4\ARM\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.20
N * @date     25. February 2013
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2013 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5030076 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  __ASM volatile ("");
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
S  __ASM volatile ("");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N#endif /* __CORE_CMFUNC_H */
L 129 "C:\Keil_v4\ARM\CMSIS\Include\core_cm0plus.h" 2
N
N#endif /* __CORE_CM0PLUS_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0PLUS_H_DEPENDANT
N#define __CORE_CM0PLUS_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0PLUS_REV
S    #define __CM0PLUS_REV             0x0000
S    #warning "__CM0PLUS_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __VTOR_PRESENT
S    #define __VTOR_PRESENT            0
S    #warning "__VTOR_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex-M0+ */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core MPU Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IP[8];                    
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N#if (__VTOR_PRESENT == 1)
X#if (1 == 1)
N  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                     
N#else
S       uint32_t RESERVED0;
N#endif
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N#if (__VTOR_PRESENT == 1)
X#if (1 == 1)
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 8                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N#if (__MPU_PRESENT == 1)
X#if (0 == 1)
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S    \brief      Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/** \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
S  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
S  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
S  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
S  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
S} MPU_Type;
S
S/* MPU Type Register */
S#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register */
S#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register */
S#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register */
S#define MPU_RBAR_ADDR_Pos                   8                                             /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register */
S#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
N#endif
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR)
N                are only accessible over DAP and not via processor. Therefore
N                they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0+ Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N
N#if (__MPU_PRESENT == 1)
X#if (0 == 1)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) & 0xFF) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) & 0xFF) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
X  if ((ticks - 1) > (0xFFFFFFUL << 0))  return (1);       
N
N  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = ticks - 1;                                   
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0PLUS_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
L 133 "C:\Keil_v4\ARM\Inc\Freescale\Kinetis\MKL25Z4.H" 2
N#include "system_MKL25Z4.h"            /* Device specific configuration file */
L 1 "C:\Keil_v4\ARM\Inc\Freescale\Kinetis\system_MKL25Z4.h" 1
N/*
N** ###################################################################
N**     Processors:          MKL25Z128FM4
N**                          MKL25Z128FT4
N**                          MKL25Z128LH4
N**                          MKL25Z128VLK4
N**
N**     Compilers:           ARM Compiler
N**                          Freescale C/C++ for Embedded ARM
N**                          GNU C Compiler
N**                          IAR ANSI C/C++ Compiler for ARM
N**
N**     Reference manual:    KL25P80M48SF0RM, Rev.3, Sep 2012
N**     Version:             rev. 1.4, 2012-11-22
N**
N**     Abstract:
N**         Provides a system configuration function and a global variable that
N**         contains the system frequency. It configures the device and initializes
N**         the oscillator (PLL) that is part of the microcontroller device.
N**
N**     Copyright: 2012 Freescale, Inc. All Rights Reserved.
N**
N**     http:                 www.freescale.com
N**     mail:                 support@freescale.com
N**
N**     Revisions:
N**     - rev. 1.0 (2012-06-13)
N**         Initial version.
N**     - rev. 1.1 (2012-06-21)
N**         Update according to reference manual rev. 1.
N**     - rev. 1.2 (2012-08-01)
N**         Device type UARTLP changed to UART0.
N**     - rev. 1.3 (2012-10-04)
N**         Update according to reference manual rev. 3.
N**     - rev. 1.4 (2012-11-22)
N**         MCG module - bit LOLS in MCG_S register renamed to LOLS0.
N**         NV registers - bit EZPORT_DIS in NV_FOPT register removed.
N**
N** ###################################################################
N*/
N
N/**
N * @file MKL25Z4
N * @version 1.4
N * @date 2012-11-22
N * @brief Device specific configuration file for MKL25Z4 (header file)
N *
N * Provides a system configuration function and a global variable that contains
N * the system frequency. It configures the device and initializes the oscillator
N * (PLL) that is part of the microcontroller device.
N */
N
N#ifndef SYSTEM_MKL25Z4_H_
N#define SYSTEM_MKL25Z4_H_                        /**< Symbol preventing repeated inclusion */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
N/**
N * @brief System clock frequency (core clock)
N *
N * The system clock frequency supplied to the SysTick timer and the processor
N * core clock. This variable can be used by the user application to setup the
N * SysTick timer or configure other parameters. It may also be used by debugger to
N * query the frequency of the debug timer or configure the trace clock speed
N * SystemCoreClock is initialized with a correct predefined value.
N */
Nextern uint32_t SystemCoreClock;
N
N/**
N * @brief Setup the microcontroller system.
N *
N * Typically this function configures the oscillator (PLL) that is part of the
N * microcontroller device. For systems with variable clock speed it also updates
N * the variable SystemCoreClock. SystemInit is called from startup_device file.
N */
Nvoid SystemInit (void);
N
N/**
N * @brief Updates the SystemCoreClock variable.
N *
N * It must be called whenever the core clock is changed during program
N * execution. SystemCoreClockUpdate() evaluates the clock register settings and calculates
N * the current core clock.
N */
Nvoid SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  /* #if !defined(SYSTEM_MKL25Z4_H_) */
L 134 "C:\Keil_v4\ARM\Inc\Freescale\Kinetis\MKL25Z4.H" 2
N
N/**
N * @}
N */ /* end of group Cortex_Core_Configuration */
N
N
N/* ----------------------------------------------------------------------------
N   -- Device Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup Peripheral_access_layer Device Peripheral Access Layer
N * @{
N */
N
N
N/*
N** Start of section using anonymous unions
N*/
N
N#if defined(__ARMCC_VERSION)
X#if 1L
N  #pragma push
N  #pragma anon_unions
N#elif defined(__CWCC__)
S  #pragma push
S  #pragma cpp_extensions on
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__IAR_SYSTEMS_ICC__)
S  #pragma language=extended
S#else
S  #error Not supported compiler type
N#endif
N
N/* ----------------------------------------------------------------------------
N   -- ADC Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup ADC_Peripheral_Access_Layer ADC Peripheral Access Layer
N * @{
N */
N
N/** ADC - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t SC1[2];                            /**< ADC Status and Control Registers 1, array offset: 0x0, array step: 0x4 */
X  volatile uint32_t SC1[2];                             
N  __IO uint32_t CFG1;                              /**< ADC Configuration Register 1, offset: 0x8 */
X  volatile uint32_t CFG1;                               
N  __IO uint32_t CFG2;                              /**< ADC Configuration Register 2, offset: 0xC */
X  volatile uint32_t CFG2;                               
N  __I  uint32_t R[2];                              /**< ADC Data Result Register, array offset: 0x10, array step: 0x4 */
X  volatile const  uint32_t R[2];                               
N  __IO uint32_t CV1;                               /**< Compare Value Registers, offset: 0x18 */
X  volatile uint32_t CV1;                                
N  __IO uint32_t CV2;                               /**< Compare Value Registers, offset: 0x1C */
X  volatile uint32_t CV2;                                
N  __IO uint32_t SC2;                               /**< Status and Control Register 2, offset: 0x20 */
X  volatile uint32_t SC2;                                
N  __IO uint32_t SC3;                               /**< Status and Control Register 3, offset: 0x24 */
X  volatile uint32_t SC3;                                
N  __IO uint32_t OFS;                               /**< ADC Offset Correction Register, offset: 0x28 */
X  volatile uint32_t OFS;                                
N  __IO uint32_t PG;                                /**< ADC Plus-Side Gain Register, offset: 0x2C */
X  volatile uint32_t PG;                                 
N  __IO uint32_t MG;                                /**< ADC Minus-Side Gain Register, offset: 0x30 */
X  volatile uint32_t MG;                                 
N  __IO uint32_t CLPD;                              /**< ADC Plus-Side General Calibration Value Register, offset: 0x34 */
X  volatile uint32_t CLPD;                               
N  __IO uint32_t CLPS;                              /**< ADC Plus-Side General Calibration Value Register, offset: 0x38 */
X  volatile uint32_t CLPS;                               
N  __IO uint32_t CLP4;                              /**< ADC Plus-Side General Calibration Value Register, offset: 0x3C */
X  volatile uint32_t CLP4;                               
N  __IO uint32_t CLP3;                              /**< ADC Plus-Side General Calibration Value Register, offset: 0x40 */
X  volatile uint32_t CLP3;                               
N  __IO uint32_t CLP2;                              /**< ADC Plus-Side General Calibration Value Register, offset: 0x44 */
X  volatile uint32_t CLP2;                               
N  __IO uint32_t CLP1;                              /**< ADC Plus-Side General Calibration Value Register, offset: 0x48 */
X  volatile uint32_t CLP1;                               
N  __IO uint32_t CLP0;                              /**< ADC Plus-Side General Calibration Value Register, offset: 0x4C */
X  volatile uint32_t CLP0;                               
N       uint8_t RESERVED_0[4];
N  __IO uint32_t CLMD;                              /**< ADC Minus-Side General Calibration Value Register, offset: 0x54 */
X  volatile uint32_t CLMD;                               
N  __IO uint32_t CLMS;                              /**< ADC Minus-Side General Calibration Value Register, offset: 0x58 */
X  volatile uint32_t CLMS;                               
N  __IO uint32_t CLM4;                              /**< ADC Minus-Side General Calibration Value Register, offset: 0x5C */
X  volatile uint32_t CLM4;                               
N  __IO uint32_t CLM3;                              /**< ADC Minus-Side General Calibration Value Register, offset: 0x60 */
X  volatile uint32_t CLM3;                               
N  __IO uint32_t CLM2;                              /**< ADC Minus-Side General Calibration Value Register, offset: 0x64 */
X  volatile uint32_t CLM2;                               
N  __IO uint32_t CLM1;                              /**< ADC Minus-Side General Calibration Value Register, offset: 0x68 */
X  volatile uint32_t CLM1;                               
N  __IO uint32_t CLM0;                              /**< ADC Minus-Side General Calibration Value Register, offset: 0x6C */
X  volatile uint32_t CLM0;                               
N} ADC_Type;
N
N/* ----------------------------------------------------------------------------
N   -- ADC Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup ADC_Register_Masks ADC Register Masks
N * @{
N */
N
N/* SC1 Bit Fields */
N#define ADC_SC1_ADCH_MASK                        0x1Fu
N#define ADC_SC1_ADCH_SHIFT                       0
N#define ADC_SC1_ADCH(x)                          (((uint32_t)(((uint32_t)(x))<<ADC_SC1_ADCH_SHIFT))&ADC_SC1_ADCH_MASK)
N#define ADC_SC1_DIFF_MASK                        0x20u
N#define ADC_SC1_DIFF_SHIFT                       5
N#define ADC_SC1_AIEN_MASK                        0x40u
N#define ADC_SC1_AIEN_SHIFT                       6
N#define ADC_SC1_COCO_MASK                        0x80u
N#define ADC_SC1_COCO_SHIFT                       7
N/* CFG1 Bit Fields */
N#define ADC_CFG1_ADICLK_MASK                     0x3u
N#define ADC_CFG1_ADICLK_SHIFT                    0
N#define ADC_CFG1_ADICLK(x)                       (((uint32_t)(((uint32_t)(x))<<ADC_CFG1_ADICLK_SHIFT))&ADC_CFG1_ADICLK_MASK)
N#define ADC_CFG1_MODE_MASK                       0xCu
N#define ADC_CFG1_MODE_SHIFT                      2
N#define ADC_CFG1_MODE(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CFG1_MODE_SHIFT))&ADC_CFG1_MODE_MASK)
N#define ADC_CFG1_ADLSMP_MASK                     0x10u
N#define ADC_CFG1_ADLSMP_SHIFT                    4
N#define ADC_CFG1_ADIV_MASK                       0x60u
N#define ADC_CFG1_ADIV_SHIFT                      5
N#define ADC_CFG1_ADIV(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CFG1_ADIV_SHIFT))&ADC_CFG1_ADIV_MASK)
N#define ADC_CFG1_ADLPC_MASK                      0x80u
N#define ADC_CFG1_ADLPC_SHIFT                     7
N/* CFG2 Bit Fields */
N#define ADC_CFG2_ADLSTS_MASK                     0x3u
N#define ADC_CFG2_ADLSTS_SHIFT                    0
N#define ADC_CFG2_ADLSTS(x)                       (((uint32_t)(((uint32_t)(x))<<ADC_CFG2_ADLSTS_SHIFT))&ADC_CFG2_ADLSTS_MASK)
N#define ADC_CFG2_ADHSC_MASK                      0x4u
N#define ADC_CFG2_ADHSC_SHIFT                     2
N#define ADC_CFG2_ADACKEN_MASK                    0x8u
N#define ADC_CFG2_ADACKEN_SHIFT                   3
N#define ADC_CFG2_MUXSEL_MASK                     0x10u
N#define ADC_CFG2_MUXSEL_SHIFT                    4
N/* R Bit Fields */
N#define ADC_R_D_MASK                             0xFFFFu
N#define ADC_R_D_SHIFT                            0
N#define ADC_R_D(x)                               (((uint32_t)(((uint32_t)(x))<<ADC_R_D_SHIFT))&ADC_R_D_MASK)
N/* CV1 Bit Fields */
N#define ADC_CV1_CV_MASK                          0xFFFFu
N#define ADC_CV1_CV_SHIFT                         0
N#define ADC_CV1_CV(x)                            (((uint32_t)(((uint32_t)(x))<<ADC_CV1_CV_SHIFT))&ADC_CV1_CV_MASK)
N/* CV2 Bit Fields */
N#define ADC_CV2_CV_MASK                          0xFFFFu
N#define ADC_CV2_CV_SHIFT                         0
N#define ADC_CV2_CV(x)                            (((uint32_t)(((uint32_t)(x))<<ADC_CV2_CV_SHIFT))&ADC_CV2_CV_MASK)
N/* SC2 Bit Fields */
N#define ADC_SC2_REFSEL_MASK                      0x3u
N#define ADC_SC2_REFSEL_SHIFT                     0
N#define ADC_SC2_REFSEL(x)                        (((uint32_t)(((uint32_t)(x))<<ADC_SC2_REFSEL_SHIFT))&ADC_SC2_REFSEL_MASK)
N#define ADC_SC2_DMAEN_MASK                       0x4u
N#define ADC_SC2_DMAEN_SHIFT                      2
N#define ADC_SC2_ACREN_MASK                       0x8u
N#define ADC_SC2_ACREN_SHIFT                      3
N#define ADC_SC2_ACFGT_MASK                       0x10u
N#define ADC_SC2_ACFGT_SHIFT                      4
N#define ADC_SC2_ACFE_MASK                        0x20u
N#define ADC_SC2_ACFE_SHIFT                       5
N#define ADC_SC2_ADTRG_MASK                       0x40u
N#define ADC_SC2_ADTRG_SHIFT                      6
N#define ADC_SC2_ADACT_MASK                       0x80u
N#define ADC_SC2_ADACT_SHIFT                      7
N/* SC3 Bit Fields */
N#define ADC_SC3_AVGS_MASK                        0x3u
N#define ADC_SC3_AVGS_SHIFT                       0
N#define ADC_SC3_AVGS(x)                          (((uint32_t)(((uint32_t)(x))<<ADC_SC3_AVGS_SHIFT))&ADC_SC3_AVGS_MASK)
N#define ADC_SC3_AVGE_MASK                        0x4u
N#define ADC_SC3_AVGE_SHIFT                       2
N#define ADC_SC3_ADCO_MASK                        0x8u
N#define ADC_SC3_ADCO_SHIFT                       3
N#define ADC_SC3_CALF_MASK                        0x40u
N#define ADC_SC3_CALF_SHIFT                       6
N#define ADC_SC3_CAL_MASK                         0x80u
N#define ADC_SC3_CAL_SHIFT                        7
N/* OFS Bit Fields */
N#define ADC_OFS_OFS_MASK                         0xFFFFu
N#define ADC_OFS_OFS_SHIFT                        0
N#define ADC_OFS_OFS(x)                           (((uint32_t)(((uint32_t)(x))<<ADC_OFS_OFS_SHIFT))&ADC_OFS_OFS_MASK)
N/* PG Bit Fields */
N#define ADC_PG_PG_MASK                           0xFFFFu
N#define ADC_PG_PG_SHIFT                          0
N#define ADC_PG_PG(x)                             (((uint32_t)(((uint32_t)(x))<<ADC_PG_PG_SHIFT))&ADC_PG_PG_MASK)
N/* MG Bit Fields */
N#define ADC_MG_MG_MASK                           0xFFFFu
N#define ADC_MG_MG_SHIFT                          0
N#define ADC_MG_MG(x)                             (((uint32_t)(((uint32_t)(x))<<ADC_MG_MG_SHIFT))&ADC_MG_MG_MASK)
N/* CLPD Bit Fields */
N#define ADC_CLPD_CLPD_MASK                       0x3Fu
N#define ADC_CLPD_CLPD_SHIFT                      0
N#define ADC_CLPD_CLPD(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLPD_CLPD_SHIFT))&ADC_CLPD_CLPD_MASK)
N/* CLPS Bit Fields */
N#define ADC_CLPS_CLPS_MASK                       0x3Fu
N#define ADC_CLPS_CLPS_SHIFT                      0
N#define ADC_CLPS_CLPS(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLPS_CLPS_SHIFT))&ADC_CLPS_CLPS_MASK)
N/* CLP4 Bit Fields */
N#define ADC_CLP4_CLP4_MASK                       0x3FFu
N#define ADC_CLP4_CLP4_SHIFT                      0
N#define ADC_CLP4_CLP4(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLP4_CLP4_SHIFT))&ADC_CLP4_CLP4_MASK)
N/* CLP3 Bit Fields */
N#define ADC_CLP3_CLP3_MASK                       0x1FFu
N#define ADC_CLP3_CLP3_SHIFT                      0
N#define ADC_CLP3_CLP3(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLP3_CLP3_SHIFT))&ADC_CLP3_CLP3_MASK)
N/* CLP2 Bit Fields */
N#define ADC_CLP2_CLP2_MASK                       0xFFu
N#define ADC_CLP2_CLP2_SHIFT                      0
N#define ADC_CLP2_CLP2(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLP2_CLP2_SHIFT))&ADC_CLP2_CLP2_MASK)
N/* CLP1 Bit Fields */
N#define ADC_CLP1_CLP1_MASK                       0x7Fu
N#define ADC_CLP1_CLP1_SHIFT                      0
N#define ADC_CLP1_CLP1(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLP1_CLP1_SHIFT))&ADC_CLP1_CLP1_MASK)
N/* CLP0 Bit Fields */
N#define ADC_CLP0_CLP0_MASK                       0x3Fu
N#define ADC_CLP0_CLP0_SHIFT                      0
N#define ADC_CLP0_CLP0(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLP0_CLP0_SHIFT))&ADC_CLP0_CLP0_MASK)
N/* CLMD Bit Fields */
N#define ADC_CLMD_CLMD_MASK                       0x3Fu
N#define ADC_CLMD_CLMD_SHIFT                      0
N#define ADC_CLMD_CLMD(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLMD_CLMD_SHIFT))&ADC_CLMD_CLMD_MASK)
N/* CLMS Bit Fields */
N#define ADC_CLMS_CLMS_MASK                       0x3Fu
N#define ADC_CLMS_CLMS_SHIFT                      0
N#define ADC_CLMS_CLMS(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLMS_CLMS_SHIFT))&ADC_CLMS_CLMS_MASK)
N/* CLM4 Bit Fields */
N#define ADC_CLM4_CLM4_MASK                       0x3FFu
N#define ADC_CLM4_CLM4_SHIFT                      0
N#define ADC_CLM4_CLM4(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLM4_CLM4_SHIFT))&ADC_CLM4_CLM4_MASK)
N/* CLM3 Bit Fields */
N#define ADC_CLM3_CLM3_MASK                       0x1FFu
N#define ADC_CLM3_CLM3_SHIFT                      0
N#define ADC_CLM3_CLM3(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLM3_CLM3_SHIFT))&ADC_CLM3_CLM3_MASK)
N/* CLM2 Bit Fields */
N#define ADC_CLM2_CLM2_MASK                       0xFFu
N#define ADC_CLM2_CLM2_SHIFT                      0
N#define ADC_CLM2_CLM2(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLM2_CLM2_SHIFT))&ADC_CLM2_CLM2_MASK)
N/* CLM1 Bit Fields */
N#define ADC_CLM1_CLM1_MASK                       0x7Fu
N#define ADC_CLM1_CLM1_SHIFT                      0
N#define ADC_CLM1_CLM1(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLM1_CLM1_SHIFT))&ADC_CLM1_CLM1_MASK)
N/* CLM0 Bit Fields */
N#define ADC_CLM0_CLM0_MASK                       0x3Fu
N#define ADC_CLM0_CLM0_SHIFT                      0
N#define ADC_CLM0_CLM0(x)                         (((uint32_t)(((uint32_t)(x))<<ADC_CLM0_CLM0_SHIFT))&ADC_CLM0_CLM0_MASK)
N
N/**
N * @}
N */ /* end of group ADC_Register_Masks */
N
N
N/* ADC - Peripheral instance base addresses */
N/** Peripheral ADC0 base address */
N#define ADC0_BASE                                (0x4003B000u)
N/** Peripheral ADC0 base pointer */
N#define ADC0                                     ((ADC_Type *)ADC0_BASE)
N/** Array initializer of ADC peripheral base pointers */
N#define ADC_BASES                                { ADC0 }
N
N/**
N * @}
N */ /* end of group ADC_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- CMP Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup CMP_Peripheral_Access_Layer CMP Peripheral Access Layer
N * @{
N */
N
N/** CMP - Register Layout Typedef */
Ntypedef struct {
N  __IO uint8_t CR0;                                /**< CMP Control Register 0, offset: 0x0 */
X  volatile uint8_t CR0;                                 
N  __IO uint8_t CR1;                                /**< CMP Control Register 1, offset: 0x1 */
X  volatile uint8_t CR1;                                 
N  __IO uint8_t FPR;                                /**< CMP Filter Period Register, offset: 0x2 */
X  volatile uint8_t FPR;                                 
N  __IO uint8_t SCR;                                /**< CMP Status and Control Register, offset: 0x3 */
X  volatile uint8_t SCR;                                 
N  __IO uint8_t DACCR;                              /**< DAC Control Register, offset: 0x4 */
X  volatile uint8_t DACCR;                               
N  __IO uint8_t MUXCR;                              /**< MUX Control Register, offset: 0x5 */
X  volatile uint8_t MUXCR;                               
N} CMP_Type;
N
N/* ----------------------------------------------------------------------------
N   -- CMP Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup CMP_Register_Masks CMP Register Masks
N * @{
N */
N
N/* CR0 Bit Fields */
N#define CMP_CR0_HYSTCTR_MASK                     0x3u
N#define CMP_CR0_HYSTCTR_SHIFT                    0
N#define CMP_CR0_HYSTCTR(x)                       (((uint8_t)(((uint8_t)(x))<<CMP_CR0_HYSTCTR_SHIFT))&CMP_CR0_HYSTCTR_MASK)
N#define CMP_CR0_FILTER_CNT_MASK                  0x70u
N#define CMP_CR0_FILTER_CNT_SHIFT                 4
N#define CMP_CR0_FILTER_CNT(x)                    (((uint8_t)(((uint8_t)(x))<<CMP_CR0_FILTER_CNT_SHIFT))&CMP_CR0_FILTER_CNT_MASK)
N/* CR1 Bit Fields */
N#define CMP_CR1_EN_MASK                          0x1u
N#define CMP_CR1_EN_SHIFT                         0
N#define CMP_CR1_OPE_MASK                         0x2u
N#define CMP_CR1_OPE_SHIFT                        1
N#define CMP_CR1_COS_MASK                         0x4u
N#define CMP_CR1_COS_SHIFT                        2
N#define CMP_CR1_INV_MASK                         0x8u
N#define CMP_CR1_INV_SHIFT                        3
N#define CMP_CR1_PMODE_MASK                       0x10u
N#define CMP_CR1_PMODE_SHIFT                      4
N#define CMP_CR1_TRIGM_MASK                       0x20u
N#define CMP_CR1_TRIGM_SHIFT                      5
N#define CMP_CR1_WE_MASK                          0x40u
N#define CMP_CR1_WE_SHIFT                         6
N#define CMP_CR1_SE_MASK                          0x80u
N#define CMP_CR1_SE_SHIFT                         7
N/* FPR Bit Fields */
N#define CMP_FPR_FILT_PER_MASK                    0xFFu
N#define CMP_FPR_FILT_PER_SHIFT                   0
N#define CMP_FPR_FILT_PER(x)                      (((uint8_t)(((uint8_t)(x))<<CMP_FPR_FILT_PER_SHIFT))&CMP_FPR_FILT_PER_MASK)
N/* SCR Bit Fields */
N#define CMP_SCR_COUT_MASK                        0x1u
N#define CMP_SCR_COUT_SHIFT                       0
N#define CMP_SCR_CFF_MASK                         0x2u
N#define CMP_SCR_CFF_SHIFT                        1
N#define CMP_SCR_CFR_MASK                         0x4u
N#define CMP_SCR_CFR_SHIFT                        2
N#define CMP_SCR_IEF_MASK                         0x8u
N#define CMP_SCR_IEF_SHIFT                        3
N#define CMP_SCR_IER_MASK                         0x10u
N#define CMP_SCR_IER_SHIFT                        4
N#define CMP_SCR_DMAEN_MASK                       0x40u
N#define CMP_SCR_DMAEN_SHIFT                      6
N/* DACCR Bit Fields */
N#define CMP_DACCR_VOSEL_MASK                     0x3Fu
N#define CMP_DACCR_VOSEL_SHIFT                    0
N#define CMP_DACCR_VOSEL(x)                       (((uint8_t)(((uint8_t)(x))<<CMP_DACCR_VOSEL_SHIFT))&CMP_DACCR_VOSEL_MASK)
N#define CMP_DACCR_VRSEL_MASK                     0x40u
N#define CMP_DACCR_VRSEL_SHIFT                    6
N#define CMP_DACCR_DACEN_MASK                     0x80u
N#define CMP_DACCR_DACEN_SHIFT                    7
N/* MUXCR Bit Fields */
N#define CMP_MUXCR_MSEL_MASK                      0x7u
N#define CMP_MUXCR_MSEL_SHIFT                     0
N#define CMP_MUXCR_MSEL(x)                        (((uint8_t)(((uint8_t)(x))<<CMP_MUXCR_MSEL_SHIFT))&CMP_MUXCR_MSEL_MASK)
N#define CMP_MUXCR_PSEL_MASK                      0x38u
N#define CMP_MUXCR_PSEL_SHIFT                     3
N#define CMP_MUXCR_PSEL(x)                        (((uint8_t)(((uint8_t)(x))<<CMP_MUXCR_PSEL_SHIFT))&CMP_MUXCR_PSEL_MASK)
N#define CMP_MUXCR_PSTM_MASK                      0x80u
N#define CMP_MUXCR_PSTM_SHIFT                     7
N
N/**
N * @}
N */ /* end of group CMP_Register_Masks */
N
N
N/* CMP - Peripheral instance base addresses */
N/** Peripheral CMP0 base address */
N#define CMP0_BASE                                (0x40073000u)
N/** Peripheral CMP0 base pointer */
N#define CMP0                                     ((CMP_Type *)CMP0_BASE)
N/** Array initializer of CMP peripheral base pointers */
N#define CMP_BASES                                { CMP0 }
N
N/**
N * @}
N */ /* end of group CMP_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- DAC Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup DAC_Peripheral_Access_Layer DAC Peripheral Access Layer
N * @{
N */
N
N/** DAC - Register Layout Typedef */
Ntypedef struct {
N  struct {                                         /* offset: 0x0, array step: 0x2 */
N    __IO uint8_t DATL;                               /**< DAC Data Low Register, array offset: 0x0, array step: 0x2 */
X    volatile uint8_t DATL;                                
N    __IO uint8_t DATH;                               /**< DAC Data High Register, array offset: 0x1, array step: 0x2 */
X    volatile uint8_t DATH;                                
N  } DAT[2];
N       uint8_t RESERVED_0[28];
N  __IO uint8_t SR;                                 /**< DAC Status Register, offset: 0x20 */
X  volatile uint8_t SR;                                  
N  __IO uint8_t C0;                                 /**< DAC Control Register, offset: 0x21 */
X  volatile uint8_t C0;                                  
N  __IO uint8_t C1;                                 /**< DAC Control Register 1, offset: 0x22 */
X  volatile uint8_t C1;                                  
N  __IO uint8_t C2;                                 /**< DAC Control Register 2, offset: 0x23 */
X  volatile uint8_t C2;                                  
N} DAC_Type;
N
N/* ----------------------------------------------------------------------------
N   -- DAC Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup DAC_Register_Masks DAC Register Masks
N * @{
N */
N
N/* DATL Bit Fields */
N#define DAC_DATL_DATA0_MASK                      0xFFu
N#define DAC_DATL_DATA0_SHIFT                     0
N#define DAC_DATL_DATA0(x)                        (((uint8_t)(((uint8_t)(x))<<DAC_DATL_DATA0_SHIFT))&DAC_DATL_DATA0_MASK)
N/* DATH Bit Fields */
N#define DAC_DATH_DATA1_MASK                      0xFu
N#define DAC_DATH_DATA1_SHIFT                     0
N#define DAC_DATH_DATA1(x)                        (((uint8_t)(((uint8_t)(x))<<DAC_DATH_DATA1_SHIFT))&DAC_DATH_DATA1_MASK)
N/* SR Bit Fields */
N#define DAC_SR_DACBFRPBF_MASK                    0x1u
N#define DAC_SR_DACBFRPBF_SHIFT                   0
N#define DAC_SR_DACBFRPTF_MASK                    0x2u
N#define DAC_SR_DACBFRPTF_SHIFT                   1
N/* C0 Bit Fields */
N#define DAC_C0_DACBBIEN_MASK                     0x1u
N#define DAC_C0_DACBBIEN_SHIFT                    0
N#define DAC_C0_DACBTIEN_MASK                     0x2u
N#define DAC_C0_DACBTIEN_SHIFT                    1
N#define DAC_C0_LPEN_MASK                         0x8u
N#define DAC_C0_LPEN_SHIFT                        3
N#define DAC_C0_DACSWTRG_MASK                     0x10u
N#define DAC_C0_DACSWTRG_SHIFT                    4
N#define DAC_C0_DACTRGSEL_MASK                    0x20u
N#define DAC_C0_DACTRGSEL_SHIFT                   5
N#define DAC_C0_DACRFS_MASK                       0x40u
N#define DAC_C0_DACRFS_SHIFT                      6
N#define DAC_C0_DACEN_MASK                        0x80u
N#define DAC_C0_DACEN_SHIFT                       7
N/* C1 Bit Fields */
N#define DAC_C1_DACBFEN_MASK                      0x1u
N#define DAC_C1_DACBFEN_SHIFT                     0
N#define DAC_C1_DACBFMD_MASK                      0x4u
N#define DAC_C1_DACBFMD_SHIFT                     2
N#define DAC_C1_DMAEN_MASK                        0x80u
N#define DAC_C1_DMAEN_SHIFT                       7
N/* C2 Bit Fields */
N#define DAC_C2_DACBFUP_MASK                      0x1u
N#define DAC_C2_DACBFUP_SHIFT                     0
N#define DAC_C2_DACBFRP_MASK                      0x10u
N#define DAC_C2_DACBFRP_SHIFT                     4
N
N/**
N * @}
N */ /* end of group DAC_Register_Masks */
N
N
N/* DAC - Peripheral instance base addresses */
N/** Peripheral DAC0 base address */
N#define DAC0_BASE                                (0x4003F000u)
N/** Peripheral DAC0 base pointer */
N#define DAC0                                     ((DAC_Type *)DAC0_BASE)
N/** Array initializer of DAC peripheral base pointers */
N#define DAC_BASES                                { DAC0 }
N
N/**
N * @}
N */ /* end of group DAC_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- DMA Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup DMA_Peripheral_Access_Layer DMA Peripheral Access Layer
N * @{
N */
N
N/** DMA - Register Layout Typedef */
Ntypedef struct {
N       uint8_t RESERVED_0[256];
N  struct {                                         /* offset: 0x100, array step: 0x10 */
N    __IO uint32_t SAR;                               /**< Source Address Register, array offset: 0x100, array step: 0x10 */
X    volatile uint32_t SAR;                                
N    __IO uint32_t DAR;                               /**< Destination Address Register, array offset: 0x104, array step: 0x10 */
X    volatile uint32_t DAR;                                
N    union {                                          /* offset: 0x108, array step: 0x10 */
N      __IO uint32_t DSR_BCR;                           /**< DMA Status Register / Byte Count Register, array offset: 0x108, array step: 0x10 */
X      volatile uint32_t DSR_BCR;                            
N      struct {                                         /* offset: 0x108, array step: 0x10 */
N             uint8_t RESERVED_0[3];
N        __IO uint8_t DSR;                                /**< DMA_DSR0 register...DMA_DSR3 register., array offset: 0x10B, array step: 0x10 */
X        volatile uint8_t DSR;                                 
N      } DMA_DSR_ACCESS8BIT;
N    };
N    __IO uint32_t DCR;                               /**< DMA Control Register, array offset: 0x10C, array step: 0x10 */
X    volatile uint32_t DCR;                                
N  } DMA[4];
N} DMA_Type;
N
N/* ----------------------------------------------------------------------------
N   -- DMA Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup DMA_Register_Masks DMA Register Masks
N * @{
N */
N
N/* SAR Bit Fields */
N#define DMA_SAR_SAR_MASK                         0xFFFFFFFFu
N#define DMA_SAR_SAR_SHIFT                        0
N#define DMA_SAR_SAR(x)                           (((uint32_t)(((uint32_t)(x))<<DMA_SAR_SAR_SHIFT))&DMA_SAR_SAR_MASK)
N/* DAR Bit Fields */
N#define DMA_DAR_DAR_MASK                         0xFFFFFFFFu
N#define DMA_DAR_DAR_SHIFT                        0
N#define DMA_DAR_DAR(x)                           (((uint32_t)(((uint32_t)(x))<<DMA_DAR_DAR_SHIFT))&DMA_DAR_DAR_MASK)
N/* DSR_BCR Bit Fields */
N#define DMA_DSR_BCR_BCR_MASK                     0xFFFFFFu
N#define DMA_DSR_BCR_BCR_SHIFT                    0
N#define DMA_DSR_BCR_BCR(x)                       (((uint32_t)(((uint32_t)(x))<<DMA_DSR_BCR_BCR_SHIFT))&DMA_DSR_BCR_BCR_MASK)
N#define DMA_DSR_BCR_DONE_MASK                    0x1000000u
N#define DMA_DSR_BCR_DONE_SHIFT                   24
N#define DMA_DSR_BCR_BSY_MASK                     0x2000000u
N#define DMA_DSR_BCR_BSY_SHIFT                    25
N#define DMA_DSR_BCR_REQ_MASK                     0x4000000u
N#define DMA_DSR_BCR_REQ_SHIFT                    26
N#define DMA_DSR_BCR_BED_MASK                     0x10000000u
N#define DMA_DSR_BCR_BED_SHIFT                    28
N#define DMA_DSR_BCR_BES_MASK                     0x20000000u
N#define DMA_DSR_BCR_BES_SHIFT                    29
N#define DMA_DSR_BCR_CE_MASK                      0x40000000u
N#define DMA_DSR_BCR_CE_SHIFT                     30
N/* DCR Bit Fields */
N#define DMA_DCR_LCH2_MASK                        0x3u
N#define DMA_DCR_LCH2_SHIFT                       0
N#define DMA_DCR_LCH2(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_DCR_LCH2_SHIFT))&DMA_DCR_LCH2_MASK)
N#define DMA_DCR_LCH1_MASK                        0xCu
N#define DMA_DCR_LCH1_SHIFT                       2
N#define DMA_DCR_LCH1(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_DCR_LCH1_SHIFT))&DMA_DCR_LCH1_MASK)
N#define DMA_DCR_LINKCC_MASK                      0x30u
N#define DMA_DCR_LINKCC_SHIFT                     4
N#define DMA_DCR_LINKCC(x)                        (((uint32_t)(((uint32_t)(x))<<DMA_DCR_LINKCC_SHIFT))&DMA_DCR_LINKCC_MASK)
N#define DMA_DCR_D_REQ_MASK                       0x80u
N#define DMA_DCR_D_REQ_SHIFT                      7
N#define DMA_DCR_DMOD_MASK                        0xF00u
N#define DMA_DCR_DMOD_SHIFT                       8
N#define DMA_DCR_DMOD(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_DCR_DMOD_SHIFT))&DMA_DCR_DMOD_MASK)
N#define DMA_DCR_SMOD_MASK                        0xF000u
N#define DMA_DCR_SMOD_SHIFT                       12
N#define DMA_DCR_SMOD(x)                          (((uint32_t)(((uint32_t)(x))<<DMA_DCR_SMOD_SHIFT))&DMA_DCR_SMOD_MASK)
N#define DMA_DCR_START_MASK                       0x10000u
N#define DMA_DCR_START_SHIFT                      16
N#define DMA_DCR_DSIZE_MASK                       0x60000u
N#define DMA_DCR_DSIZE_SHIFT                      17
N#define DMA_DCR_DSIZE(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_DCR_DSIZE_SHIFT))&DMA_DCR_DSIZE_MASK)
N#define DMA_DCR_DINC_MASK                        0x80000u
N#define DMA_DCR_DINC_SHIFT                       19
N#define DMA_DCR_SSIZE_MASK                       0x300000u
N#define DMA_DCR_SSIZE_SHIFT                      20
N#define DMA_DCR_SSIZE(x)                         (((uint32_t)(((uint32_t)(x))<<DMA_DCR_SSIZE_SHIFT))&DMA_DCR_SSIZE_MASK)
N#define DMA_DCR_SINC_MASK                        0x400000u
N#define DMA_DCR_SINC_SHIFT                       22
N#define DMA_DCR_EADREQ_MASK                      0x800000u
N#define DMA_DCR_EADREQ_SHIFT                     23
N#define DMA_DCR_AA_MASK                          0x10000000u
N#define DMA_DCR_AA_SHIFT                         28
N#define DMA_DCR_CS_MASK                          0x20000000u
N#define DMA_DCR_CS_SHIFT                         29
N#define DMA_DCR_ERQ_MASK                         0x40000000u
N#define DMA_DCR_ERQ_SHIFT                        30
N#define DMA_DCR_EINT_MASK                        0x80000000u
N#define DMA_DCR_EINT_SHIFT                       31
N
N/**
N * @}
N */ /* end of group DMA_Register_Masks */
N
N
N/* DMA - Peripheral instance base addresses */
N/** Peripheral DMA base address */
N#define DMA_BASE                                 (0x40008000u)
N/** Peripheral DMA base pointer */
N#define DMA0                                     ((DMA_Type *)DMA_BASE)
N/** Array initializer of DMA peripheral base pointers */
N#define DMA_BASES                                { DMA0 }
N
N/**
N * @}
N */ /* end of group DMA_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- DMAMUX Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup DMAMUX_Peripheral_Access_Layer DMAMUX Peripheral Access Layer
N * @{
N */
N
N/** DMAMUX - Register Layout Typedef */
Ntypedef struct {
N  __IO uint8_t CHCFG[4];                           /**< Channel Configuration register, array offset: 0x0, array step: 0x1 */
X  volatile uint8_t CHCFG[4];                            
N} DMAMUX_Type;
N
N/* ----------------------------------------------------------------------------
N   -- DMAMUX Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup DMAMUX_Register_Masks DMAMUX Register Masks
N * @{
N */
N
N/* CHCFG Bit Fields */
N#define DMAMUX_CHCFG_SOURCE_MASK                 0x3Fu
N#define DMAMUX_CHCFG_SOURCE_SHIFT                0
N#define DMAMUX_CHCFG_SOURCE(x)                   (((uint8_t)(((uint8_t)(x))<<DMAMUX_CHCFG_SOURCE_SHIFT))&DMAMUX_CHCFG_SOURCE_MASK)
N#define DMAMUX_CHCFG_TRIG_MASK                   0x40u
N#define DMAMUX_CHCFG_TRIG_SHIFT                  6
N#define DMAMUX_CHCFG_ENBL_MASK                   0x80u
N#define DMAMUX_CHCFG_ENBL_SHIFT                  7
N
N/**
N * @}
N */ /* end of group DMAMUX_Register_Masks */
N
N
N/* DMAMUX - Peripheral instance base addresses */
N/** Peripheral DMAMUX0 base address */
N#define DMAMUX0_BASE                             (0x40021000u)
N/** Peripheral DMAMUX0 base pointer */
N#define DMAMUX0                                  ((DMAMUX_Type *)DMAMUX0_BASE)
N/** Array initializer of DMAMUX peripheral base pointers */
N#define DMAMUX_BASES                             { DMAMUX0 }
N
N/**
N * @}
N */ /* end of group DMAMUX_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- FGPIO Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup FGPIO_Peripheral_Access_Layer FGPIO Peripheral Access Layer
N * @{
N */
N
N/** FGPIO - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t PDOR;                              /**< Port Data Output Register, offset: 0x0 */
X  volatile uint32_t PDOR;                               
N  __O  uint32_t PSOR;                              /**< Port Set Output Register, offset: 0x4 */
X  volatile  uint32_t PSOR;                               
N  __O  uint32_t PCOR;                              /**< Port Clear Output Register, offset: 0x8 */
X  volatile  uint32_t PCOR;                               
N  __O  uint32_t PTOR;                              /**< Port Toggle Output Register, offset: 0xC */
X  volatile  uint32_t PTOR;                               
N  __I  uint32_t PDIR;                              /**< Port Data Input Register, offset: 0x10 */
X  volatile const  uint32_t PDIR;                               
N  __IO uint32_t PDDR;                              /**< Port Data Direction Register, offset: 0x14 */
X  volatile uint32_t PDDR;                               
N} FGPIO_Type;
N
N/* ----------------------------------------------------------------------------
N   -- FGPIO Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup FGPIO_Register_Masks FGPIO Register Masks
N * @{
N */
N
N/* PDOR Bit Fields */
N#define FGPIO_PDOR_PDO_MASK                      0xFFFFFFFFu
N#define FGPIO_PDOR_PDO_SHIFT                     0
N#define FGPIO_PDOR_PDO(x)                        (((uint32_t)(((uint32_t)(x))<<FGPIO_PDOR_PDO_SHIFT))&FGPIO_PDOR_PDO_MASK)
N/* PSOR Bit Fields */
N#define FGPIO_PSOR_PTSO_MASK                     0xFFFFFFFFu
N#define FGPIO_PSOR_PTSO_SHIFT                    0
N#define FGPIO_PSOR_PTSO(x)                       (((uint32_t)(((uint32_t)(x))<<FGPIO_PSOR_PTSO_SHIFT))&FGPIO_PSOR_PTSO_MASK)
N/* PCOR Bit Fields */
N#define FGPIO_PCOR_PTCO_MASK                     0xFFFFFFFFu
N#define FGPIO_PCOR_PTCO_SHIFT                    0
N#define FGPIO_PCOR_PTCO(x)                       (((uint32_t)(((uint32_t)(x))<<FGPIO_PCOR_PTCO_SHIFT))&FGPIO_PCOR_PTCO_MASK)
N/* PTOR Bit Fields */
N#define FGPIO_PTOR_PTTO_MASK                     0xFFFFFFFFu
N#define FGPIO_PTOR_PTTO_SHIFT                    0
N#define FGPIO_PTOR_PTTO(x)                       (((uint32_t)(((uint32_t)(x))<<FGPIO_PTOR_PTTO_SHIFT))&FGPIO_PTOR_PTTO_MASK)
N/* PDIR Bit Fields */
N#define FGPIO_PDIR_PDI_MASK                      0xFFFFFFFFu
N#define FGPIO_PDIR_PDI_SHIFT                     0
N#define FGPIO_PDIR_PDI(x)                        (((uint32_t)(((uint32_t)(x))<<FGPIO_PDIR_PDI_SHIFT))&FGPIO_PDIR_PDI_MASK)
N/* PDDR Bit Fields */
N#define FGPIO_PDDR_PDD_MASK                      0xFFFFFFFFu
N#define FGPIO_PDDR_PDD_SHIFT                     0
N#define FGPIO_PDDR_PDD(x)                        (((uint32_t)(((uint32_t)(x))<<FGPIO_PDDR_PDD_SHIFT))&FGPIO_PDDR_PDD_MASK)
N
N/**
N * @}
N */ /* end of group FGPIO_Register_Masks */
N
N
N/* FGPIO - Peripheral instance base addresses */
N/** Peripheral FPTA base address */
N#define FPTA_BASE                                (0xF80FF000u)
N/** Peripheral FPTA base pointer */
N#define FPTA                                     ((FGPIO_Type *)FPTA_BASE)
N/** Peripheral FPTB base address */
N#define FPTB_BASE                                (0xF80FF040u)
N/** Peripheral FPTB base pointer */
N#define FPTB                                     ((FGPIO_Type *)FPTB_BASE)
N/** Peripheral FPTC base address */
N#define FPTC_BASE                                (0xF80FF080u)
N/** Peripheral FPTC base pointer */
N#define FPTC                                     ((FGPIO_Type *)FPTC_BASE)
N/** Peripheral FPTD base address */
N#define FPTD_BASE                                (0xF80FF0C0u)
N/** Peripheral FPTD base pointer */
N#define FPTD                                     ((FGPIO_Type *)FPTD_BASE)
N/** Peripheral FPTE base address */
N#define FPTE_BASE                                (0xF80FF100u)
N/** Peripheral FPTE base pointer */
N#define FPTE                                     ((FGPIO_Type *)FPTE_BASE)
N/** Array initializer of FGPIO peripheral base pointers */
N#define FGPIO_BASES                              { FPTA, FPTB, FPTC, FPTD, FPTE }
N
N/**
N * @}
N */ /* end of group FGPIO_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- FTFA Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup FTFA_Peripheral_Access_Layer FTFA Peripheral Access Layer
N * @{
N */
N
N/** FTFA - Register Layout Typedef */
Ntypedef struct {
N  __IO uint8_t FSTAT;                              /**< Flash Status Register, offset: 0x0 */
X  volatile uint8_t FSTAT;                               
N  __IO uint8_t FCNFG;                              /**< Flash Configuration Register, offset: 0x1 */
X  volatile uint8_t FCNFG;                               
N  __I  uint8_t FSEC;                               /**< Flash Security Register, offset: 0x2 */
X  volatile const  uint8_t FSEC;                                
N  __I  uint8_t FOPT;                               /**< Flash Option Register, offset: 0x3 */
X  volatile const  uint8_t FOPT;                                
N  __IO uint8_t FCCOB3;                             /**< Flash Common Command Object Registers, offset: 0x4 */
X  volatile uint8_t FCCOB3;                              
N  __IO uint8_t FCCOB2;                             /**< Flash Common Command Object Registers, offset: 0x5 */
X  volatile uint8_t FCCOB2;                              
N  __IO uint8_t FCCOB1;                             /**< Flash Common Command Object Registers, offset: 0x6 */
X  volatile uint8_t FCCOB1;                              
N  __IO uint8_t FCCOB0;                             /**< Flash Common Command Object Registers, offset: 0x7 */
X  volatile uint8_t FCCOB0;                              
N  __IO uint8_t FCCOB7;                             /**< Flash Common Command Object Registers, offset: 0x8 */
X  volatile uint8_t FCCOB7;                              
N  __IO uint8_t FCCOB6;                             /**< Flash Common Command Object Registers, offset: 0x9 */
X  volatile uint8_t FCCOB6;                              
N  __IO uint8_t FCCOB5;                             /**< Flash Common Command Object Registers, offset: 0xA */
X  volatile uint8_t FCCOB5;                              
N  __IO uint8_t FCCOB4;                             /**< Flash Common Command Object Registers, offset: 0xB */
X  volatile uint8_t FCCOB4;                              
N  __IO uint8_t FCCOBB;                             /**< Flash Common Command Object Registers, offset: 0xC */
X  volatile uint8_t FCCOBB;                              
N  __IO uint8_t FCCOBA;                             /**< Flash Common Command Object Registers, offset: 0xD */
X  volatile uint8_t FCCOBA;                              
N  __IO uint8_t FCCOB9;                             /**< Flash Common Command Object Registers, offset: 0xE */
X  volatile uint8_t FCCOB9;                              
N  __IO uint8_t FCCOB8;                             /**< Flash Common Command Object Registers, offset: 0xF */
X  volatile uint8_t FCCOB8;                              
N  __IO uint8_t FPROT3;                             /**< Program Flash Protection Registers, offset: 0x10 */
X  volatile uint8_t FPROT3;                              
N  __IO uint8_t FPROT2;                             /**< Program Flash Protection Registers, offset: 0x11 */
X  volatile uint8_t FPROT2;                              
N  __IO uint8_t FPROT1;                             /**< Program Flash Protection Registers, offset: 0x12 */
X  volatile uint8_t FPROT1;                              
N  __IO uint8_t FPROT0;                             /**< Program Flash Protection Registers, offset: 0x13 */
X  volatile uint8_t FPROT0;                              
N} FTFA_Type;
N
N/* ----------------------------------------------------------------------------
N   -- FTFA Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup FTFA_Register_Masks FTFA Register Masks
N * @{
N */
N
N/* FSTAT Bit Fields */
N#define FTFA_FSTAT_MGSTAT0_MASK                  0x1u
N#define FTFA_FSTAT_MGSTAT0_SHIFT                 0
N#define FTFA_FSTAT_FPVIOL_MASK                   0x10u
N#define FTFA_FSTAT_FPVIOL_SHIFT                  4
N#define FTFA_FSTAT_ACCERR_MASK                   0x20u
N#define FTFA_FSTAT_ACCERR_SHIFT                  5
N#define FTFA_FSTAT_RDCOLERR_MASK                 0x40u
N#define FTFA_FSTAT_RDCOLERR_SHIFT                6
N#define FTFA_FSTAT_CCIF_MASK                     0x80u
N#define FTFA_FSTAT_CCIF_SHIFT                    7
N/* FCNFG Bit Fields */
N#define FTFA_FCNFG_ERSSUSP_MASK                  0x10u
N#define FTFA_FCNFG_ERSSUSP_SHIFT                 4
N#define FTFA_FCNFG_ERSAREQ_MASK                  0x20u
N#define FTFA_FCNFG_ERSAREQ_SHIFT                 5
N#define FTFA_FCNFG_RDCOLLIE_MASK                 0x40u
N#define FTFA_FCNFG_RDCOLLIE_SHIFT                6
N#define FTFA_FCNFG_CCIE_MASK                     0x80u
N#define FTFA_FCNFG_CCIE_SHIFT                    7
N/* FSEC Bit Fields */
N#define FTFA_FSEC_SEC_MASK                       0x3u
N#define FTFA_FSEC_SEC_SHIFT                      0
N#define FTFA_FSEC_SEC(x)                         (((uint8_t)(((uint8_t)(x))<<FTFA_FSEC_SEC_SHIFT))&FTFA_FSEC_SEC_MASK)
N#define FTFA_FSEC_FSLACC_MASK                    0xCu
N#define FTFA_FSEC_FSLACC_SHIFT                   2
N#define FTFA_FSEC_FSLACC(x)                      (((uint8_t)(((uint8_t)(x))<<FTFA_FSEC_FSLACC_SHIFT))&FTFA_FSEC_FSLACC_MASK)
N#define FTFA_FSEC_MEEN_MASK                      0x30u
N#define FTFA_FSEC_MEEN_SHIFT                     4
N#define FTFA_FSEC_MEEN(x)                        (((uint8_t)(((uint8_t)(x))<<FTFA_FSEC_MEEN_SHIFT))&FTFA_FSEC_MEEN_MASK)
N#define FTFA_FSEC_KEYEN_MASK                     0xC0u
N#define FTFA_FSEC_KEYEN_SHIFT                    6
N#define FTFA_FSEC_KEYEN(x)                       (((uint8_t)(((uint8_t)(x))<<FTFA_FSEC_KEYEN_SHIFT))&FTFA_FSEC_KEYEN_MASK)
N/* FOPT Bit Fields */
N#define FTFA_FOPT_OPT_MASK                       0xFFu
N#define FTFA_FOPT_OPT_SHIFT                      0
N#define FTFA_FOPT_OPT(x)                         (((uint8_t)(((uint8_t)(x))<<FTFA_FOPT_OPT_SHIFT))&FTFA_FOPT_OPT_MASK)
N/* FCCOB3 Bit Fields */
N#define FTFA_FCCOB3_CCOBn_MASK                   0xFFu
N#define FTFA_FCCOB3_CCOBn_SHIFT                  0
N#define FTFA_FCCOB3_CCOBn(x)                     (((uint8_t)(((uint8_t)(x))<<FTFA_FCCOB3_CCOBn_SHIFT))&FTFA_FCCOB3_CCOBn_MASK)
N/* FCCOB2 Bit Fields */
N#define FTFA_FCCOB2_CCOBn_MASK                   0xFFu
N#define FTFA_FCCOB2_CCOBn_SHIFT                  0
N#define FTFA_FCCOB2_CCOBn(x)                     (((uint8_t)(((uint8_t)(x))<<FTFA_FCCOB2_CCOBn_SHIFT))&FTFA_FCCOB2_CCOBn_MASK)
N/* FCCOB1 Bit Fields */
N#define FTFA_FCCOB1_CCOBn_MASK                   0xFFu
N#define FTFA_FCCOB1_CCOBn_SHIFT                  0
N#define FTFA_FCCOB1_CCOBn(x)                     (((uint8_t)(((uint8_t)(x))<<FTFA_FCCOB1_CCOBn_SHIFT))&FTFA_FCCOB1_CCOBn_MASK)
N/* FCCOB0 Bit Fields */
N#define FTFA_FCCOB0_CCOBn_MASK                   0xFFu
N#define FTFA_FCCOB0_CCOBn_SHIFT                  0
N#define FTFA_FCCOB0_CCOBn(x)                     (((uint8_t)(((uint8_t)(x))<<FTFA_FCCOB0_CCOBn_SHIFT))&FTFA_FCCOB0_CCOBn_MASK)
N/* FCCOB7 Bit Fields */
N#define FTFA_FCCOB7_CCOBn_MASK                   0xFFu
N#define FTFA_FCCOB7_CCOBn_SHIFT                  0
N#define FTFA_FCCOB7_CCOBn(x)                     (((uint8_t)(((uint8_t)(x))<<FTFA_FCCOB7_CCOBn_SHIFT))&FTFA_FCCOB7_CCOBn_MASK)
N/* FCCOB6 Bit Fields */
N#define FTFA_FCCOB6_CCOBn_MASK                   0xFFu
N#define FTFA_FCCOB6_CCOBn_SHIFT                  0
N#define FTFA_FCCOB6_CCOBn(x)                     (((uint8_t)(((uint8_t)(x))<<FTFA_FCCOB6_CCOBn_SHIFT))&FTFA_FCCOB6_CCOBn_MASK)
N/* FCCOB5 Bit Fields */
N#define FTFA_FCCOB5_CCOBn_MASK                   0xFFu
N#define FTFA_FCCOB5_CCOBn_SHIFT                  0
N#define FTFA_FCCOB5_CCOBn(x)                     (((uint8_t)(((uint8_t)(x))<<FTFA_FCCOB5_CCOBn_SHIFT))&FTFA_FCCOB5_CCOBn_MASK)
N/* FCCOB4 Bit Fields */
N#define FTFA_FCCOB4_CCOBn_MASK                   0xFFu
N#define FTFA_FCCOB4_CCOBn_SHIFT                  0
N#define FTFA_FCCOB4_CCOBn(x)                     (((uint8_t)(((uint8_t)(x))<<FTFA_FCCOB4_CCOBn_SHIFT))&FTFA_FCCOB4_CCOBn_MASK)
N/* FCCOBB Bit Fields */
N#define FTFA_FCCOBB_CCOBn_MASK                   0xFFu
N#define FTFA_FCCOBB_CCOBn_SHIFT                  0
N#define FTFA_FCCOBB_CCOBn(x)                     (((uint8_t)(((uint8_t)(x))<<FTFA_FCCOBB_CCOBn_SHIFT))&FTFA_FCCOBB_CCOBn_MASK)
N/* FCCOBA Bit Fields */
N#define FTFA_FCCOBA_CCOBn_MASK                   0xFFu
N#define FTFA_FCCOBA_CCOBn_SHIFT                  0
N#define FTFA_FCCOBA_CCOBn(x)                     (((uint8_t)(((uint8_t)(x))<<FTFA_FCCOBA_CCOBn_SHIFT))&FTFA_FCCOBA_CCOBn_MASK)
N/* FCCOB9 Bit Fields */
N#define FTFA_FCCOB9_CCOBn_MASK                   0xFFu
N#define FTFA_FCCOB9_CCOBn_SHIFT                  0
N#define FTFA_FCCOB9_CCOBn(x)                     (((uint8_t)(((uint8_t)(x))<<FTFA_FCCOB9_CCOBn_SHIFT))&FTFA_FCCOB9_CCOBn_MASK)
N/* FCCOB8 Bit Fields */
N#define FTFA_FCCOB8_CCOBn_MASK                   0xFFu
N#define FTFA_FCCOB8_CCOBn_SHIFT                  0
N#define FTFA_FCCOB8_CCOBn(x)                     (((uint8_t)(((uint8_t)(x))<<FTFA_FCCOB8_CCOBn_SHIFT))&FTFA_FCCOB8_CCOBn_MASK)
N/* FPROT3 Bit Fields */
N#define FTFA_FPROT3_PROT_MASK                    0xFFu
N#define FTFA_FPROT3_PROT_SHIFT                   0
N#define FTFA_FPROT3_PROT(x)                      (((uint8_t)(((uint8_t)(x))<<FTFA_FPROT3_PROT_SHIFT))&FTFA_FPROT3_PROT_MASK)
N/* FPROT2 Bit Fields */
N#define FTFA_FPROT2_PROT_MASK                    0xFFu
N#define FTFA_FPROT2_PROT_SHIFT                   0
N#define FTFA_FPROT2_PROT(x)                      (((uint8_t)(((uint8_t)(x))<<FTFA_FPROT2_PROT_SHIFT))&FTFA_FPROT2_PROT_MASK)
N/* FPROT1 Bit Fields */
N#define FTFA_FPROT1_PROT_MASK                    0xFFu
N#define FTFA_FPROT1_PROT_SHIFT                   0
N#define FTFA_FPROT1_PROT(x)                      (((uint8_t)(((uint8_t)(x))<<FTFA_FPROT1_PROT_SHIFT))&FTFA_FPROT1_PROT_MASK)
N/* FPROT0 Bit Fields */
N#define FTFA_FPROT0_PROT_MASK                    0xFFu
N#define FTFA_FPROT0_PROT_SHIFT                   0
N#define FTFA_FPROT0_PROT(x)                      (((uint8_t)(((uint8_t)(x))<<FTFA_FPROT0_PROT_SHIFT))&FTFA_FPROT0_PROT_MASK)
N
N/**
N * @}
N */ /* end of group FTFA_Register_Masks */
N
N
N/* FTFA - Peripheral instance base addresses */
N/** Peripheral FTFA base address */
N#define FTFA_BASE                                (0x40020000u)
N/** Peripheral FTFA base pointer */
N#define FTFA                                     ((FTFA_Type *)FTFA_BASE)
N/** Array initializer of FTFA peripheral base pointers */
N#define FTFA_BASES                               { FTFA }
N
N/**
N * @}
N */ /* end of group FTFA_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- GPIO Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup GPIO_Peripheral_Access_Layer GPIO Peripheral Access Layer
N * @{
N */
N
N/** GPIO - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t PDOR;                              /**< Port Data Output Register, offset: 0x0 */
X  volatile uint32_t PDOR;                               
N  __O  uint32_t PSOR;                              /**< Port Set Output Register, offset: 0x4 */
X  volatile  uint32_t PSOR;                               
N  __O  uint32_t PCOR;                              /**< Port Clear Output Register, offset: 0x8 */
X  volatile  uint32_t PCOR;                               
N  __O  uint32_t PTOR;                              /**< Port Toggle Output Register, offset: 0xC */
X  volatile  uint32_t PTOR;                               
N  __I  uint32_t PDIR;                              /**< Port Data Input Register, offset: 0x10 */
X  volatile const  uint32_t PDIR;                               
N  __IO uint32_t PDDR;                              /**< Port Data Direction Register, offset: 0x14 */
X  volatile uint32_t PDDR;                               
N} GPIO_Type;
N
N/* ----------------------------------------------------------------------------
N   -- GPIO Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup GPIO_Register_Masks GPIO Register Masks
N * @{
N */
N
N/* PDOR Bit Fields */
N#define GPIO_PDOR_PDO_MASK                       0xFFFFFFFFu
N#define GPIO_PDOR_PDO_SHIFT                      0
N#define GPIO_PDOR_PDO(x)                         (((uint32_t)(((uint32_t)(x))<<GPIO_PDOR_PDO_SHIFT))&GPIO_PDOR_PDO_MASK)
N/* PSOR Bit Fields */
N#define GPIO_PSOR_PTSO_MASK                      0xFFFFFFFFu
N#define GPIO_PSOR_PTSO_SHIFT                     0
N#define GPIO_PSOR_PTSO(x)                        (((uint32_t)(((uint32_t)(x))<<GPIO_PSOR_PTSO_SHIFT))&GPIO_PSOR_PTSO_MASK)
N/* PCOR Bit Fields */
N#define GPIO_PCOR_PTCO_MASK                      0xFFFFFFFFu
N#define GPIO_PCOR_PTCO_SHIFT                     0
N#define GPIO_PCOR_PTCO(x)                        (((uint32_t)(((uint32_t)(x))<<GPIO_PCOR_PTCO_SHIFT))&GPIO_PCOR_PTCO_MASK)
N/* PTOR Bit Fields */
N#define GPIO_PTOR_PTTO_MASK                      0xFFFFFFFFu
N#define GPIO_PTOR_PTTO_SHIFT                     0
N#define GPIO_PTOR_PTTO(x)                        (((uint32_t)(((uint32_t)(x))<<GPIO_PTOR_PTTO_SHIFT))&GPIO_PTOR_PTTO_MASK)
N/* PDIR Bit Fields */
N#define GPIO_PDIR_PDI_MASK                       0xFFFFFFFFu
N#define GPIO_PDIR_PDI_SHIFT                      0
N#define GPIO_PDIR_PDI(x)                         (((uint32_t)(((uint32_t)(x))<<GPIO_PDIR_PDI_SHIFT))&GPIO_PDIR_PDI_MASK)
N/* PDDR Bit Fields */
N#define GPIO_PDDR_PDD_MASK                       0xFFFFFFFFu
N#define GPIO_PDDR_PDD_SHIFT                      0
N#define GPIO_PDDR_PDD(x)                         (((uint32_t)(((uint32_t)(x))<<GPIO_PDDR_PDD_SHIFT))&GPIO_PDDR_PDD_MASK)
N
N/**
N * @}
N */ /* end of group GPIO_Register_Masks */
N
N
N/* GPIO - Peripheral instance base addresses */
N/** Peripheral PTA base address */
N#define PTA_BASE                                 (0x400FF000u)
N/** Peripheral PTA base pointer */
N#define PTA                                      ((GPIO_Type *)PTA_BASE)
N/** Peripheral PTB base address */
N#define PTB_BASE                                 (0x400FF040u)
N/** Peripheral PTB base pointer */
N#define PTB                                      ((GPIO_Type *)PTB_BASE)
N/** Peripheral PTC base address */
N#define PTC_BASE                                 (0x400FF080u)
N/** Peripheral PTC base pointer */
N#define PTC                                      ((GPIO_Type *)PTC_BASE)
N/** Peripheral PTD base address */
N#define PTD_BASE                                 (0x400FF0C0u)
N/** Peripheral PTD base pointer */
N#define PTD                                      ((GPIO_Type *)PTD_BASE)
N/** Peripheral PTE base address */
N#define PTE_BASE                                 (0x400FF100u)
N/** Peripheral PTE base pointer */
N#define PTE                                      ((GPIO_Type *)PTE_BASE)
N/** Array initializer of GPIO peripheral base pointers */
N#define GPIO_BASES                               { PTA, PTB, PTC, PTD, PTE }
N
N/**
N * @}
N */ /* end of group GPIO_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- I2C Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup I2C_Peripheral_Access_Layer I2C Peripheral Access Layer
N * @{
N */
N
N/** I2C - Register Layout Typedef */
Ntypedef struct {
N  __IO uint8_t A1;                                 /**< I2C Address Register 1, offset: 0x0 */
X  volatile uint8_t A1;                                  
N  __IO uint8_t F;                                  /**< I2C Frequency Divider register, offset: 0x1 */
X  volatile uint8_t F;                                   
N  __IO uint8_t C1;                                 /**< I2C Control Register 1, offset: 0x2 */
X  volatile uint8_t C1;                                  
N  __IO uint8_t S;                                  /**< I2C Status register, offset: 0x3 */
X  volatile uint8_t S;                                   
N  __IO uint8_t D;                                  /**< I2C Data I/O register, offset: 0x4 */
X  volatile uint8_t D;                                   
N  __IO uint8_t C2;                                 /**< I2C Control Register 2, offset: 0x5 */
X  volatile uint8_t C2;                                  
N  __IO uint8_t FLT;                                /**< I2C Programmable Input Glitch Filter register, offset: 0x6 */
X  volatile uint8_t FLT;                                 
N  __IO uint8_t RA;                                 /**< I2C Range Address register, offset: 0x7 */
X  volatile uint8_t RA;                                  
N  __IO uint8_t SMB;                                /**< I2C SMBus Control and Status register, offset: 0x8 */
X  volatile uint8_t SMB;                                 
N  __IO uint8_t A2;                                 /**< I2C Address Register 2, offset: 0x9 */
X  volatile uint8_t A2;                                  
N  __IO uint8_t SLTH;                               /**< I2C SCL Low Timeout Register High, offset: 0xA */
X  volatile uint8_t SLTH;                                
N  __IO uint8_t SLTL;                               /**< I2C SCL Low Timeout Register Low, offset: 0xB */
X  volatile uint8_t SLTL;                                
N} I2C_Type;
N
N/* ----------------------------------------------------------------------------
N   -- I2C Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup I2C_Register_Masks I2C Register Masks
N * @{
N */
N
N/* A1 Bit Fields */
N#define I2C_A1_AD_MASK                           0xFEu
N#define I2C_A1_AD_SHIFT                          1
N#define I2C_A1_AD(x)                             (((uint8_t)(((uint8_t)(x))<<I2C_A1_AD_SHIFT))&I2C_A1_AD_MASK)
N/* F Bit Fields */
N#define I2C_F_ICR_MASK                           0x3Fu
N#define I2C_F_ICR_SHIFT                          0
N#define I2C_F_ICR(x)                             (((uint8_t)(((uint8_t)(x))<<I2C_F_ICR_SHIFT))&I2C_F_ICR_MASK)
N#define I2C_F_MULT_MASK                          0xC0u
N#define I2C_F_MULT_SHIFT                         6
N#define I2C_F_MULT(x)                            (((uint8_t)(((uint8_t)(x))<<I2C_F_MULT_SHIFT))&I2C_F_MULT_MASK)
N/* C1 Bit Fields */
N#define I2C_C1_DMAEN_MASK                        0x1u
N#define I2C_C1_DMAEN_SHIFT                       0
N#define I2C_C1_WUEN_MASK                         0x2u
N#define I2C_C1_WUEN_SHIFT                        1
N#define I2C_C1_RSTA_MASK                         0x4u
N#define I2C_C1_RSTA_SHIFT                        2
N#define I2C_C1_TXAK_MASK                         0x8u
N#define I2C_C1_TXAK_SHIFT                        3
N#define I2C_C1_TX_MASK                           0x10u
N#define I2C_C1_TX_SHIFT                          4
N#define I2C_C1_MST_MASK                          0x20u
N#define I2C_C1_MST_SHIFT                         5
N#define I2C_C1_IICIE_MASK                        0x40u
N#define I2C_C1_IICIE_SHIFT                       6
N#define I2C_C1_IICEN_MASK                        0x80u
N#define I2C_C1_IICEN_SHIFT                       7
N/* S Bit Fields */
N#define I2C_S_RXAK_MASK                          0x1u
N#define I2C_S_RXAK_SHIFT                         0
N#define I2C_S_IICIF_MASK                         0x2u
N#define I2C_S_IICIF_SHIFT                        1
N#define I2C_S_SRW_MASK                           0x4u
N#define I2C_S_SRW_SHIFT                          2
N#define I2C_S_RAM_MASK                           0x8u
N#define I2C_S_RAM_SHIFT                          3
N#define I2C_S_ARBL_MASK                          0x10u
N#define I2C_S_ARBL_SHIFT                         4
N#define I2C_S_BUSY_MASK                          0x20u
N#define I2C_S_BUSY_SHIFT                         5
N#define I2C_S_IAAS_MASK                          0x40u
N#define I2C_S_IAAS_SHIFT                         6
N#define I2C_S_TCF_MASK                           0x80u
N#define I2C_S_TCF_SHIFT                          7
N/* D Bit Fields */
N#define I2C_D_DATA_MASK                          0xFFu
N#define I2C_D_DATA_SHIFT                         0
N#define I2C_D_DATA(x)                            (((uint8_t)(((uint8_t)(x))<<I2C_D_DATA_SHIFT))&I2C_D_DATA_MASK)
N/* C2 Bit Fields */
N#define I2C_C2_AD_MASK                           0x7u
N#define I2C_C2_AD_SHIFT                          0
N#define I2C_C2_AD(x)                             (((uint8_t)(((uint8_t)(x))<<I2C_C2_AD_SHIFT))&I2C_C2_AD_MASK)
N#define I2C_C2_RMEN_MASK                         0x8u
N#define I2C_C2_RMEN_SHIFT                        3
N#define I2C_C2_SBRC_MASK                         0x10u
N#define I2C_C2_SBRC_SHIFT                        4
N#define I2C_C2_HDRS_MASK                         0x20u
N#define I2C_C2_HDRS_SHIFT                        5
N#define I2C_C2_ADEXT_MASK                        0x40u
N#define I2C_C2_ADEXT_SHIFT                       6
N#define I2C_C2_GCAEN_MASK                        0x80u
N#define I2C_C2_GCAEN_SHIFT                       7
N/* FLT Bit Fields */
N#define I2C_FLT_FLT_MASK                         0x1Fu
N#define I2C_FLT_FLT_SHIFT                        0
N#define I2C_FLT_FLT(x)                           (((uint8_t)(((uint8_t)(x))<<I2C_FLT_FLT_SHIFT))&I2C_FLT_FLT_MASK)
N#define I2C_FLT_STOPIE_MASK                      0x20u
N#define I2C_FLT_STOPIE_SHIFT                     5
N#define I2C_FLT_STOPF_MASK                       0x40u
N#define I2C_FLT_STOPF_SHIFT                      6
N#define I2C_FLT_SHEN_MASK                        0x80u
N#define I2C_FLT_SHEN_SHIFT                       7
N/* RA Bit Fields */
N#define I2C_RA_RAD_MASK                          0xFEu
N#define I2C_RA_RAD_SHIFT                         1
N#define I2C_RA_RAD(x)                            (((uint8_t)(((uint8_t)(x))<<I2C_RA_RAD_SHIFT))&I2C_RA_RAD_MASK)
N/* SMB Bit Fields */
N#define I2C_SMB_SHTF2IE_MASK                     0x1u
N#define I2C_SMB_SHTF2IE_SHIFT                    0
N#define I2C_SMB_SHTF2_MASK                       0x2u
N#define I2C_SMB_SHTF2_SHIFT                      1
N#define I2C_SMB_SHTF1_MASK                       0x4u
N#define I2C_SMB_SHTF1_SHIFT                      2
N#define I2C_SMB_SLTF_MASK                        0x8u
N#define I2C_SMB_SLTF_SHIFT                       3
N#define I2C_SMB_TCKSEL_MASK                      0x10u
N#define I2C_SMB_TCKSEL_SHIFT                     4
N#define I2C_SMB_SIICAEN_MASK                     0x20u
N#define I2C_SMB_SIICAEN_SHIFT                    5
N#define I2C_SMB_ALERTEN_MASK                     0x40u
N#define I2C_SMB_ALERTEN_SHIFT                    6
N#define I2C_SMB_FACK_MASK                        0x80u
N#define I2C_SMB_FACK_SHIFT                       7
N/* A2 Bit Fields */
N#define I2C_A2_SAD_MASK                          0xFEu
N#define I2C_A2_SAD_SHIFT                         1
N#define I2C_A2_SAD(x)                            (((uint8_t)(((uint8_t)(x))<<I2C_A2_SAD_SHIFT))&I2C_A2_SAD_MASK)
N/* SLTH Bit Fields */
N#define I2C_SLTH_SSLT_MASK                       0xFFu
N#define I2C_SLTH_SSLT_SHIFT                      0
N#define I2C_SLTH_SSLT(x)                         (((uint8_t)(((uint8_t)(x))<<I2C_SLTH_SSLT_SHIFT))&I2C_SLTH_SSLT_MASK)
N/* SLTL Bit Fields */
N#define I2C_SLTL_SSLT_MASK                       0xFFu
N#define I2C_SLTL_SSLT_SHIFT                      0
N#define I2C_SLTL_SSLT(x)                         (((uint8_t)(((uint8_t)(x))<<I2C_SLTL_SSLT_SHIFT))&I2C_SLTL_SSLT_MASK)
N
N/**
N * @}
N */ /* end of group I2C_Register_Masks */
N
N
N/* I2C - Peripheral instance base addresses */
N/** Peripheral I2C0 base address */
N#define I2C0_BASE                                (0x40066000u)
N/** Peripheral I2C0 base pointer */
N#define I2C0                                     ((I2C_Type *)I2C0_BASE)
N/** Peripheral I2C1 base address */
N#define I2C1_BASE                                (0x40067000u)
N/** Peripheral I2C1 base pointer */
N#define I2C1                                     ((I2C_Type *)I2C1_BASE)
N/** Array initializer of I2C peripheral base pointers */
N#define I2C_BASES                                { I2C0, I2C1 }
N
N/**
N * @}
N */ /* end of group I2C_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- LLWU Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup LLWU_Peripheral_Access_Layer LLWU Peripheral Access Layer
N * @{
N */
N
N/** LLWU - Register Layout Typedef */
Ntypedef struct {
N  __IO uint8_t PE1;                                /**< LLWU Pin Enable 1 register, offset: 0x0 */
X  volatile uint8_t PE1;                                 
N  __IO uint8_t PE2;                                /**< LLWU Pin Enable 2 register, offset: 0x1 */
X  volatile uint8_t PE2;                                 
N  __IO uint8_t PE3;                                /**< LLWU Pin Enable 3 register, offset: 0x2 */
X  volatile uint8_t PE3;                                 
N  __IO uint8_t PE4;                                /**< LLWU Pin Enable 4 register, offset: 0x3 */
X  volatile uint8_t PE4;                                 
N  __IO uint8_t ME;                                 /**< LLWU Module Enable register, offset: 0x4 */
X  volatile uint8_t ME;                                  
N  __IO uint8_t F1;                                 /**< LLWU Flag 1 register, offset: 0x5 */
X  volatile uint8_t F1;                                  
N  __IO uint8_t F2;                                 /**< LLWU Flag 2 register, offset: 0x6 */
X  volatile uint8_t F2;                                  
N  __I  uint8_t F3;                                 /**< LLWU Flag 3 register, offset: 0x7 */
X  volatile const  uint8_t F3;                                  
N  __IO uint8_t FILT1;                              /**< LLWU Pin Filter 1 register, offset: 0x8 */
X  volatile uint8_t FILT1;                               
N  __IO uint8_t FILT2;                              /**< LLWU Pin Filter 2 register, offset: 0x9 */
X  volatile uint8_t FILT2;                               
N} LLWU_Type;
N
N/* ----------------------------------------------------------------------------
N   -- LLWU Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup LLWU_Register_Masks LLWU Register Masks
N * @{
N */
N
N/* PE1 Bit Fields */
N#define LLWU_PE1_WUPE0_MASK                      0x3u
N#define LLWU_PE1_WUPE0_SHIFT                     0
N#define LLWU_PE1_WUPE0(x)                        (((uint8_t)(((uint8_t)(x))<<LLWU_PE1_WUPE0_SHIFT))&LLWU_PE1_WUPE0_MASK)
N#define LLWU_PE1_WUPE1_MASK                      0xCu
N#define LLWU_PE1_WUPE1_SHIFT                     2
N#define LLWU_PE1_WUPE1(x)                        (((uint8_t)(((uint8_t)(x))<<LLWU_PE1_WUPE1_SHIFT))&LLWU_PE1_WUPE1_MASK)
N#define LLWU_PE1_WUPE2_MASK                      0x30u
N#define LLWU_PE1_WUPE2_SHIFT                     4
N#define LLWU_PE1_WUPE2(x)                        (((uint8_t)(((uint8_t)(x))<<LLWU_PE1_WUPE2_SHIFT))&LLWU_PE1_WUPE2_MASK)
N#define LLWU_PE1_WUPE3_MASK                      0xC0u
N#define LLWU_PE1_WUPE3_SHIFT                     6
N#define LLWU_PE1_WUPE3(x)                        (((uint8_t)(((uint8_t)(x))<<LLWU_PE1_WUPE3_SHIFT))&LLWU_PE1_WUPE3_MASK)
N/* PE2 Bit Fields */
N#define LLWU_PE2_WUPE4_MASK                      0x3u
N#define LLWU_PE2_WUPE4_SHIFT                     0
N#define LLWU_PE2_WUPE4(x)                        (((uint8_t)(((uint8_t)(x))<<LLWU_PE2_WUPE4_SHIFT))&LLWU_PE2_WUPE4_MASK)
N#define LLWU_PE2_WUPE5_MASK                      0xCu
N#define LLWU_PE2_WUPE5_SHIFT                     2
N#define LLWU_PE2_WUPE5(x)                        (((uint8_t)(((uint8_t)(x))<<LLWU_PE2_WUPE5_SHIFT))&LLWU_PE2_WUPE5_MASK)
N#define LLWU_PE2_WUPE6_MASK                      0x30u
N#define LLWU_PE2_WUPE6_SHIFT                     4
N#define LLWU_PE2_WUPE6(x)                        (((uint8_t)(((uint8_t)(x))<<LLWU_PE2_WUPE6_SHIFT))&LLWU_PE2_WUPE6_MASK)
N#define LLWU_PE2_WUPE7_MASK                      0xC0u
N#define LLWU_PE2_WUPE7_SHIFT                     6
N#define LLWU_PE2_WUPE7(x)                        (((uint8_t)(((uint8_t)(x))<<LLWU_PE2_WUPE7_SHIFT))&LLWU_PE2_WUPE7_MASK)
N/* PE3 Bit Fields */
N#define LLWU_PE3_WUPE8_MASK                      0x3u
N#define LLWU_PE3_WUPE8_SHIFT                     0
N#define LLWU_PE3_WUPE8(x)                        (((uint8_t)(((uint8_t)(x))<<LLWU_PE3_WUPE8_SHIFT))&LLWU_PE3_WUPE8_MASK)
N#define LLWU_PE3_WUPE9_MASK                      0xCu
N#define LLWU_PE3_WUPE9_SHIFT                     2
N#define LLWU_PE3_WUPE9(x)                        (((uint8_t)(((uint8_t)(x))<<LLWU_PE3_WUPE9_SHIFT))&LLWU_PE3_WUPE9_MASK)
N#define LLWU_PE3_WUPE10_MASK                     0x30u
N#define LLWU_PE3_WUPE10_SHIFT                    4
N#define LLWU_PE3_WUPE10(x)                       (((uint8_t)(((uint8_t)(x))<<LLWU_PE3_WUPE10_SHIFT))&LLWU_PE3_WUPE10_MASK)
N#define LLWU_PE3_WUPE11_MASK                     0xC0u
N#define LLWU_PE3_WUPE11_SHIFT                    6
N#define LLWU_PE3_WUPE11(x)                       (((uint8_t)(((uint8_t)(x))<<LLWU_PE3_WUPE11_SHIFT))&LLWU_PE3_WUPE11_MASK)
N/* PE4 Bit Fields */
N#define LLWU_PE4_WUPE12_MASK                     0x3u
N#define LLWU_PE4_WUPE12_SHIFT                    0
N#define LLWU_PE4_WUPE12(x)                       (((uint8_t)(((uint8_t)(x))<<LLWU_PE4_WUPE12_SHIFT))&LLWU_PE4_WUPE12_MASK)
N#define LLWU_PE4_WUPE13_MASK                     0xCu
N#define LLWU_PE4_WUPE13_SHIFT                    2
N#define LLWU_PE4_WUPE13(x)                       (((uint8_t)(((uint8_t)(x))<<LLWU_PE4_WUPE13_SHIFT))&LLWU_PE4_WUPE13_MASK)
N#define LLWU_PE4_WUPE14_MASK                     0x30u
N#define LLWU_PE4_WUPE14_SHIFT                    4
N#define LLWU_PE4_WUPE14(x)                       (((uint8_t)(((uint8_t)(x))<<LLWU_PE4_WUPE14_SHIFT))&LLWU_PE4_WUPE14_MASK)
N#define LLWU_PE4_WUPE15_MASK                     0xC0u
N#define LLWU_PE4_WUPE15_SHIFT                    6
N#define LLWU_PE4_WUPE15(x)                       (((uint8_t)(((uint8_t)(x))<<LLWU_PE4_WUPE15_SHIFT))&LLWU_PE4_WUPE15_MASK)
N/* ME Bit Fields */
N#define LLWU_ME_WUME0_MASK                       0x1u
N#define LLWU_ME_WUME0_SHIFT                      0
N#define LLWU_ME_WUME1_MASK                       0x2u
N#define LLWU_ME_WUME1_SHIFT                      1
N#define LLWU_ME_WUME2_MASK                       0x4u
N#define LLWU_ME_WUME2_SHIFT                      2
N#define LLWU_ME_WUME3_MASK                       0x8u
N#define LLWU_ME_WUME3_SHIFT                      3
N#define LLWU_ME_WUME4_MASK                       0x10u
N#define LLWU_ME_WUME4_SHIFT                      4
N#define LLWU_ME_WUME5_MASK                       0x20u
N#define LLWU_ME_WUME5_SHIFT                      5
N#define LLWU_ME_WUME6_MASK                       0x40u
N#define LLWU_ME_WUME6_SHIFT                      6
N#define LLWU_ME_WUME7_MASK                       0x80u
N#define LLWU_ME_WUME7_SHIFT                      7
N/* F1 Bit Fields */
N#define LLWU_F1_WUF0_MASK                        0x1u
N#define LLWU_F1_WUF0_SHIFT                       0
N#define LLWU_F1_WUF1_MASK                        0x2u
N#define LLWU_F1_WUF1_SHIFT                       1
N#define LLWU_F1_WUF2_MASK                        0x4u
N#define LLWU_F1_WUF2_SHIFT                       2
N#define LLWU_F1_WUF3_MASK                        0x8u
N#define LLWU_F1_WUF3_SHIFT                       3
N#define LLWU_F1_WUF4_MASK                        0x10u
N#define LLWU_F1_WUF4_SHIFT                       4
N#define LLWU_F1_WUF5_MASK                        0x20u
N#define LLWU_F1_WUF5_SHIFT                       5
N#define LLWU_F1_WUF6_MASK                        0x40u
N#define LLWU_F1_WUF6_SHIFT                       6
N#define LLWU_F1_WUF7_MASK                        0x80u
N#define LLWU_F1_WUF7_SHIFT                       7
N/* F2 Bit Fields */
N#define LLWU_F2_WUF8_MASK                        0x1u
N#define LLWU_F2_WUF8_SHIFT                       0
N#define LLWU_F2_WUF9_MASK                        0x2u
N#define LLWU_F2_WUF9_SHIFT                       1
N#define LLWU_F2_WUF10_MASK                       0x4u
N#define LLWU_F2_WUF10_SHIFT                      2
N#define LLWU_F2_WUF11_MASK                       0x8u
N#define LLWU_F2_WUF11_SHIFT                      3
N#define LLWU_F2_WUF12_MASK                       0x10u
N#define LLWU_F2_WUF12_SHIFT                      4
N#define LLWU_F2_WUF13_MASK                       0x20u
N#define LLWU_F2_WUF13_SHIFT                      5
N#define LLWU_F2_WUF14_MASK                       0x40u
N#define LLWU_F2_WUF14_SHIFT                      6
N#define LLWU_F2_WUF15_MASK                       0x80u
N#define LLWU_F2_WUF15_SHIFT                      7
N/* F3 Bit Fields */
N#define LLWU_F3_MWUF0_MASK                       0x1u
N#define LLWU_F3_MWUF0_SHIFT                      0
N#define LLWU_F3_MWUF1_MASK                       0x2u
N#define LLWU_F3_MWUF1_SHIFT                      1
N#define LLWU_F3_MWUF2_MASK                       0x4u
N#define LLWU_F3_MWUF2_SHIFT                      2
N#define LLWU_F3_MWUF3_MASK                       0x8u
N#define LLWU_F3_MWUF3_SHIFT                      3
N#define LLWU_F3_MWUF4_MASK                       0x10u
N#define LLWU_F3_MWUF4_SHIFT                      4
N#define LLWU_F3_MWUF5_MASK                       0x20u
N#define LLWU_F3_MWUF5_SHIFT                      5
N#define LLWU_F3_MWUF6_MASK                       0x40u
N#define LLWU_F3_MWUF6_SHIFT                      6
N#define LLWU_F3_MWUF7_MASK                       0x80u
N#define LLWU_F3_MWUF7_SHIFT                      7
N/* FILT1 Bit Fields */
N#define LLWU_FILT1_FILTSEL_MASK                  0xFu
N#define LLWU_FILT1_FILTSEL_SHIFT                 0
N#define LLWU_FILT1_FILTSEL(x)                    (((uint8_t)(((uint8_t)(x))<<LLWU_FILT1_FILTSEL_SHIFT))&LLWU_FILT1_FILTSEL_MASK)
N#define LLWU_FILT1_FILTE_MASK                    0x60u
N#define LLWU_FILT1_FILTE_SHIFT                   5
N#define LLWU_FILT1_FILTE(x)                      (((uint8_t)(((uint8_t)(x))<<LLWU_FILT1_FILTE_SHIFT))&LLWU_FILT1_FILTE_MASK)
N#define LLWU_FILT1_FILTF_MASK                    0x80u
N#define LLWU_FILT1_FILTF_SHIFT                   7
N/* FILT2 Bit Fields */
N#define LLWU_FILT2_FILTSEL_MASK                  0xFu
N#define LLWU_FILT2_FILTSEL_SHIFT                 0
N#define LLWU_FILT2_FILTSEL(x)                    (((uint8_t)(((uint8_t)(x))<<LLWU_FILT2_FILTSEL_SHIFT))&LLWU_FILT2_FILTSEL_MASK)
N#define LLWU_FILT2_FILTE_MASK                    0x60u
N#define LLWU_FILT2_FILTE_SHIFT                   5
N#define LLWU_FILT2_FILTE(x)                      (((uint8_t)(((uint8_t)(x))<<LLWU_FILT2_FILTE_SHIFT))&LLWU_FILT2_FILTE_MASK)
N#define LLWU_FILT2_FILTF_MASK                    0x80u
N#define LLWU_FILT2_FILTF_SHIFT                   7
N
N/**
N * @}
N */ /* end of group LLWU_Register_Masks */
N
N
N/* LLWU - Peripheral instance base addresses */
N/** Peripheral LLWU base address */
N#define LLWU_BASE                                (0x4007C000u)
N/** Peripheral LLWU base pointer */
N#define LLWU                                     ((LLWU_Type *)LLWU_BASE)
N/** Array initializer of LLWU peripheral base pointers */
N#define LLWU_BASES                               { LLWU }
N
N/**
N * @}
N */ /* end of group LLWU_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- LPTMR Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup LPTMR_Peripheral_Access_Layer LPTMR Peripheral Access Layer
N * @{
N */
N
N/** LPTMR - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t CSR;                               /**< Low Power Timer Control Status Register, offset: 0x0 */
X  volatile uint32_t CSR;                                
N  __IO uint32_t PSR;                               /**< Low Power Timer Prescale Register, offset: 0x4 */
X  volatile uint32_t PSR;                                
N  __IO uint32_t CMR;                               /**< Low Power Timer Compare Register, offset: 0x8 */
X  volatile uint32_t CMR;                                
N  __I  uint32_t CNR;                               /**< Low Power Timer Counter Register, offset: 0xC */
X  volatile const  uint32_t CNR;                                
N} LPTMR_Type;
N
N/* ----------------------------------------------------------------------------
N   -- LPTMR Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup LPTMR_Register_Masks LPTMR Register Masks
N * @{
N */
N
N/* CSR Bit Fields */
N#define LPTMR_CSR_TEN_MASK                       0x1u
N#define LPTMR_CSR_TEN_SHIFT                      0
N#define LPTMR_CSR_TMS_MASK                       0x2u
N#define LPTMR_CSR_TMS_SHIFT                      1
N#define LPTMR_CSR_TFC_MASK                       0x4u
N#define LPTMR_CSR_TFC_SHIFT                      2
N#define LPTMR_CSR_TPP_MASK                       0x8u
N#define LPTMR_CSR_TPP_SHIFT                      3
N#define LPTMR_CSR_TPS_MASK                       0x30u
N#define LPTMR_CSR_TPS_SHIFT                      4
N#define LPTMR_CSR_TPS(x)                         (((uint32_t)(((uint32_t)(x))<<LPTMR_CSR_TPS_SHIFT))&LPTMR_CSR_TPS_MASK)
N#define LPTMR_CSR_TIE_MASK                       0x40u
N#define LPTMR_CSR_TIE_SHIFT                      6
N#define LPTMR_CSR_TCF_MASK                       0x80u
N#define LPTMR_CSR_TCF_SHIFT                      7
N/* PSR Bit Fields */
N#define LPTMR_PSR_PCS_MASK                       0x3u
N#define LPTMR_PSR_PCS_SHIFT                      0
N#define LPTMR_PSR_PCS(x)                         (((uint32_t)(((uint32_t)(x))<<LPTMR_PSR_PCS_SHIFT))&LPTMR_PSR_PCS_MASK)
N#define LPTMR_PSR_PBYP_MASK                      0x4u
N#define LPTMR_PSR_PBYP_SHIFT                     2
N#define LPTMR_PSR_PRESCALE_MASK                  0x78u
N#define LPTMR_PSR_PRESCALE_SHIFT                 3
N#define LPTMR_PSR_PRESCALE(x)                    (((uint32_t)(((uint32_t)(x))<<LPTMR_PSR_PRESCALE_SHIFT))&LPTMR_PSR_PRESCALE_MASK)
N/* CMR Bit Fields */
N#define LPTMR_CMR_COMPARE_MASK                   0xFFFFu
N#define LPTMR_CMR_COMPARE_SHIFT                  0
N#define LPTMR_CMR_COMPARE(x)                     (((uint32_t)(((uint32_t)(x))<<LPTMR_CMR_COMPARE_SHIFT))&LPTMR_CMR_COMPARE_MASK)
N/* CNR Bit Fields */
N#define LPTMR_CNR_COUNTER_MASK                   0xFFFFu
N#define LPTMR_CNR_COUNTER_SHIFT                  0
N#define LPTMR_CNR_COUNTER(x)                     (((uint32_t)(((uint32_t)(x))<<LPTMR_CNR_COUNTER_SHIFT))&LPTMR_CNR_COUNTER_MASK)
N
N/**
N * @}
N */ /* end of group LPTMR_Register_Masks */
N
N
N/* LPTMR - Peripheral instance base addresses */
N/** Peripheral LPTMR0 base address */
N#define LPTMR0_BASE                              (0x40040000u)
N/** Peripheral LPTMR0 base pointer */
N#define LPTMR0                                   ((LPTMR_Type *)LPTMR0_BASE)
N/** Array initializer of LPTMR peripheral base pointers */
N#define LPTMR_BASES                              { LPTMR0 }
N
N/**
N * @}
N */ /* end of group LPTMR_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- MCG Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup MCG_Peripheral_Access_Layer MCG Peripheral Access Layer
N * @{
N */
N
N/** MCG - Register Layout Typedef */
Ntypedef struct {
N  __IO uint8_t C1;                                 /**< MCG Control 1 Register, offset: 0x0 */
X  volatile uint8_t C1;                                  
N  __IO uint8_t C2;                                 /**< MCG Control 2 Register, offset: 0x1 */
X  volatile uint8_t C2;                                  
N  __IO uint8_t C3;                                 /**< MCG Control 3 Register, offset: 0x2 */
X  volatile uint8_t C3;                                  
N  __IO uint8_t C4;                                 /**< MCG Control 4 Register, offset: 0x3 */
X  volatile uint8_t C4;                                  
N  __IO uint8_t C5;                                 /**< MCG Control 5 Register, offset: 0x4 */
X  volatile uint8_t C5;                                  
N  __IO uint8_t C6;                                 /**< MCG Control 6 Register, offset: 0x5 */
X  volatile uint8_t C6;                                  
N  __I  uint8_t S;                                  /**< MCG Status Register, offset: 0x6 */
X  volatile const  uint8_t S;                                   
N       uint8_t RESERVED_0[1];
N  __IO uint8_t SC;                                 /**< MCG Status and Control Register, offset: 0x8 */
X  volatile uint8_t SC;                                  
N       uint8_t RESERVED_1[1];
N  __IO uint8_t ATCVH;                              /**< MCG Auto Trim Compare Value High Register, offset: 0xA */
X  volatile uint8_t ATCVH;                               
N  __IO uint8_t ATCVL;                              /**< MCG Auto Trim Compare Value Low Register, offset: 0xB */
X  volatile uint8_t ATCVL;                               
N  __I  uint8_t C7;                                 /**< MCG Control 7 Register, offset: 0xC */
X  volatile const  uint8_t C7;                                  
N  __IO uint8_t C8;                                 /**< MCG Control 8 Register, offset: 0xD */
X  volatile uint8_t C8;                                  
N  __I  uint8_t C9;                                 /**< MCG Control 9 Register, offset: 0xE */
X  volatile const  uint8_t C9;                                  
N  __I  uint8_t C10;                                /**< MCG Control 10 Register, offset: 0xF */
X  volatile const  uint8_t C10;                                 
N} MCG_Type;
N
N/* ----------------------------------------------------------------------------
N   -- MCG Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup MCG_Register_Masks MCG Register Masks
N * @{
N */
N
N/* C1 Bit Fields */
N#define MCG_C1_IREFSTEN_MASK                     0x1u
N#define MCG_C1_IREFSTEN_SHIFT                    0
N#define MCG_C1_IRCLKEN_MASK                      0x2u
N#define MCG_C1_IRCLKEN_SHIFT                     1
N#define MCG_C1_IREFS_MASK                        0x4u
N#define MCG_C1_IREFS_SHIFT                       2
N#define MCG_C1_FRDIV_MASK                        0x38u
N#define MCG_C1_FRDIV_SHIFT                       3
N#define MCG_C1_FRDIV(x)                          (((uint8_t)(((uint8_t)(x))<<MCG_C1_FRDIV_SHIFT))&MCG_C1_FRDIV_MASK)
N#define MCG_C1_CLKS_MASK                         0xC0u
N#define MCG_C1_CLKS_SHIFT                        6
N#define MCG_C1_CLKS(x)                           (((uint8_t)(((uint8_t)(x))<<MCG_C1_CLKS_SHIFT))&MCG_C1_CLKS_MASK)
N/* C2 Bit Fields */
N#define MCG_C2_IRCS_MASK                         0x1u
N#define MCG_C2_IRCS_SHIFT                        0
N#define MCG_C2_LP_MASK                           0x2u
N#define MCG_C2_LP_SHIFT                          1
N#define MCG_C2_EREFS0_MASK                       0x4u
N#define MCG_C2_EREFS0_SHIFT                      2
N#define MCG_C2_HGO0_MASK                         0x8u
N#define MCG_C2_HGO0_SHIFT                        3
N#define MCG_C2_RANGE0_MASK                       0x30u
N#define MCG_C2_RANGE0_SHIFT                      4
N#define MCG_C2_RANGE0(x)                         (((uint8_t)(((uint8_t)(x))<<MCG_C2_RANGE0_SHIFT))&MCG_C2_RANGE0_MASK)
N#define MCG_C2_LOCRE0_MASK                       0x80u
N#define MCG_C2_LOCRE0_SHIFT                      7
N/* C3 Bit Fields */
N#define MCG_C3_SCTRIM_MASK                       0xFFu
N#define MCG_C3_SCTRIM_SHIFT                      0
N#define MCG_C3_SCTRIM(x)                         (((uint8_t)(((uint8_t)(x))<<MCG_C3_SCTRIM_SHIFT))&MCG_C3_SCTRIM_MASK)
N/* C4 Bit Fields */
N#define MCG_C4_SCFTRIM_MASK                      0x1u
N#define MCG_C4_SCFTRIM_SHIFT                     0
N#define MCG_C4_FCTRIM_MASK                       0x1Eu
N#define MCG_C4_FCTRIM_SHIFT                      1
N#define MCG_C4_FCTRIM(x)                         (((uint8_t)(((uint8_t)(x))<<MCG_C4_FCTRIM_SHIFT))&MCG_C4_FCTRIM_MASK)
N#define MCG_C4_DRST_DRS_MASK                     0x60u
N#define MCG_C4_DRST_DRS_SHIFT                    5
N#define MCG_C4_DRST_DRS(x)                       (((uint8_t)(((uint8_t)(x))<<MCG_C4_DRST_DRS_SHIFT))&MCG_C4_DRST_DRS_MASK)
N#define MCG_C4_DMX32_MASK                        0x80u
N#define MCG_C4_DMX32_SHIFT                       7
N/* C5 Bit Fields */
N#define MCG_C5_PRDIV0_MASK                       0x1Fu
N#define MCG_C5_PRDIV0_SHIFT                      0
N#define MCG_C5_PRDIV0(x)                         (((uint8_t)(((uint8_t)(x))<<MCG_C5_PRDIV0_SHIFT))&MCG_C5_PRDIV0_MASK)
N#define MCG_C5_PLLSTEN0_MASK                     0x20u
N#define MCG_C5_PLLSTEN0_SHIFT                    5
N#define MCG_C5_PLLCLKEN0_MASK                    0x40u
N#define MCG_C5_PLLCLKEN0_SHIFT                   6
N/* C6 Bit Fields */
N#define MCG_C6_VDIV0_MASK                        0x1Fu
N#define MCG_C6_VDIV0_SHIFT                       0
N#define MCG_C6_VDIV0(x)                          (((uint8_t)(((uint8_t)(x))<<MCG_C6_VDIV0_SHIFT))&MCG_C6_VDIV0_MASK)
N#define MCG_C6_CME0_MASK                         0x20u
N#define MCG_C6_CME0_SHIFT                        5
N#define MCG_C6_PLLS_MASK                         0x40u
N#define MCG_C6_PLLS_SHIFT                        6
N#define MCG_C6_LOLIE0_MASK                       0x80u
N#define MCG_C6_LOLIE0_SHIFT                      7
N/* S Bit Fields */
N#define MCG_S_IRCST_MASK                         0x1u
N#define MCG_S_IRCST_SHIFT                        0
N#define MCG_S_OSCINIT0_MASK                      0x2u
N#define MCG_S_OSCINIT0_SHIFT                     1
N#define MCG_S_CLKST_MASK                         0xCu
N#define MCG_S_CLKST_SHIFT                        2
N#define MCG_S_CLKST(x)                           (((uint8_t)(((uint8_t)(x))<<MCG_S_CLKST_SHIFT))&MCG_S_CLKST_MASK)
N#define MCG_S_IREFST_MASK                        0x10u
N#define MCG_S_IREFST_SHIFT                       4
N#define MCG_S_PLLST_MASK                         0x20u
N#define MCG_S_PLLST_SHIFT                        5
N#define MCG_S_LOCK0_MASK                         0x40u
N#define MCG_S_LOCK0_SHIFT                        6
N#define MCG_S_LOLS0_MASK                         0x80u
N#define MCG_S_LOLS0_SHIFT                        7
N/* SC Bit Fields */
N#define MCG_SC_LOCS0_MASK                        0x1u
N#define MCG_SC_LOCS0_SHIFT                       0
N#define MCG_SC_FCRDIV_MASK                       0xEu
N#define MCG_SC_FCRDIV_SHIFT                      1
N#define MCG_SC_FCRDIV(x)                         (((uint8_t)(((uint8_t)(x))<<MCG_SC_FCRDIV_SHIFT))&MCG_SC_FCRDIV_MASK)
N#define MCG_SC_FLTPRSRV_MASK                     0x10u
N#define MCG_SC_FLTPRSRV_SHIFT                    4
N#define MCG_SC_ATMF_MASK                         0x20u
N#define MCG_SC_ATMF_SHIFT                        5
N#define MCG_SC_ATMS_MASK                         0x40u
N#define MCG_SC_ATMS_SHIFT                        6
N#define MCG_SC_ATME_MASK                         0x80u
N#define MCG_SC_ATME_SHIFT                        7
N/* ATCVH Bit Fields */
N#define MCG_ATCVH_ATCVH_MASK                     0xFFu
N#define MCG_ATCVH_ATCVH_SHIFT                    0
N#define MCG_ATCVH_ATCVH(x)                       (((uint8_t)(((uint8_t)(x))<<MCG_ATCVH_ATCVH_SHIFT))&MCG_ATCVH_ATCVH_MASK)
N/* ATCVL Bit Fields */
N#define MCG_ATCVL_ATCVL_MASK                     0xFFu
N#define MCG_ATCVL_ATCVL_SHIFT                    0
N#define MCG_ATCVL_ATCVL(x)                       (((uint8_t)(((uint8_t)(x))<<MCG_ATCVL_ATCVL_SHIFT))&MCG_ATCVL_ATCVL_MASK)
N/* C8 Bit Fields */
N#define MCG_C8_LOLRE_MASK                        0x40u
N#define MCG_C8_LOLRE_SHIFT                       6
N
N/**
N * @}
N */ /* end of group MCG_Register_Masks */
N
N
N/* MCG - Peripheral instance base addresses */
N/** Peripheral MCG base address */
N#define MCG_BASE                                 (0x40064000u)
N/** Peripheral MCG base pointer */
N#define MCG                                      ((MCG_Type *)MCG_BASE)
N/** Array initializer of MCG peripheral base pointers */
N#define MCG_BASES                                { MCG }
N
N/**
N * @}
N */ /* end of group MCG_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- MCM Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup MCM_Peripheral_Access_Layer MCM Peripheral Access Layer
N * @{
N */
N
N/** MCM - Register Layout Typedef */
Ntypedef struct {
N       uint8_t RESERVED_0[8];
N  __I  uint16_t PLASC;                             /**< Crossbar Switch (AXBS) Slave Configuration, offset: 0x8 */
X  volatile const  uint16_t PLASC;                              
N  __I  uint16_t PLAMC;                             /**< Crossbar Switch (AXBS) Master Configuration, offset: 0xA */
X  volatile const  uint16_t PLAMC;                              
N  __IO uint32_t PLACR;                             /**< Platform Control Register, offset: 0xC */
X  volatile uint32_t PLACR;                              
N       uint8_t RESERVED_1[48];
N  __IO uint32_t CPO;                               /**< Compute Operation Control Register, offset: 0x40 */
X  volatile uint32_t CPO;                                
N} MCM_Type;
N
N/* ----------------------------------------------------------------------------
N   -- MCM Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup MCM_Register_Masks MCM Register Masks
N * @{
N */
N
N/* PLASC Bit Fields */
N#define MCM_PLASC_ASC_MASK                       0xFFu
N#define MCM_PLASC_ASC_SHIFT                      0
N#define MCM_PLASC_ASC(x)                         (((uint16_t)(((uint16_t)(x))<<MCM_PLASC_ASC_SHIFT))&MCM_PLASC_ASC_MASK)
N/* PLAMC Bit Fields */
N#define MCM_PLAMC_AMC_MASK                       0xFFu
N#define MCM_PLAMC_AMC_SHIFT                      0
N#define MCM_PLAMC_AMC(x)                         (((uint16_t)(((uint16_t)(x))<<MCM_PLAMC_AMC_SHIFT))&MCM_PLAMC_AMC_MASK)
N/* PLACR Bit Fields */
N#define MCM_PLACR_ARB_MASK                       0x200u
N#define MCM_PLACR_ARB_SHIFT                      9
N#define MCM_PLACR_CFCC_MASK                      0x400u
N#define MCM_PLACR_CFCC_SHIFT                     10
N#define MCM_PLACR_DFCDA_MASK                     0x800u
N#define MCM_PLACR_DFCDA_SHIFT                    11
N#define MCM_PLACR_DFCIC_MASK                     0x1000u
N#define MCM_PLACR_DFCIC_SHIFT                    12
N#define MCM_PLACR_DFCC_MASK                      0x2000u
N#define MCM_PLACR_DFCC_SHIFT                     13
N#define MCM_PLACR_EFDS_MASK                      0x4000u
N#define MCM_PLACR_EFDS_SHIFT                     14
N#define MCM_PLACR_DFCS_MASK                      0x8000u
N#define MCM_PLACR_DFCS_SHIFT                     15
N#define MCM_PLACR_ESFC_MASK                      0x10000u
N#define MCM_PLACR_ESFC_SHIFT                     16
N/* CPO Bit Fields */
N#define MCM_CPO_CPOREQ_MASK                      0x1u
N#define MCM_CPO_CPOREQ_SHIFT                     0
N#define MCM_CPO_CPOACK_MASK                      0x2u
N#define MCM_CPO_CPOACK_SHIFT                     1
N#define MCM_CPO_CPOWOI_MASK                      0x4u
N#define MCM_CPO_CPOWOI_SHIFT                     2
N
N/**
N * @}
N */ /* end of group MCM_Register_Masks */
N
N
N/* MCM - Peripheral instance base addresses */
N/** Peripheral MCM base address */
N#define MCM_BASE                                 (0xF0003000u)
N/** Peripheral MCM base pointer */
N#define MCM                                      ((MCM_Type *)MCM_BASE)
N/** Array initializer of MCM peripheral base pointers */
N#define MCM_BASES                                { MCM }
N
N/**
N * @}
N */ /* end of group MCM_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- MTB Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup MTB_Peripheral_Access_Layer MTB Peripheral Access Layer
N * @{
N */
N
N/** MTB - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t POSITION;                          /**< MTB Position Register, offset: 0x0 */
X  volatile uint32_t POSITION;                           
N  __IO uint32_t MASTER;                            /**< MTB Master Register, offset: 0x4 */
X  volatile uint32_t MASTER;                             
N  __IO uint32_t FLOW;                              /**< MTB Flow Register, offset: 0x8 */
X  volatile uint32_t FLOW;                               
N  __I  uint32_t BASE;                              /**< MTB Base Register, offset: 0xC */
X  volatile const  uint32_t BASE;                               
N       uint8_t RESERVED_0[3824];
N  __I  uint32_t MODECTRL;                          /**< Integration Mode Control Register, offset: 0xF00 */
X  volatile const  uint32_t MODECTRL;                           
N       uint8_t RESERVED_1[156];
N  __I  uint32_t TAGSET;                            /**< Claim TAG Set Register, offset: 0xFA0 */
X  volatile const  uint32_t TAGSET;                             
N  __I  uint32_t TAGCLEAR;                          /**< Claim TAG Clear Register, offset: 0xFA4 */
X  volatile const  uint32_t TAGCLEAR;                           
N       uint8_t RESERVED_2[8];
N  __I  uint32_t LOCKACCESS;                        /**< Lock Access Register, offset: 0xFB0 */
X  volatile const  uint32_t LOCKACCESS;                         
N  __I  uint32_t LOCKSTAT;                          /**< Lock Status Register, offset: 0xFB4 */
X  volatile const  uint32_t LOCKSTAT;                           
N  __I  uint32_t AUTHSTAT;                          /**< Authentication Status Register, offset: 0xFB8 */
X  volatile const  uint32_t AUTHSTAT;                           
N  __I  uint32_t DEVICEARCH;                        /**< Device Architecture Register, offset: 0xFBC */
X  volatile const  uint32_t DEVICEARCH;                         
N       uint8_t RESERVED_3[8];
N  __I  uint32_t DEVICECFG;                         /**< Device Configuration Register, offset: 0xFC8 */
X  volatile const  uint32_t DEVICECFG;                          
N  __I  uint32_t DEVICETYPID;                       /**< Device Type Identifier Register, offset: 0xFCC */
X  volatile const  uint32_t DEVICETYPID;                        
N  __I  uint32_t PERIPHID[8];                       /**< Peripheral ID Register, array offset: 0xFD0, array step: 0x4 */
X  volatile const  uint32_t PERIPHID[8];                        
N  __I  uint32_t COMPID[4];                         /**< Component ID Register, array offset: 0xFF0, array step: 0x4 */
X  volatile const  uint32_t COMPID[4];                          
N} MTB_Type;
N
N/* ----------------------------------------------------------------------------
N   -- MTB Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup MTB_Register_Masks MTB Register Masks
N * @{
N */
N
N/* POSITION Bit Fields */
N#define MTB_POSITION_WRAP_MASK                   0x4u
N#define MTB_POSITION_WRAP_SHIFT                  2
N#define MTB_POSITION_POINTER_MASK                0xFFFFFFF8u
N#define MTB_POSITION_POINTER_SHIFT               3
N#define MTB_POSITION_POINTER(x)                  (((uint32_t)(((uint32_t)(x))<<MTB_POSITION_POINTER_SHIFT))&MTB_POSITION_POINTER_MASK)
N/* MASTER Bit Fields */
N#define MTB_MASTER_MASK_MASK                     0x1Fu
N#define MTB_MASTER_MASK_SHIFT                    0
N#define MTB_MASTER_MASK(x)                       (((uint32_t)(((uint32_t)(x))<<MTB_MASTER_MASK_SHIFT))&MTB_MASTER_MASK_MASK)
N#define MTB_MASTER_TSTARTEN_MASK                 0x20u
N#define MTB_MASTER_TSTARTEN_SHIFT                5
N#define MTB_MASTER_TSTOPEN_MASK                  0x40u
N#define MTB_MASTER_TSTOPEN_SHIFT                 6
N#define MTB_MASTER_SFRWPRIV_MASK                 0x80u
N#define MTB_MASTER_SFRWPRIV_SHIFT                7
N#define MTB_MASTER_RAMPRIV_MASK                  0x100u
N#define MTB_MASTER_RAMPRIV_SHIFT                 8
N#define MTB_MASTER_HALTREQ_MASK                  0x200u
N#define MTB_MASTER_HALTREQ_SHIFT                 9
N#define MTB_MASTER_EN_MASK                       0x80000000u
N#define MTB_MASTER_EN_SHIFT                      31
N/* FLOW Bit Fields */
N#define MTB_FLOW_AUTOSTOP_MASK                   0x1u
N#define MTB_FLOW_AUTOSTOP_SHIFT                  0
N#define MTB_FLOW_AUTOHALT_MASK                   0x2u
N#define MTB_FLOW_AUTOHALT_SHIFT                  1
N#define MTB_FLOW_WATERMARK_MASK                  0xFFFFFFF8u
N#define MTB_FLOW_WATERMARK_SHIFT                 3
N#define MTB_FLOW_WATERMARK(x)                    (((uint32_t)(((uint32_t)(x))<<MTB_FLOW_WATERMARK_SHIFT))&MTB_FLOW_WATERMARK_MASK)
N/* BASE Bit Fields */
N#define MTB_BASE_BASEADDR_MASK                   0xFFFFFFFFu
N#define MTB_BASE_BASEADDR_SHIFT                  0
N#define MTB_BASE_BASEADDR(x)                     (((uint32_t)(((uint32_t)(x))<<MTB_BASE_BASEADDR_SHIFT))&MTB_BASE_BASEADDR_MASK)
N/* MODECTRL Bit Fields */
N#define MTB_MODECTRL_MODECTRL_MASK               0xFFFFFFFFu
N#define MTB_MODECTRL_MODECTRL_SHIFT              0
N#define MTB_MODECTRL_MODECTRL(x)                 (((uint32_t)(((uint32_t)(x))<<MTB_MODECTRL_MODECTRL_SHIFT))&MTB_MODECTRL_MODECTRL_MASK)
N/* TAGSET Bit Fields */
N#define MTB_TAGSET_TAGSET_MASK                   0xFFFFFFFFu
N#define MTB_TAGSET_TAGSET_SHIFT                  0
N#define MTB_TAGSET_TAGSET(x)                     (((uint32_t)(((uint32_t)(x))<<MTB_TAGSET_TAGSET_SHIFT))&MTB_TAGSET_TAGSET_MASK)
N/* TAGCLEAR Bit Fields */
N#define MTB_TAGCLEAR_TAGCLEAR_MASK               0xFFFFFFFFu
N#define MTB_TAGCLEAR_TAGCLEAR_SHIFT              0
N#define MTB_TAGCLEAR_TAGCLEAR(x)                 (((uint32_t)(((uint32_t)(x))<<MTB_TAGCLEAR_TAGCLEAR_SHIFT))&MTB_TAGCLEAR_TAGCLEAR_MASK)
N/* LOCKACCESS Bit Fields */
N#define MTB_LOCKACCESS_LOCKACCESS_MASK           0xFFFFFFFFu
N#define MTB_LOCKACCESS_LOCKACCESS_SHIFT          0
N#define MTB_LOCKACCESS_LOCKACCESS(x)             (((uint32_t)(((uint32_t)(x))<<MTB_LOCKACCESS_LOCKACCESS_SHIFT))&MTB_LOCKACCESS_LOCKACCESS_MASK)
N/* LOCKSTAT Bit Fields */
N#define MTB_LOCKSTAT_LOCKSTAT_MASK               0xFFFFFFFFu
N#define MTB_LOCKSTAT_LOCKSTAT_SHIFT              0
N#define MTB_LOCKSTAT_LOCKSTAT(x)                 (((uint32_t)(((uint32_t)(x))<<MTB_LOCKSTAT_LOCKSTAT_SHIFT))&MTB_LOCKSTAT_LOCKSTAT_MASK)
N/* AUTHSTAT Bit Fields */
N#define MTB_AUTHSTAT_BIT0_MASK                   0x1u
N#define MTB_AUTHSTAT_BIT0_SHIFT                  0
N#define MTB_AUTHSTAT_BIT1_MASK                   0x2u
N#define MTB_AUTHSTAT_BIT1_SHIFT                  1
N#define MTB_AUTHSTAT_BIT2_MASK                   0x4u
N#define MTB_AUTHSTAT_BIT2_SHIFT                  2
N#define MTB_AUTHSTAT_BIT3_MASK                   0x8u
N#define MTB_AUTHSTAT_BIT3_SHIFT                  3
N/* DEVICEARCH Bit Fields */
N#define MTB_DEVICEARCH_DEVICEARCH_MASK           0xFFFFFFFFu
N#define MTB_DEVICEARCH_DEVICEARCH_SHIFT          0
N#define MTB_DEVICEARCH_DEVICEARCH(x)             (((uint32_t)(((uint32_t)(x))<<MTB_DEVICEARCH_DEVICEARCH_SHIFT))&MTB_DEVICEARCH_DEVICEARCH_MASK)
N/* DEVICECFG Bit Fields */
N#define MTB_DEVICECFG_DEVICECFG_MASK             0xFFFFFFFFu
N#define MTB_DEVICECFG_DEVICECFG_SHIFT            0
N#define MTB_DEVICECFG_DEVICECFG(x)               (((uint32_t)(((uint32_t)(x))<<MTB_DEVICECFG_DEVICECFG_SHIFT))&MTB_DEVICECFG_DEVICECFG_MASK)
N/* DEVICETYPID Bit Fields */
N#define MTB_DEVICETYPID_DEVICETYPID_MASK         0xFFFFFFFFu
N#define MTB_DEVICETYPID_DEVICETYPID_SHIFT        0
N#define MTB_DEVICETYPID_DEVICETYPID(x)           (((uint32_t)(((uint32_t)(x))<<MTB_DEVICETYPID_DEVICETYPID_SHIFT))&MTB_DEVICETYPID_DEVICETYPID_MASK)
N/* PERIPHID Bit Fields */
N#define MTB_PERIPHID_PERIPHID_MASK               0xFFFFFFFFu
N#define MTB_PERIPHID_PERIPHID_SHIFT              0
N#define MTB_PERIPHID_PERIPHID(x)                 (((uint32_t)(((uint32_t)(x))<<MTB_PERIPHID_PERIPHID_SHIFT))&MTB_PERIPHID_PERIPHID_MASK)
N/* COMPID Bit Fields */
N#define MTB_COMPID_COMPID_MASK                   0xFFFFFFFFu
N#define MTB_COMPID_COMPID_SHIFT                  0
N#define MTB_COMPID_COMPID(x)                     (((uint32_t)(((uint32_t)(x))<<MTB_COMPID_COMPID_SHIFT))&MTB_COMPID_COMPID_MASK)
N
N/**
N * @}
N */ /* end of group MTB_Register_Masks */
N
N
N/* MTB - Peripheral instance base addresses */
N/** Peripheral MTB base address */
N#define MTB_BASE                                 (0xF0000000u)
N/** Peripheral MTB base pointer */
N#define MTB                                      ((MTB_Type *)MTB_BASE)
N/** Array initializer of MTB peripheral base pointers */
N#define MTB_BASES                                { MTB }
N
N/**
N * @}
N */ /* end of group MTB_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- MTBDWT Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup MTBDWT_Peripheral_Access_Layer MTBDWT Peripheral Access Layer
N * @{
N */
N
N/** MTBDWT - Register Layout Typedef */
Ntypedef struct {
N  __I  uint32_t CTRL;                              /**< MTB DWT Control Register, offset: 0x0 */
X  volatile const  uint32_t CTRL;                               
N       uint8_t RESERVED_0[28];
N  struct {                                         /* offset: 0x20, array step: 0x10 */
N    __IO uint32_t COMP;                              /**< MTB_DWT Comparator Register, array offset: 0x20, array step: 0x10 */
X    volatile uint32_t COMP;                               
N    __IO uint32_t MASK;                              /**< MTB_DWT Comparator Mask Register, array offset: 0x24, array step: 0x10 */
X    volatile uint32_t MASK;                               
N    __IO uint32_t FCT;                               /**< MTB_DWT Comparator Function Register 0..MTB_DWT Comparator Function Register 1, array offset: 0x28, array step: 0x10 */
X    volatile uint32_t FCT;                                
N         uint8_t RESERVED_0[4];
N  } COMPARATOR[2];
N       uint8_t RESERVED_1[448];
N  __IO uint32_t TBCTRL;                            /**< MTB_DWT Trace Buffer Control Register, offset: 0x200 */
X  volatile uint32_t TBCTRL;                             
N       uint8_t RESERVED_2[3524];
N  __I  uint32_t DEVICECFG;                         /**< Device Configuration Register, offset: 0xFC8 */
X  volatile const  uint32_t DEVICECFG;                          
N  __I  uint32_t DEVICETYPID;                       /**< Device Type Identifier Register, offset: 0xFCC */
X  volatile const  uint32_t DEVICETYPID;                        
N  __I  uint32_t PERIPHID[8];                       /**< Peripheral ID Register, array offset: 0xFD0, array step: 0x4 */
X  volatile const  uint32_t PERIPHID[8];                        
N  __I  uint32_t COMPID[4];                         /**< Component ID Register, array offset: 0xFF0, array step: 0x4 */
X  volatile const  uint32_t COMPID[4];                          
N} MTBDWT_Type;
N
N/* ----------------------------------------------------------------------------
N   -- MTBDWT Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup MTBDWT_Register_Masks MTBDWT Register Masks
N * @{
N */
N
N/* CTRL Bit Fields */
N#define MTBDWT_CTRL_DWTCFGCTRL_MASK              0xFFFFFFFu
N#define MTBDWT_CTRL_DWTCFGCTRL_SHIFT             0
N#define MTBDWT_CTRL_DWTCFGCTRL(x)                (((uint32_t)(((uint32_t)(x))<<MTBDWT_CTRL_DWTCFGCTRL_SHIFT))&MTBDWT_CTRL_DWTCFGCTRL_MASK)
N#define MTBDWT_CTRL_NUMCMP_MASK                  0xF0000000u
N#define MTBDWT_CTRL_NUMCMP_SHIFT                 28
N#define MTBDWT_CTRL_NUMCMP(x)                    (((uint32_t)(((uint32_t)(x))<<MTBDWT_CTRL_NUMCMP_SHIFT))&MTBDWT_CTRL_NUMCMP_MASK)
N/* COMP Bit Fields */
N#define MTBDWT_COMP_COMP_MASK                    0xFFFFFFFFu
N#define MTBDWT_COMP_COMP_SHIFT                   0
N#define MTBDWT_COMP_COMP(x)                      (((uint32_t)(((uint32_t)(x))<<MTBDWT_COMP_COMP_SHIFT))&MTBDWT_COMP_COMP_MASK)
N/* MASK Bit Fields */
N#define MTBDWT_MASK_MASK_MASK                    0x1Fu
N#define MTBDWT_MASK_MASK_SHIFT                   0
N#define MTBDWT_MASK_MASK(x)                      (((uint32_t)(((uint32_t)(x))<<MTBDWT_MASK_MASK_SHIFT))&MTBDWT_MASK_MASK_MASK)
N/* FCT Bit Fields */
N#define MTBDWT_FCT_FUNCTION_MASK                 0xFu
N#define MTBDWT_FCT_FUNCTION_SHIFT                0
N#define MTBDWT_FCT_FUNCTION(x)                   (((uint32_t)(((uint32_t)(x))<<MTBDWT_FCT_FUNCTION_SHIFT))&MTBDWT_FCT_FUNCTION_MASK)
N#define MTBDWT_FCT_DATAVMATCH_MASK               0x100u
N#define MTBDWT_FCT_DATAVMATCH_SHIFT              8
N#define MTBDWT_FCT_DATAVSIZE_MASK                0xC00u
N#define MTBDWT_FCT_DATAVSIZE_SHIFT               10
N#define MTBDWT_FCT_DATAVSIZE(x)                  (((uint32_t)(((uint32_t)(x))<<MTBDWT_FCT_DATAVSIZE_SHIFT))&MTBDWT_FCT_DATAVSIZE_MASK)
N#define MTBDWT_FCT_DATAVADDR0_MASK               0xF000u
N#define MTBDWT_FCT_DATAVADDR0_SHIFT              12
N#define MTBDWT_FCT_DATAVADDR0(x)                 (((uint32_t)(((uint32_t)(x))<<MTBDWT_FCT_DATAVADDR0_SHIFT))&MTBDWT_FCT_DATAVADDR0_MASK)
N#define MTBDWT_FCT_MATCHED_MASK                  0x1000000u
N#define MTBDWT_FCT_MATCHED_SHIFT                 24
N/* TBCTRL Bit Fields */
N#define MTBDWT_TBCTRL_ACOMP0_MASK                0x1u
N#define MTBDWT_TBCTRL_ACOMP0_SHIFT               0
N#define MTBDWT_TBCTRL_ACOMP1_MASK                0x2u
N#define MTBDWT_TBCTRL_ACOMP1_SHIFT               1
N#define MTBDWT_TBCTRL_NUMCOMP_MASK               0xF0000000u
N#define MTBDWT_TBCTRL_NUMCOMP_SHIFT              28
N#define MTBDWT_TBCTRL_NUMCOMP(x)                 (((uint32_t)(((uint32_t)(x))<<MTBDWT_TBCTRL_NUMCOMP_SHIFT))&MTBDWT_TBCTRL_NUMCOMP_MASK)
N/* DEVICECFG Bit Fields */
N#define MTBDWT_DEVICECFG_DEVICECFG_MASK          0xFFFFFFFFu
N#define MTBDWT_DEVICECFG_DEVICECFG_SHIFT         0
N#define MTBDWT_DEVICECFG_DEVICECFG(x)            (((uint32_t)(((uint32_t)(x))<<MTBDWT_DEVICECFG_DEVICECFG_SHIFT))&MTBDWT_DEVICECFG_DEVICECFG_MASK)
N/* DEVICETYPID Bit Fields */
N#define MTBDWT_DEVICETYPID_DEVICETYPID_MASK      0xFFFFFFFFu
N#define MTBDWT_DEVICETYPID_DEVICETYPID_SHIFT     0
N#define MTBDWT_DEVICETYPID_DEVICETYPID(x)        (((uint32_t)(((uint32_t)(x))<<MTBDWT_DEVICETYPID_DEVICETYPID_SHIFT))&MTBDWT_DEVICETYPID_DEVICETYPID_MASK)
N/* PERIPHID Bit Fields */
N#define MTBDWT_PERIPHID_PERIPHID_MASK            0xFFFFFFFFu
N#define MTBDWT_PERIPHID_PERIPHID_SHIFT           0
N#define MTBDWT_PERIPHID_PERIPHID(x)              (((uint32_t)(((uint32_t)(x))<<MTBDWT_PERIPHID_PERIPHID_SHIFT))&MTBDWT_PERIPHID_PERIPHID_MASK)
N/* COMPID Bit Fields */
N#define MTBDWT_COMPID_COMPID_MASK                0xFFFFFFFFu
N#define MTBDWT_COMPID_COMPID_SHIFT               0
N#define MTBDWT_COMPID_COMPID(x)                  (((uint32_t)(((uint32_t)(x))<<MTBDWT_COMPID_COMPID_SHIFT))&MTBDWT_COMPID_COMPID_MASK)
N
N/**
N * @}
N */ /* end of group MTBDWT_Register_Masks */
N
N
N/* MTBDWT - Peripheral instance base addresses */
N/** Peripheral MTBDWT base address */
N#define MTBDWT_BASE                              (0xF0001000u)
N/** Peripheral MTBDWT base pointer */
N#define MTBDWT                                   ((MTBDWT_Type *)MTBDWT_BASE)
N/** Array initializer of MTBDWT peripheral base pointers */
N#define MTBDWT_BASES                             { MTBDWT }
N
N/**
N * @}
N */ /* end of group MTBDWT_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- NV Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup NV_Peripheral_Access_Layer NV Peripheral Access Layer
N * @{
N */
N
N/** NV - Register Layout Typedef */
Ntypedef struct {
N  __I  uint8_t BACKKEY3;                           /**< Backdoor Comparison Key 3., offset: 0x0 */
X  volatile const  uint8_t BACKKEY3;                            
N  __I  uint8_t BACKKEY2;                           /**< Backdoor Comparison Key 2., offset: 0x1 */
X  volatile const  uint8_t BACKKEY2;                            
N  __I  uint8_t BACKKEY1;                           /**< Backdoor Comparison Key 1., offset: 0x2 */
X  volatile const  uint8_t BACKKEY1;                            
N  __I  uint8_t BACKKEY0;                           /**< Backdoor Comparison Key 0., offset: 0x3 */
X  volatile const  uint8_t BACKKEY0;                            
N  __I  uint8_t BACKKEY7;                           /**< Backdoor Comparison Key 7., offset: 0x4 */
X  volatile const  uint8_t BACKKEY7;                            
N  __I  uint8_t BACKKEY6;                           /**< Backdoor Comparison Key 6., offset: 0x5 */
X  volatile const  uint8_t BACKKEY6;                            
N  __I  uint8_t BACKKEY5;                           /**< Backdoor Comparison Key 5., offset: 0x6 */
X  volatile const  uint8_t BACKKEY5;                            
N  __I  uint8_t BACKKEY4;                           /**< Backdoor Comparison Key 4., offset: 0x7 */
X  volatile const  uint8_t BACKKEY4;                            
N  __I  uint8_t FPROT3;                             /**< Non-volatile P-Flash Protection 1 - Low Register, offset: 0x8 */
X  volatile const  uint8_t FPROT3;                              
N  __I  uint8_t FPROT2;                             /**< Non-volatile P-Flash Protection 1 - High Register, offset: 0x9 */
X  volatile const  uint8_t FPROT2;                              
N  __I  uint8_t FPROT1;                             /**< Non-volatile P-Flash Protection 0 - Low Register, offset: 0xA */
X  volatile const  uint8_t FPROT1;                              
N  __I  uint8_t FPROT0;                             /**< Non-volatile P-Flash Protection 0 - High Register, offset: 0xB */
X  volatile const  uint8_t FPROT0;                              
N  __I  uint8_t FSEC;                               /**< Non-volatile Flash Security Register, offset: 0xC */
X  volatile const  uint8_t FSEC;                                
N  __I  uint8_t FOPT;                               /**< Non-volatile Flash Option Register, offset: 0xD */
X  volatile const  uint8_t FOPT;                                
N} NV_Type;
N
N/* ----------------------------------------------------------------------------
N   -- NV Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup NV_Register_Masks NV Register Masks
N * @{
N */
N
N/* BACKKEY3 Bit Fields */
N#define NV_BACKKEY3_KEY_MASK                     0xFFu
N#define NV_BACKKEY3_KEY_SHIFT                    0
N#define NV_BACKKEY3_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY3_KEY_SHIFT))&NV_BACKKEY3_KEY_MASK)
N/* BACKKEY2 Bit Fields */
N#define NV_BACKKEY2_KEY_MASK                     0xFFu
N#define NV_BACKKEY2_KEY_SHIFT                    0
N#define NV_BACKKEY2_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY2_KEY_SHIFT))&NV_BACKKEY2_KEY_MASK)
N/* BACKKEY1 Bit Fields */
N#define NV_BACKKEY1_KEY_MASK                     0xFFu
N#define NV_BACKKEY1_KEY_SHIFT                    0
N#define NV_BACKKEY1_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY1_KEY_SHIFT))&NV_BACKKEY1_KEY_MASK)
N/* BACKKEY0 Bit Fields */
N#define NV_BACKKEY0_KEY_MASK                     0xFFu
N#define NV_BACKKEY0_KEY_SHIFT                    0
N#define NV_BACKKEY0_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY0_KEY_SHIFT))&NV_BACKKEY0_KEY_MASK)
N/* BACKKEY7 Bit Fields */
N#define NV_BACKKEY7_KEY_MASK                     0xFFu
N#define NV_BACKKEY7_KEY_SHIFT                    0
N#define NV_BACKKEY7_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY7_KEY_SHIFT))&NV_BACKKEY7_KEY_MASK)
N/* BACKKEY6 Bit Fields */
N#define NV_BACKKEY6_KEY_MASK                     0xFFu
N#define NV_BACKKEY6_KEY_SHIFT                    0
N#define NV_BACKKEY6_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY6_KEY_SHIFT))&NV_BACKKEY6_KEY_MASK)
N/* BACKKEY5 Bit Fields */
N#define NV_BACKKEY5_KEY_MASK                     0xFFu
N#define NV_BACKKEY5_KEY_SHIFT                    0
N#define NV_BACKKEY5_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY5_KEY_SHIFT))&NV_BACKKEY5_KEY_MASK)
N/* BACKKEY4 Bit Fields */
N#define NV_BACKKEY4_KEY_MASK                     0xFFu
N#define NV_BACKKEY4_KEY_SHIFT                    0
N#define NV_BACKKEY4_KEY(x)                       (((uint8_t)(((uint8_t)(x))<<NV_BACKKEY4_KEY_SHIFT))&NV_BACKKEY4_KEY_MASK)
N/* FPROT3 Bit Fields */
N#define NV_FPROT3_PROT_MASK                      0xFFu
N#define NV_FPROT3_PROT_SHIFT                     0
N#define NV_FPROT3_PROT(x)                        (((uint8_t)(((uint8_t)(x))<<NV_FPROT3_PROT_SHIFT))&NV_FPROT3_PROT_MASK)
N/* FPROT2 Bit Fields */
N#define NV_FPROT2_PROT_MASK                      0xFFu
N#define NV_FPROT2_PROT_SHIFT                     0
N#define NV_FPROT2_PROT(x)                        (((uint8_t)(((uint8_t)(x))<<NV_FPROT2_PROT_SHIFT))&NV_FPROT2_PROT_MASK)
N/* FPROT1 Bit Fields */
N#define NV_FPROT1_PROT_MASK                      0xFFu
N#define NV_FPROT1_PROT_SHIFT                     0
N#define NV_FPROT1_PROT(x)                        (((uint8_t)(((uint8_t)(x))<<NV_FPROT1_PROT_SHIFT))&NV_FPROT1_PROT_MASK)
N/* FPROT0 Bit Fields */
N#define NV_FPROT0_PROT_MASK                      0xFFu
N#define NV_FPROT0_PROT_SHIFT                     0
N#define NV_FPROT0_PROT(x)                        (((uint8_t)(((uint8_t)(x))<<NV_FPROT0_PROT_SHIFT))&NV_FPROT0_PROT_MASK)
N/* FSEC Bit Fields */
N#define NV_FSEC_SEC_MASK                         0x3u
N#define NV_FSEC_SEC_SHIFT                        0
N#define NV_FSEC_SEC(x)                           (((uint8_t)(((uint8_t)(x))<<NV_FSEC_SEC_SHIFT))&NV_FSEC_SEC_MASK)
N#define NV_FSEC_FSLACC_MASK                      0xCu
N#define NV_FSEC_FSLACC_SHIFT                     2
N#define NV_FSEC_FSLACC(x)                        (((uint8_t)(((uint8_t)(x))<<NV_FSEC_FSLACC_SHIFT))&NV_FSEC_FSLACC_MASK)
N#define NV_FSEC_MEEN_MASK                        0x30u
N#define NV_FSEC_MEEN_SHIFT                       4
N#define NV_FSEC_MEEN(x)                          (((uint8_t)(((uint8_t)(x))<<NV_FSEC_MEEN_SHIFT))&NV_FSEC_MEEN_MASK)
N#define NV_FSEC_KEYEN_MASK                       0xC0u
N#define NV_FSEC_KEYEN_SHIFT                      6
N#define NV_FSEC_KEYEN(x)                         (((uint8_t)(((uint8_t)(x))<<NV_FSEC_KEYEN_SHIFT))&NV_FSEC_KEYEN_MASK)
N/* FOPT Bit Fields */
N#define NV_FOPT_LPBOOT0_MASK                     0x1u
N#define NV_FOPT_LPBOOT0_SHIFT                    0
N#define NV_FOPT_NMI_DIS_MASK                     0x4u
N#define NV_FOPT_NMI_DIS_SHIFT                    2
N#define NV_FOPT_RESET_PIN_CFG_MASK               0x8u
N#define NV_FOPT_RESET_PIN_CFG_SHIFT              3
N#define NV_FOPT_LPBOOT1_MASK                     0x10u
N#define NV_FOPT_LPBOOT1_SHIFT                    4
N#define NV_FOPT_FAST_INIT_MASK                   0x20u
N#define NV_FOPT_FAST_INIT_SHIFT                  5
N
N/**
N * @}
N */ /* end of group NV_Register_Masks */
N
N
N/* NV - Peripheral instance base addresses */
N/** Peripheral FTFA_FlashConfig base address */
N#define FTFA_FlashConfig_BASE                    (0x400u)
N/** Peripheral FTFA_FlashConfig base pointer */
N#define FTFA_FlashConfig                         ((NV_Type *)FTFA_FlashConfig_BASE)
N/** Array initializer of NV peripheral base pointers */
N#define NV_BASES                                 { FTFA_FlashConfig }
N
N/**
N * @}
N */ /* end of group NV_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- OSC Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup OSC_Peripheral_Access_Layer OSC Peripheral Access Layer
N * @{
N */
N
N/** OSC - Register Layout Typedef */
Ntypedef struct {
N  __IO uint8_t CR;                                 /**< OSC Control Register, offset: 0x0 */
X  volatile uint8_t CR;                                  
N} OSC_Type;
N
N/* ----------------------------------------------------------------------------
N   -- OSC Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup OSC_Register_Masks OSC Register Masks
N * @{
N */
N
N/* CR Bit Fields */
N#define OSC_CR_SC16P_MASK                        0x1u
N#define OSC_CR_SC16P_SHIFT                       0
N#define OSC_CR_SC8P_MASK                         0x2u
N#define OSC_CR_SC8P_SHIFT                        1
N#define OSC_CR_SC4P_MASK                         0x4u
N#define OSC_CR_SC4P_SHIFT                        2
N#define OSC_CR_SC2P_MASK                         0x8u
N#define OSC_CR_SC2P_SHIFT                        3
N#define OSC_CR_EREFSTEN_MASK                     0x20u
N#define OSC_CR_EREFSTEN_SHIFT                    5
N#define OSC_CR_ERCLKEN_MASK                      0x80u
N#define OSC_CR_ERCLKEN_SHIFT                     7
N
N/**
N * @}
N */ /* end of group OSC_Register_Masks */
N
N
N/* OSC - Peripheral instance base addresses */
N/** Peripheral OSC0 base address */
N#define OSC0_BASE                                (0x40065000u)
N/** Peripheral OSC0 base pointer */
N#define OSC0                                     ((OSC_Type *)OSC0_BASE)
N/** Array initializer of OSC peripheral base pointers */
N#define OSC_BASES                                { OSC0 }
N
N/**
N * @}
N */ /* end of group OSC_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- PIT Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup PIT_Peripheral_Access_Layer PIT Peripheral Access Layer
N * @{
N */
N
N/** PIT - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t MCR;                               /**< PIT Module Control Register, offset: 0x0 */
X  volatile uint32_t MCR;                                
N       uint8_t RESERVED_0[220];
N  __I  uint32_t LTMR64H;                           /**< PIT Upper Lifetime Timer Register, offset: 0xE0 */
X  volatile const  uint32_t LTMR64H;                            
N  __I  uint32_t LTMR64L;                           /**< PIT Lower Lifetime Timer Register, offset: 0xE4 */
X  volatile const  uint32_t LTMR64L;                            
N       uint8_t RESERVED_1[24];
N  struct {                                         /* offset: 0x100, array step: 0x10 */
N    __IO uint32_t LDVAL;                             /**< Timer Load Value Register, array offset: 0x100, array step: 0x10 */
X    volatile uint32_t LDVAL;                              
N    __I  uint32_t CVAL;                              /**< Current Timer Value Register, array offset: 0x104, array step: 0x10 */
X    volatile const  uint32_t CVAL;                               
N    __IO uint32_t TCTRL;                             /**< Timer Control Register, array offset: 0x108, array step: 0x10 */
X    volatile uint32_t TCTRL;                              
N    __IO uint32_t TFLG;                              /**< Timer Flag Register, array offset: 0x10C, array step: 0x10 */
X    volatile uint32_t TFLG;                               
N  } CHANNEL[2];
N} PIT_Type;
N
N/* ----------------------------------------------------------------------------
N   -- PIT Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup PIT_Register_Masks PIT Register Masks
N * @{
N */
N
N/* MCR Bit Fields */
N#define PIT_MCR_FRZ_MASK                         0x1u
N#define PIT_MCR_FRZ_SHIFT                        0
N#define PIT_MCR_MDIS_MASK                        0x2u
N#define PIT_MCR_MDIS_SHIFT                       1
N/* LTMR64H Bit Fields */
N#define PIT_LTMR64H_LTH_MASK                     0xFFFFFFFFu
N#define PIT_LTMR64H_LTH_SHIFT                    0
N#define PIT_LTMR64H_LTH(x)                       (((uint32_t)(((uint32_t)(x))<<PIT_LTMR64H_LTH_SHIFT))&PIT_LTMR64H_LTH_MASK)
N/* LTMR64L Bit Fields */
N#define PIT_LTMR64L_LTL_MASK                     0xFFFFFFFFu
N#define PIT_LTMR64L_LTL_SHIFT                    0
N#define PIT_LTMR64L_LTL(x)                       (((uint32_t)(((uint32_t)(x))<<PIT_LTMR64L_LTL_SHIFT))&PIT_LTMR64L_LTL_MASK)
N/* LDVAL Bit Fields */
N#define PIT_LDVAL_TSV_MASK                       0xFFFFFFFFu
N#define PIT_LDVAL_TSV_SHIFT                      0
N#define PIT_LDVAL_TSV(x)                         (((uint32_t)(((uint32_t)(x))<<PIT_LDVAL_TSV_SHIFT))&PIT_LDVAL_TSV_MASK)
N/* CVAL Bit Fields */
N#define PIT_CVAL_TVL_MASK                        0xFFFFFFFFu
N#define PIT_CVAL_TVL_SHIFT                       0
N#define PIT_CVAL_TVL(x)                          (((uint32_t)(((uint32_t)(x))<<PIT_CVAL_TVL_SHIFT))&PIT_CVAL_TVL_MASK)
N/* TCTRL Bit Fields */
N#define PIT_TCTRL_TEN_MASK                       0x1u
N#define PIT_TCTRL_TEN_SHIFT                      0
N#define PIT_TCTRL_TIE_MASK                       0x2u
N#define PIT_TCTRL_TIE_SHIFT                      1
N#define PIT_TCTRL_CHN_MASK                       0x4u
N#define PIT_TCTRL_CHN_SHIFT                      2
N/* TFLG Bit Fields */
N#define PIT_TFLG_TIF_MASK                        0x1u
N#define PIT_TFLG_TIF_SHIFT                       0
N
N/**
N * @}
N */ /* end of group PIT_Register_Masks */
N
N
N/* PIT - Peripheral instance base addresses */
N/** Peripheral PIT base address */
N#define PIT_BASE                                 (0x40037000u)
N/** Peripheral PIT base pointer */
N#define PIT                                      ((PIT_Type *)PIT_BASE)
N/** Array initializer of PIT peripheral base pointers */
N#define PIT_BASES                                { PIT }
N
N/**
N * @}
N */ /* end of group PIT_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- PMC Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup PMC_Peripheral_Access_Layer PMC Peripheral Access Layer
N * @{
N */
N
N/** PMC - Register Layout Typedef */
Ntypedef struct {
N  __IO uint8_t LVDSC1;                             /**< Low Voltage Detect Status And Control 1 register, offset: 0x0 */
X  volatile uint8_t LVDSC1;                              
N  __IO uint8_t LVDSC2;                             /**< Low Voltage Detect Status And Control 2 register, offset: 0x1 */
X  volatile uint8_t LVDSC2;                              
N  __IO uint8_t REGSC;                              /**< Regulator Status And Control register, offset: 0x2 */
X  volatile uint8_t REGSC;                               
N} PMC_Type;
N
N/* ----------------------------------------------------------------------------
N   -- PMC Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup PMC_Register_Masks PMC Register Masks
N * @{
N */
N
N/* LVDSC1 Bit Fields */
N#define PMC_LVDSC1_LVDV_MASK                     0x3u
N#define PMC_LVDSC1_LVDV_SHIFT                    0
N#define PMC_LVDSC1_LVDV(x)                       (((uint8_t)(((uint8_t)(x))<<PMC_LVDSC1_LVDV_SHIFT))&PMC_LVDSC1_LVDV_MASK)
N#define PMC_LVDSC1_LVDRE_MASK                    0x10u
N#define PMC_LVDSC1_LVDRE_SHIFT                   4
N#define PMC_LVDSC1_LVDIE_MASK                    0x20u
N#define PMC_LVDSC1_LVDIE_SHIFT                   5
N#define PMC_LVDSC1_LVDACK_MASK                   0x40u
N#define PMC_LVDSC1_LVDACK_SHIFT                  6
N#define PMC_LVDSC1_LVDF_MASK                     0x80u
N#define PMC_LVDSC1_LVDF_SHIFT                    7
N/* LVDSC2 Bit Fields */
N#define PMC_LVDSC2_LVWV_MASK                     0x3u
N#define PMC_LVDSC2_LVWV_SHIFT                    0
N#define PMC_LVDSC2_LVWV(x)                       (((uint8_t)(((uint8_t)(x))<<PMC_LVDSC2_LVWV_SHIFT))&PMC_LVDSC2_LVWV_MASK)
N#define PMC_LVDSC2_LVWIE_MASK                    0x20u
N#define PMC_LVDSC2_LVWIE_SHIFT                   5
N#define PMC_LVDSC2_LVWACK_MASK                   0x40u
N#define PMC_LVDSC2_LVWACK_SHIFT                  6
N#define PMC_LVDSC2_LVWF_MASK                     0x80u
N#define PMC_LVDSC2_LVWF_SHIFT                    7
N/* REGSC Bit Fields */
N#define PMC_REGSC_BGBE_MASK                      0x1u
N#define PMC_REGSC_BGBE_SHIFT                     0
N#define PMC_REGSC_REGONS_MASK                    0x4u
N#define PMC_REGSC_REGONS_SHIFT                   2
N#define PMC_REGSC_ACKISO_MASK                    0x8u
N#define PMC_REGSC_ACKISO_SHIFT                   3
N#define PMC_REGSC_BGEN_MASK                      0x10u
N#define PMC_REGSC_BGEN_SHIFT                     4
N
N/**
N * @}
N */ /* end of group PMC_Register_Masks */
N
N
N/* PMC - Peripheral instance base addresses */
N/** Peripheral PMC base address */
N#define PMC_BASE                                 (0x4007D000u)
N/** Peripheral PMC base pointer */
N#define PMC                                      ((PMC_Type *)PMC_BASE)
N/** Array initializer of PMC peripheral base pointers */
N#define PMC_BASES                                { PMC }
N
N/**
N * @}
N */ /* end of group PMC_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- PORT Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup PORT_Peripheral_Access_Layer PORT Peripheral Access Layer
N * @{
N */
N
N/** PORT - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t PCR[32];                           /**< Pin Control Register n, array offset: 0x0, array step: 0x4 */
X  volatile uint32_t PCR[32];                            
N  __O  uint32_t GPCLR;                             /**< Global Pin Control Low Register, offset: 0x80 */
X  volatile  uint32_t GPCLR;                              
N  __O  uint32_t GPCHR;                             /**< Global Pin Control High Register, offset: 0x84 */
X  volatile  uint32_t GPCHR;                              
N       uint8_t RESERVED_0[24];
N  __IO uint32_t ISFR;                              /**< Interrupt Status Flag Register, offset: 0xA0 */
X  volatile uint32_t ISFR;                               
N} PORT_Type;
N
N/* ----------------------------------------------------------------------------
N   -- PORT Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup PORT_Register_Masks PORT Register Masks
N * @{
N */
N
N/* PCR Bit Fields */
N#define PORT_PCR_PS_MASK                         0x1u
N#define PORT_PCR_PS_SHIFT                        0
N#define PORT_PCR_PE_MASK                         0x2u
N#define PORT_PCR_PE_SHIFT                        1
N#define PORT_PCR_SRE_MASK                        0x4u
N#define PORT_PCR_SRE_SHIFT                       2
N#define PORT_PCR_PFE_MASK                        0x10u
N#define PORT_PCR_PFE_SHIFT                       4
N#define PORT_PCR_DSE_MASK                        0x40u
N#define PORT_PCR_DSE_SHIFT                       6
N#define PORT_PCR_MUX_MASK                        0x700u
N#define PORT_PCR_MUX_SHIFT                       8
N#define PORT_PCR_MUX(x)                          (((uint32_t)(((uint32_t)(x))<<PORT_PCR_MUX_SHIFT))&PORT_PCR_MUX_MASK)
N#define PORT_PCR_IRQC_MASK                       0xF0000u
N#define PORT_PCR_IRQC_SHIFT                      16
N#define PORT_PCR_IRQC(x)                         (((uint32_t)(((uint32_t)(x))<<PORT_PCR_IRQC_SHIFT))&PORT_PCR_IRQC_MASK)
N#define PORT_PCR_ISF_MASK                        0x1000000u
N#define PORT_PCR_ISF_SHIFT                       24
N/* GPCLR Bit Fields */
N#define PORT_GPCLR_GPWD_MASK                     0xFFFFu
N#define PORT_GPCLR_GPWD_SHIFT                    0
N#define PORT_GPCLR_GPWD(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_GPCLR_GPWD_SHIFT))&PORT_GPCLR_GPWD_MASK)
N#define PORT_GPCLR_GPWE_MASK                     0xFFFF0000u
N#define PORT_GPCLR_GPWE_SHIFT                    16
N#define PORT_GPCLR_GPWE(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_GPCLR_GPWE_SHIFT))&PORT_GPCLR_GPWE_MASK)
N/* GPCHR Bit Fields */
N#define PORT_GPCHR_GPWD_MASK                     0xFFFFu
N#define PORT_GPCHR_GPWD_SHIFT                    0
N#define PORT_GPCHR_GPWD(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_GPCHR_GPWD_SHIFT))&PORT_GPCHR_GPWD_MASK)
N#define PORT_GPCHR_GPWE_MASK                     0xFFFF0000u
N#define PORT_GPCHR_GPWE_SHIFT                    16
N#define PORT_GPCHR_GPWE(x)                       (((uint32_t)(((uint32_t)(x))<<PORT_GPCHR_GPWE_SHIFT))&PORT_GPCHR_GPWE_MASK)
N/* ISFR Bit Fields */
N#define PORT_ISFR_ISF_MASK                       0xFFFFFFFFu
N#define PORT_ISFR_ISF_SHIFT                      0
N#define PORT_ISFR_ISF(x)                         (((uint32_t)(((uint32_t)(x))<<PORT_ISFR_ISF_SHIFT))&PORT_ISFR_ISF_MASK)
N
N/**
N * @}
N */ /* end of group PORT_Register_Masks */
N
N
N/* PORT - Peripheral instance base addresses */
N/** Peripheral PORTA base address */
N#define PORTA_BASE                               (0x40049000u)
N/** Peripheral PORTA base pointer */
N#define PORTA                                    ((PORT_Type *)PORTA_BASE)
N/** Peripheral PORTB base address */
N#define PORTB_BASE                               (0x4004A000u)
N/** Peripheral PORTB base pointer */
N#define PORTB                                    ((PORT_Type *)PORTB_BASE)
N/** Peripheral PORTC base address */
N#define PORTC_BASE                               (0x4004B000u)
N/** Peripheral PORTC base pointer */
N#define PORTC                                    ((PORT_Type *)PORTC_BASE)
N/** Peripheral PORTD base address */
N#define PORTD_BASE                               (0x4004C000u)
N/** Peripheral PORTD base pointer */
N#define PORTD                                    ((PORT_Type *)PORTD_BASE)
N/** Peripheral PORTE base address */
N#define PORTE_BASE                               (0x4004D000u)
N/** Peripheral PORTE base pointer */
N#define PORTE                                    ((PORT_Type *)PORTE_BASE)
N/** Array initializer of PORT peripheral base pointers */
N#define PORT_BASES                               { PORTA, PORTB, PORTC, PORTD, PORTE }
N
N/**
N * @}
N */ /* end of group PORT_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- RCM Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup RCM_Peripheral_Access_Layer RCM Peripheral Access Layer
N * @{
N */
N
N/** RCM - Register Layout Typedef */
Ntypedef struct {
N  __I  uint8_t SRS0;                               /**< System Reset Status Register 0, offset: 0x0 */
X  volatile const  uint8_t SRS0;                                
N  __I  uint8_t SRS1;                               /**< System Reset Status Register 1, offset: 0x1 */
X  volatile const  uint8_t SRS1;                                
N       uint8_t RESERVED_0[2];
N  __IO uint8_t RPFC;                               /**< Reset Pin Filter Control register, offset: 0x4 */
X  volatile uint8_t RPFC;                                
N  __IO uint8_t RPFW;                               /**< Reset Pin Filter Width register, offset: 0x5 */
X  volatile uint8_t RPFW;                                
N} RCM_Type;
N
N/* ----------------------------------------------------------------------------
N   -- RCM Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup RCM_Register_Masks RCM Register Masks
N * @{
N */
N
N/* SRS0 Bit Fields */
N#define RCM_SRS0_WAKEUP_MASK                     0x1u
N#define RCM_SRS0_WAKEUP_SHIFT                    0
N#define RCM_SRS0_LVD_MASK                        0x2u
N#define RCM_SRS0_LVD_SHIFT                       1
N#define RCM_SRS0_LOC_MASK                        0x4u
N#define RCM_SRS0_LOC_SHIFT                       2
N#define RCM_SRS0_LOL_MASK                        0x8u
N#define RCM_SRS0_LOL_SHIFT                       3
N#define RCM_SRS0_WDOG_MASK                       0x20u
N#define RCM_SRS0_WDOG_SHIFT                      5
N#define RCM_SRS0_PIN_MASK                        0x40u
N#define RCM_SRS0_PIN_SHIFT                       6
N#define RCM_SRS0_POR_MASK                        0x80u
N#define RCM_SRS0_POR_SHIFT                       7
N/* SRS1 Bit Fields */
N#define RCM_SRS1_LOCKUP_MASK                     0x2u
N#define RCM_SRS1_LOCKUP_SHIFT                    1
N#define RCM_SRS1_SW_MASK                         0x4u
N#define RCM_SRS1_SW_SHIFT                        2
N#define RCM_SRS1_MDM_AP_MASK                     0x8u
N#define RCM_SRS1_MDM_AP_SHIFT                    3
N#define RCM_SRS1_SACKERR_MASK                    0x20u
N#define RCM_SRS1_SACKERR_SHIFT                   5
N/* RPFC Bit Fields */
N#define RCM_RPFC_RSTFLTSRW_MASK                  0x3u
N#define RCM_RPFC_RSTFLTSRW_SHIFT                 0
N#define RCM_RPFC_RSTFLTSRW(x)                    (((uint8_t)(((uint8_t)(x))<<RCM_RPFC_RSTFLTSRW_SHIFT))&RCM_RPFC_RSTFLTSRW_MASK)
N#define RCM_RPFC_RSTFLTSS_MASK                   0x4u
N#define RCM_RPFC_RSTFLTSS_SHIFT                  2
N/* RPFW Bit Fields */
N#define RCM_RPFW_RSTFLTSEL_MASK                  0x1Fu
N#define RCM_RPFW_RSTFLTSEL_SHIFT                 0
N#define RCM_RPFW_RSTFLTSEL(x)                    (((uint8_t)(((uint8_t)(x))<<RCM_RPFW_RSTFLTSEL_SHIFT))&RCM_RPFW_RSTFLTSEL_MASK)
N
N/**
N * @}
N */ /* end of group RCM_Register_Masks */
N
N
N/* RCM - Peripheral instance base addresses */
N/** Peripheral RCM base address */
N#define RCM_BASE                                 (0x4007F000u)
N/** Peripheral RCM base pointer */
N#define RCM                                      ((RCM_Type *)RCM_BASE)
N/** Array initializer of RCM peripheral base pointers */
N#define RCM_BASES                                { RCM }
N
N/**
N * @}
N */ /* end of group RCM_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- ROM Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup ROM_Peripheral_Access_Layer ROM Peripheral Access Layer
N * @{
N */
N
N/** ROM - Register Layout Typedef */
Ntypedef struct {
N  __I  uint32_t ENTRY[3];                          /**< Entry, array offset: 0x0, array step: 0x4 */
X  volatile const  uint32_t ENTRY[3];                           
N  __I  uint32_t TABLEMARK;                         /**< End of Table Marker Register, offset: 0xC */
X  volatile const  uint32_t TABLEMARK;                          
N       uint8_t RESERVED_0[4028];
N  __I  uint32_t SYSACCESS;                         /**< System Access Register, offset: 0xFCC */
X  volatile const  uint32_t SYSACCESS;                          
N  __I  uint32_t PERIPHID4;                         /**< Peripheral ID Register, offset: 0xFD0 */
X  volatile const  uint32_t PERIPHID4;                          
N  __I  uint32_t PERIPHID5;                         /**< Peripheral ID Register, offset: 0xFD4 */
X  volatile const  uint32_t PERIPHID5;                          
N  __I  uint32_t PERIPHID6;                         /**< Peripheral ID Register, offset: 0xFD8 */
X  volatile const  uint32_t PERIPHID6;                          
N  __I  uint32_t PERIPHID7;                         /**< Peripheral ID Register, offset: 0xFDC */
X  volatile const  uint32_t PERIPHID7;                          
N  __I  uint32_t PERIPHID0;                         /**< Peripheral ID Register, offset: 0xFE0 */
X  volatile const  uint32_t PERIPHID0;                          
N  __I  uint32_t PERIPHID1;                         /**< Peripheral ID Register, offset: 0xFE4 */
X  volatile const  uint32_t PERIPHID1;                          
N  __I  uint32_t PERIPHID2;                         /**< Peripheral ID Register, offset: 0xFE8 */
X  volatile const  uint32_t PERIPHID2;                          
N  __I  uint32_t PERIPHID3;                         /**< Peripheral ID Register, offset: 0xFEC */
X  volatile const  uint32_t PERIPHID3;                          
N  __I  uint32_t COMPID[4];                         /**< Component ID Register, array offset: 0xFF0, array step: 0x4 */
X  volatile const  uint32_t COMPID[4];                          
N} ROM_Type;
N
N/* ----------------------------------------------------------------------------
N   -- ROM Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup ROM_Register_Masks ROM Register Masks
N * @{
N */
N
N/* ENTRY Bit Fields */
N#define ROM_ENTRY_ENTRY_MASK                     0xFFFFFFFFu
N#define ROM_ENTRY_ENTRY_SHIFT                    0
N#define ROM_ENTRY_ENTRY(x)                       (((uint32_t)(((uint32_t)(x))<<ROM_ENTRY_ENTRY_SHIFT))&ROM_ENTRY_ENTRY_MASK)
N/* TABLEMARK Bit Fields */
N#define ROM_TABLEMARK_MARK_MASK                  0xFFFFFFFFu
N#define ROM_TABLEMARK_MARK_SHIFT                 0
N#define ROM_TABLEMARK_MARK(x)                    (((uint32_t)(((uint32_t)(x))<<ROM_TABLEMARK_MARK_SHIFT))&ROM_TABLEMARK_MARK_MASK)
N/* SYSACCESS Bit Fields */
N#define ROM_SYSACCESS_SYSACCESS_MASK             0xFFFFFFFFu
N#define ROM_SYSACCESS_SYSACCESS_SHIFT            0
N#define ROM_SYSACCESS_SYSACCESS(x)               (((uint32_t)(((uint32_t)(x))<<ROM_SYSACCESS_SYSACCESS_SHIFT))&ROM_SYSACCESS_SYSACCESS_MASK)
N/* PERIPHID4 Bit Fields */
N#define ROM_PERIPHID4_PERIPHID_MASK              0xFFFFFFFFu
N#define ROM_PERIPHID4_PERIPHID_SHIFT             0
N#define ROM_PERIPHID4_PERIPHID(x)                (((uint32_t)(((uint32_t)(x))<<ROM_PERIPHID4_PERIPHID_SHIFT))&ROM_PERIPHID4_PERIPHID_MASK)
N/* PERIPHID5 Bit Fields */
N#define ROM_PERIPHID5_PERIPHID_MASK              0xFFFFFFFFu
N#define ROM_PERIPHID5_PERIPHID_SHIFT             0
N#define ROM_PERIPHID5_PERIPHID(x)                (((uint32_t)(((uint32_t)(x))<<ROM_PERIPHID5_PERIPHID_SHIFT))&ROM_PERIPHID5_PERIPHID_MASK)
N/* PERIPHID6 Bit Fields */
N#define ROM_PERIPHID6_PERIPHID_MASK              0xFFFFFFFFu
N#define ROM_PERIPHID6_PERIPHID_SHIFT             0
N#define ROM_PERIPHID6_PERIPHID(x)                (((uint32_t)(((uint32_t)(x))<<ROM_PERIPHID6_PERIPHID_SHIFT))&ROM_PERIPHID6_PERIPHID_MASK)
N/* PERIPHID7 Bit Fields */
N#define ROM_PERIPHID7_PERIPHID_MASK              0xFFFFFFFFu
N#define ROM_PERIPHID7_PERIPHID_SHIFT             0
N#define ROM_PERIPHID7_PERIPHID(x)                (((uint32_t)(((uint32_t)(x))<<ROM_PERIPHID7_PERIPHID_SHIFT))&ROM_PERIPHID7_PERIPHID_MASK)
N/* PERIPHID0 Bit Fields */
N#define ROM_PERIPHID0_PERIPHID_MASK              0xFFFFFFFFu
N#define ROM_PERIPHID0_PERIPHID_SHIFT             0
N#define ROM_PERIPHID0_PERIPHID(x)                (((uint32_t)(((uint32_t)(x))<<ROM_PERIPHID0_PERIPHID_SHIFT))&ROM_PERIPHID0_PERIPHID_MASK)
N/* PERIPHID1 Bit Fields */
N#define ROM_PERIPHID1_PERIPHID_MASK              0xFFFFFFFFu
N#define ROM_PERIPHID1_PERIPHID_SHIFT             0
N#define ROM_PERIPHID1_PERIPHID(x)                (((uint32_t)(((uint32_t)(x))<<ROM_PERIPHID1_PERIPHID_SHIFT))&ROM_PERIPHID1_PERIPHID_MASK)
N/* PERIPHID2 Bit Fields */
N#define ROM_PERIPHID2_PERIPHID_MASK              0xFFFFFFFFu
N#define ROM_PERIPHID2_PERIPHID_SHIFT             0
N#define ROM_PERIPHID2_PERIPHID(x)                (((uint32_t)(((uint32_t)(x))<<ROM_PERIPHID2_PERIPHID_SHIFT))&ROM_PERIPHID2_PERIPHID_MASK)
N/* PERIPHID3 Bit Fields */
N#define ROM_PERIPHID3_PERIPHID_MASK              0xFFFFFFFFu
N#define ROM_PERIPHID3_PERIPHID_SHIFT             0
N#define ROM_PERIPHID3_PERIPHID(x)                (((uint32_t)(((uint32_t)(x))<<ROM_PERIPHID3_PERIPHID_SHIFT))&ROM_PERIPHID3_PERIPHID_MASK)
N/* COMPID Bit Fields */
N#define ROM_COMPID_COMPID_MASK                   0xFFFFFFFFu
N#define ROM_COMPID_COMPID_SHIFT                  0
N#define ROM_COMPID_COMPID(x)                     (((uint32_t)(((uint32_t)(x))<<ROM_COMPID_COMPID_SHIFT))&ROM_COMPID_COMPID_MASK)
N
N/**
N * @}
N */ /* end of group ROM_Register_Masks */
N
N
N/* ROM - Peripheral instance base addresses */
N/** Peripheral ROM base address */
N#define ROM_BASE                                 (0xF0002000u)
N/** Peripheral ROM base pointer */
N#define ROM                                      ((ROM_Type *)ROM_BASE)
N/** Array initializer of ROM peripheral base pointers */
N#define ROM_BASES                                { ROM }
N
N/**
N * @}
N */ /* end of group ROM_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- RTC Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup RTC_Peripheral_Access_Layer RTC Peripheral Access Layer
N * @{
N */
N
N/** RTC - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t TSR;                               /**< RTC Time Seconds Register, offset: 0x0 */
X  volatile uint32_t TSR;                                
N  __IO uint32_t TPR;                               /**< RTC Time Prescaler Register, offset: 0x4 */
X  volatile uint32_t TPR;                                
N  __IO uint32_t TAR;                               /**< RTC Time Alarm Register, offset: 0x8 */
X  volatile uint32_t TAR;                                
N  __IO uint32_t TCR;                               /**< RTC Time Compensation Register, offset: 0xC */
X  volatile uint32_t TCR;                                
N  __IO uint32_t CR;                                /**< RTC Control Register, offset: 0x10 */
X  volatile uint32_t CR;                                 
N  __IO uint32_t SR;                                /**< RTC Status Register, offset: 0x14 */
X  volatile uint32_t SR;                                 
N  __IO uint32_t LR;                                /**< RTC Lock Register, offset: 0x18 */
X  volatile uint32_t LR;                                 
N  __IO uint32_t IER;                               /**< RTC Interrupt Enable Register, offset: 0x1C */
X  volatile uint32_t IER;                                
N} RTC_Type;
N
N/* ----------------------------------------------------------------------------
N   -- RTC Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup RTC_Register_Masks RTC Register Masks
N * @{
N */
N
N/* TSR Bit Fields */
N#define RTC_TSR_TSR_MASK                         0xFFFFFFFFu
N#define RTC_TSR_TSR_SHIFT                        0
N#define RTC_TSR_TSR(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_TSR_TSR_SHIFT))&RTC_TSR_TSR_MASK)
N/* TPR Bit Fields */
N#define RTC_TPR_TPR_MASK                         0xFFFFu
N#define RTC_TPR_TPR_SHIFT                        0
N#define RTC_TPR_TPR(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_TPR_TPR_SHIFT))&RTC_TPR_TPR_MASK)
N/* TAR Bit Fields */
N#define RTC_TAR_TAR_MASK                         0xFFFFFFFFu
N#define RTC_TAR_TAR_SHIFT                        0
N#define RTC_TAR_TAR(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_TAR_TAR_SHIFT))&RTC_TAR_TAR_MASK)
N/* TCR Bit Fields */
N#define RTC_TCR_TCR_MASK                         0xFFu
N#define RTC_TCR_TCR_SHIFT                        0
N#define RTC_TCR_TCR(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_TCR_TCR_SHIFT))&RTC_TCR_TCR_MASK)
N#define RTC_TCR_CIR_MASK                         0xFF00u
N#define RTC_TCR_CIR_SHIFT                        8
N#define RTC_TCR_CIR(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_TCR_CIR_SHIFT))&RTC_TCR_CIR_MASK)
N#define RTC_TCR_TCV_MASK                         0xFF0000u
N#define RTC_TCR_TCV_SHIFT                        16
N#define RTC_TCR_TCV(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_TCR_TCV_SHIFT))&RTC_TCR_TCV_MASK)
N#define RTC_TCR_CIC_MASK                         0xFF000000u
N#define RTC_TCR_CIC_SHIFT                        24
N#define RTC_TCR_CIC(x)                           (((uint32_t)(((uint32_t)(x))<<RTC_TCR_CIC_SHIFT))&RTC_TCR_CIC_MASK)
N/* CR Bit Fields */
N#define RTC_CR_SWR_MASK                          0x1u
N#define RTC_CR_SWR_SHIFT                         0
N#define RTC_CR_WPE_MASK                          0x2u
N#define RTC_CR_WPE_SHIFT                         1
N#define RTC_CR_SUP_MASK                          0x4u
N#define RTC_CR_SUP_SHIFT                         2
N#define RTC_CR_UM_MASK                           0x8u
N#define RTC_CR_UM_SHIFT                          3
N#define RTC_CR_OSCE_MASK                         0x100u
N#define RTC_CR_OSCE_SHIFT                        8
N#define RTC_CR_CLKO_MASK                         0x200u
N#define RTC_CR_CLKO_SHIFT                        9
N#define RTC_CR_SC16P_MASK                        0x400u
N#define RTC_CR_SC16P_SHIFT                       10
N#define RTC_CR_SC8P_MASK                         0x800u
N#define RTC_CR_SC8P_SHIFT                        11
N#define RTC_CR_SC4P_MASK                         0x1000u
N#define RTC_CR_SC4P_SHIFT                        12
N#define RTC_CR_SC2P_MASK                         0x2000u
N#define RTC_CR_SC2P_SHIFT                        13
N/* SR Bit Fields */
N#define RTC_SR_TIF_MASK                          0x1u
N#define RTC_SR_TIF_SHIFT                         0
N#define RTC_SR_TOF_MASK                          0x2u
N#define RTC_SR_TOF_SHIFT                         1
N#define RTC_SR_TAF_MASK                          0x4u
N#define RTC_SR_TAF_SHIFT                         2
N#define RTC_SR_TCE_MASK                          0x10u
N#define RTC_SR_TCE_SHIFT                         4
N/* LR Bit Fields */
N#define RTC_LR_TCL_MASK                          0x8u
N#define RTC_LR_TCL_SHIFT                         3
N#define RTC_LR_CRL_MASK                          0x10u
N#define RTC_LR_CRL_SHIFT                         4
N#define RTC_LR_SRL_MASK                          0x20u
N#define RTC_LR_SRL_SHIFT                         5
N#define RTC_LR_LRL_MASK                          0x40u
N#define RTC_LR_LRL_SHIFT                         6
N/* IER Bit Fields */
N#define RTC_IER_TIIE_MASK                        0x1u
N#define RTC_IER_TIIE_SHIFT                       0
N#define RTC_IER_TOIE_MASK                        0x2u
N#define RTC_IER_TOIE_SHIFT                       1
N#define RTC_IER_TAIE_MASK                        0x4u
N#define RTC_IER_TAIE_SHIFT                       2
N#define RTC_IER_TSIE_MASK                        0x10u
N#define RTC_IER_TSIE_SHIFT                       4
N#define RTC_IER_WPON_MASK                        0x80u
N#define RTC_IER_WPON_SHIFT                       7
N
N/**
N * @}
N */ /* end of group RTC_Register_Masks */
N
N
N/* RTC - Peripheral instance base addresses */
N/** Peripheral RTC base address */
N#define RTC_BASE                                 (0x4003D000u)
N/** Peripheral RTC base pointer */
N#define RTC                                      ((RTC_Type *)RTC_BASE)
N/** Array initializer of RTC peripheral base pointers */
N#define RTC_BASES                                { RTC }
N
N/**
N * @}
N */ /* end of group RTC_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- SIM Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup SIM_Peripheral_Access_Layer SIM Peripheral Access Layer
N * @{
N */
N
N/** SIM - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t SOPT1;                             /**< System Options Register 1, offset: 0x0 */
X  volatile uint32_t SOPT1;                              
N  __IO uint32_t SOPT1CFG;                          /**< SOPT1 Configuration Register, offset: 0x4 */
X  volatile uint32_t SOPT1CFG;                           
N       uint8_t RESERVED_0[4092];
N  __IO uint32_t SOPT2;                             /**< System Options Register 2, offset: 0x1004 */
X  volatile uint32_t SOPT2;                              
N       uint8_t RESERVED_1[4];
N  __IO uint32_t SOPT4;                             /**< System Options Register 4, offset: 0x100C */
X  volatile uint32_t SOPT4;                              
N  __IO uint32_t SOPT5;                             /**< System Options Register 5, offset: 0x1010 */
X  volatile uint32_t SOPT5;                              
N       uint8_t RESERVED_2[4];
N  __IO uint32_t SOPT7;                             /**< System Options Register 7, offset: 0x1018 */
X  volatile uint32_t SOPT7;                              
N       uint8_t RESERVED_3[8];
N  __I  uint32_t SDID;                              /**< System Device Identification Register, offset: 0x1024 */
X  volatile const  uint32_t SDID;                               
N       uint8_t RESERVED_4[12];
N  __IO uint32_t SCGC4;                             /**< System Clock Gating Control Register 4, offset: 0x1034 */
X  volatile uint32_t SCGC4;                              
N  __IO uint32_t SCGC5;                             /**< System Clock Gating Control Register 5, offset: 0x1038 */
X  volatile uint32_t SCGC5;                              
N  __IO uint32_t SCGC6;                             /**< System Clock Gating Control Register 6, offset: 0x103C */
X  volatile uint32_t SCGC6;                              
N  __IO uint32_t SCGC7;                             /**< System Clock Gating Control Register 7, offset: 0x1040 */
X  volatile uint32_t SCGC7;                              
N  __IO uint32_t CLKDIV1;                           /**< System Clock Divider Register 1, offset: 0x1044 */
X  volatile uint32_t CLKDIV1;                            
N       uint8_t RESERVED_5[4];
N  __IO uint32_t FCFG1;                             /**< Flash Configuration Register 1, offset: 0x104C */
X  volatile uint32_t FCFG1;                              
N  __I  uint32_t FCFG2;                             /**< Flash Configuration Register 2, offset: 0x1050 */
X  volatile const  uint32_t FCFG2;                              
N       uint8_t RESERVED_6[4];
N  __I  uint32_t UIDMH;                             /**< Unique Identification Register Mid-High, offset: 0x1058 */
X  volatile const  uint32_t UIDMH;                              
N  __I  uint32_t UIDML;                             /**< Unique Identification Register Mid Low, offset: 0x105C */
X  volatile const  uint32_t UIDML;                              
N  __I  uint32_t UIDL;                              /**< Unique Identification Register Low, offset: 0x1060 */
X  volatile const  uint32_t UIDL;                               
N       uint8_t RESERVED_7[156];
N  __IO uint32_t COPC;                              /**< COP Control Register, offset: 0x1100 */
X  volatile uint32_t COPC;                               
N  __O  uint32_t SRVCOP;                            /**< Service COP Register, offset: 0x1104 */
X  volatile  uint32_t SRVCOP;                             
N} SIM_Type;
N
N/* ----------------------------------------------------------------------------
N   -- SIM Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup SIM_Register_Masks SIM Register Masks
N * @{
N */
N
N/* SOPT1 Bit Fields */
N#define SIM_SOPT1_OSC32KSEL_MASK                 0xC0000u
N#define SIM_SOPT1_OSC32KSEL_SHIFT                18
N#define SIM_SOPT1_OSC32KSEL(x)                   (((uint32_t)(((uint32_t)(x))<<SIM_SOPT1_OSC32KSEL_SHIFT))&SIM_SOPT1_OSC32KSEL_MASK)
N#define SIM_SOPT1_USBVSTBY_MASK                  0x20000000u
N#define SIM_SOPT1_USBVSTBY_SHIFT                 29
N#define SIM_SOPT1_USBSSTBY_MASK                  0x40000000u
N#define SIM_SOPT1_USBSSTBY_SHIFT                 30
N#define SIM_SOPT1_USBREGEN_MASK                  0x80000000u
N#define SIM_SOPT1_USBREGEN_SHIFT                 31
N/* SOPT1CFG Bit Fields */
N#define SIM_SOPT1CFG_URWE_MASK                   0x1000000u
N#define SIM_SOPT1CFG_URWE_SHIFT                  24
N#define SIM_SOPT1CFG_UVSWE_MASK                  0x2000000u
N#define SIM_SOPT1CFG_UVSWE_SHIFT                 25
N#define SIM_SOPT1CFG_USSWE_MASK                  0x4000000u
N#define SIM_SOPT1CFG_USSWE_SHIFT                 26
N/* SOPT2 Bit Fields */
N#define SIM_SOPT2_RTCCLKOUTSEL_MASK              0x10u
N#define SIM_SOPT2_RTCCLKOUTSEL_SHIFT             4
N#define SIM_SOPT2_CLKOUTSEL_MASK                 0xE0u
N#define SIM_SOPT2_CLKOUTSEL_SHIFT                5
N#define SIM_SOPT2_CLKOUTSEL(x)                   (((uint32_t)(((uint32_t)(x))<<SIM_SOPT2_CLKOUTSEL_SHIFT))&SIM_SOPT2_CLKOUTSEL_MASK)
N#define SIM_SOPT2_PLLFLLSEL_MASK                 0x10000u
N#define SIM_SOPT2_PLLFLLSEL_SHIFT                16
N#define SIM_SOPT2_USBSRC_MASK                    0x40000u
N#define SIM_SOPT2_USBSRC_SHIFT                   18
N#define SIM_SOPT2_TPMSRC_MASK                    0x3000000u
N#define SIM_SOPT2_TPMSRC_SHIFT                   24
N#define SIM_SOPT2_TPMSRC(x)                      (((uint32_t)(((uint32_t)(x))<<SIM_SOPT2_TPMSRC_SHIFT))&SIM_SOPT2_TPMSRC_MASK)
N#define SIM_SOPT2_UART0SRC_MASK                  0xC000000u
N#define SIM_SOPT2_UART0SRC_SHIFT                 26
N#define SIM_SOPT2_UART0SRC(x)                    (((uint32_t)(((uint32_t)(x))<<SIM_SOPT2_UART0SRC_SHIFT))&SIM_SOPT2_UART0SRC_MASK)
N/* SOPT4 Bit Fields */
N#define SIM_SOPT4_TPM1CH0SRC_MASK                0x40000u
N#define SIM_SOPT4_TPM1CH0SRC_SHIFT               18
N#define SIM_SOPT4_TPM2CH0SRC_MASK                0x100000u
N#define SIM_SOPT4_TPM2CH0SRC_SHIFT               20
N#define SIM_SOPT4_TPM0CLKSEL_MASK                0x1000000u
N#define SIM_SOPT4_TPM0CLKSEL_SHIFT               24
N#define SIM_SOPT4_TPM1CLKSEL_MASK                0x2000000u
N#define SIM_SOPT4_TPM1CLKSEL_SHIFT               25
N#define SIM_SOPT4_TPM2CLKSEL_MASK                0x4000000u
N#define SIM_SOPT4_TPM2CLKSEL_SHIFT               26
N/* SOPT5 Bit Fields */
N#define SIM_SOPT5_UART0TXSRC_MASK                0x3u
N#define SIM_SOPT5_UART0TXSRC_SHIFT               0
N#define SIM_SOPT5_UART0TXSRC(x)                  (((uint32_t)(((uint32_t)(x))<<SIM_SOPT5_UART0TXSRC_SHIFT))&SIM_SOPT5_UART0TXSRC_MASK)
N#define SIM_SOPT5_UART0RXSRC_MASK                0x4u
N#define SIM_SOPT5_UART0RXSRC_SHIFT               2
N#define SIM_SOPT5_UART1TXSRC_MASK                0x30u
N#define SIM_SOPT5_UART1TXSRC_SHIFT               4
N#define SIM_SOPT5_UART1TXSRC(x)                  (((uint32_t)(((uint32_t)(x))<<SIM_SOPT5_UART1TXSRC_SHIFT))&SIM_SOPT5_UART1TXSRC_MASK)
N#define SIM_SOPT5_UART1RXSRC_MASK                0x40u
N#define SIM_SOPT5_UART1RXSRC_SHIFT               6
N#define SIM_SOPT5_UART0ODE_MASK                  0x10000u
N#define SIM_SOPT5_UART0ODE_SHIFT                 16
N#define SIM_SOPT5_UART1ODE_MASK                  0x20000u
N#define SIM_SOPT5_UART1ODE_SHIFT                 17
N#define SIM_SOPT5_UART2ODE_MASK                  0x40000u
N#define SIM_SOPT5_UART2ODE_SHIFT                 18
N/* SOPT7 Bit Fields */
N#define SIM_SOPT7_ADC0TRGSEL_MASK                0xFu
N#define SIM_SOPT7_ADC0TRGSEL_SHIFT               0
N#define SIM_SOPT7_ADC0TRGSEL(x)                  (((uint32_t)(((uint32_t)(x))<<SIM_SOPT7_ADC0TRGSEL_SHIFT))&SIM_SOPT7_ADC0TRGSEL_MASK)
N#define SIM_SOPT7_ADC0PRETRGSEL_MASK             0x10u
N#define SIM_SOPT7_ADC0PRETRGSEL_SHIFT            4
N#define SIM_SOPT7_ADC0ALTTRGEN_MASK              0x80u
N#define SIM_SOPT7_ADC0ALTTRGEN_SHIFT             7
N/* SDID Bit Fields */
N#define SIM_SDID_PINID_MASK                      0xFu
N#define SIM_SDID_PINID_SHIFT                     0
N#define SIM_SDID_PINID(x)                        (((uint32_t)(((uint32_t)(x))<<SIM_SDID_PINID_SHIFT))&SIM_SDID_PINID_MASK)
N#define SIM_SDID_DIEID_MASK                      0xF80u
N#define SIM_SDID_DIEID_SHIFT                     7
N#define SIM_SDID_DIEID(x)                        (((uint32_t)(((uint32_t)(x))<<SIM_SDID_DIEID_SHIFT))&SIM_SDID_DIEID_MASK)
N#define SIM_SDID_REVID_MASK                      0xF000u
N#define SIM_SDID_REVID_SHIFT                     12
N#define SIM_SDID_REVID(x)                        (((uint32_t)(((uint32_t)(x))<<SIM_SDID_REVID_SHIFT))&SIM_SDID_REVID_MASK)
N#define SIM_SDID_SRAMSIZE_MASK                   0xF0000u
N#define SIM_SDID_SRAMSIZE_SHIFT                  16
N#define SIM_SDID_SRAMSIZE(x)                     (((uint32_t)(((uint32_t)(x))<<SIM_SDID_SRAMSIZE_SHIFT))&SIM_SDID_SRAMSIZE_MASK)
N#define SIM_SDID_SERIESID_MASK                   0xF00000u
N#define SIM_SDID_SERIESID_SHIFT                  20
N#define SIM_SDID_SERIESID(x)                     (((uint32_t)(((uint32_t)(x))<<SIM_SDID_SERIESID_SHIFT))&SIM_SDID_SERIESID_MASK)
N#define SIM_SDID_SUBFAMID_MASK                   0xF000000u
N#define SIM_SDID_SUBFAMID_SHIFT                  24
N#define SIM_SDID_SUBFAMID(x)                     (((uint32_t)(((uint32_t)(x))<<SIM_SDID_SUBFAMID_SHIFT))&SIM_SDID_SUBFAMID_MASK)
N#define SIM_SDID_FAMID_MASK                      0xF0000000u
N#define SIM_SDID_FAMID_SHIFT                     28
N#define SIM_SDID_FAMID(x)                        (((uint32_t)(((uint32_t)(x))<<SIM_SDID_FAMID_SHIFT))&SIM_SDID_FAMID_MASK)
N/* SCGC4 Bit Fields */
N#define SIM_SCGC4_I2C0_MASK                      0x40u
N#define SIM_SCGC4_I2C0_SHIFT                     6
N#define SIM_SCGC4_I2C1_MASK                      0x80u
N#define SIM_SCGC4_I2C1_SHIFT                     7
N#define SIM_SCGC4_UART0_MASK                     0x400u
N#define SIM_SCGC4_UART0_SHIFT                    10
N#define SIM_SCGC4_UART1_MASK                     0x800u
N#define SIM_SCGC4_UART1_SHIFT                    11
N#define SIM_SCGC4_UART2_MASK                     0x1000u
N#define SIM_SCGC4_UART2_SHIFT                    12
N#define SIM_SCGC4_USBOTG_MASK                    0x40000u
N#define SIM_SCGC4_USBOTG_SHIFT                   18
N#define SIM_SCGC4_CMP_MASK                       0x80000u
N#define SIM_SCGC4_CMP_SHIFT                      19
N#define SIM_SCGC4_SPI0_MASK                      0x400000u
N#define SIM_SCGC4_SPI0_SHIFT                     22
N#define SIM_SCGC4_SPI1_MASK                      0x800000u
N#define SIM_SCGC4_SPI1_SHIFT                     23
N/* SCGC5 Bit Fields */
N#define SIM_SCGC5_LPTMR_MASK                     0x1u
N#define SIM_SCGC5_LPTMR_SHIFT                    0
N#define SIM_SCGC5_TSI_MASK                       0x20u
N#define SIM_SCGC5_TSI_SHIFT                      5
N#define SIM_SCGC5_PORTA_MASK                     0x200u
N#define SIM_SCGC5_PORTA_SHIFT                    9
N#define SIM_SCGC5_PORTB_MASK                     0x400u
N#define SIM_SCGC5_PORTB_SHIFT                    10
N#define SIM_SCGC5_PORTC_MASK                     0x800u
N#define SIM_SCGC5_PORTC_SHIFT                    11
N#define SIM_SCGC5_PORTD_MASK                     0x1000u
N#define SIM_SCGC5_PORTD_SHIFT                    12
N#define SIM_SCGC5_PORTE_MASK                     0x2000u
N#define SIM_SCGC5_PORTE_SHIFT                    13
N/* SCGC6 Bit Fields */
N#define SIM_SCGC6_FTF_MASK                       0x1u
N#define SIM_SCGC6_FTF_SHIFT                      0
N#define SIM_SCGC6_DMAMUX_MASK                    0x2u
N#define SIM_SCGC6_DMAMUX_SHIFT                   1
N#define SIM_SCGC6_PIT_MASK                       0x800000u
N#define SIM_SCGC6_PIT_SHIFT                      23
N#define SIM_SCGC6_TPM0_MASK                      0x1000000u
N#define SIM_SCGC6_TPM0_SHIFT                     24
N#define SIM_SCGC6_TPM1_MASK                      0x2000000u
N#define SIM_SCGC6_TPM1_SHIFT                     25
N#define SIM_SCGC6_TPM2_MASK                      0x4000000u
N#define SIM_SCGC6_TPM2_SHIFT                     26
N#define SIM_SCGC6_ADC0_MASK                      0x8000000u
N#define SIM_SCGC6_ADC0_SHIFT                     27
N#define SIM_SCGC6_RTC_MASK                       0x20000000u
N#define SIM_SCGC6_RTC_SHIFT                      29
N#define SIM_SCGC6_DAC0_MASK                      0x80000000u
N#define SIM_SCGC6_DAC0_SHIFT                     31
N/* SCGC7 Bit Fields */
N#define SIM_SCGC7_DMA_MASK                       0x100u
N#define SIM_SCGC7_DMA_SHIFT                      8
N/* CLKDIV1 Bit Fields */
N#define SIM_CLKDIV1_OUTDIV4_MASK                 0x70000u
N#define SIM_CLKDIV1_OUTDIV4_SHIFT                16
N#define SIM_CLKDIV1_OUTDIV4(x)                   (((uint32_t)(((uint32_t)(x))<<SIM_CLKDIV1_OUTDIV4_SHIFT))&SIM_CLKDIV1_OUTDIV4_MASK)
N#define SIM_CLKDIV1_OUTDIV1_MASK                 0xF0000000u
N#define SIM_CLKDIV1_OUTDIV1_SHIFT                28
N#define SIM_CLKDIV1_OUTDIV1(x)                   (((uint32_t)(((uint32_t)(x))<<SIM_CLKDIV1_OUTDIV1_SHIFT))&SIM_CLKDIV1_OUTDIV1_MASK)
N/* FCFG1 Bit Fields */
N#define SIM_FCFG1_FLASHDIS_MASK                  0x1u
N#define SIM_FCFG1_FLASHDIS_SHIFT                 0
N#define SIM_FCFG1_FLASHDOZE_MASK                 0x2u
N#define SIM_FCFG1_FLASHDOZE_SHIFT                1
N#define SIM_FCFG1_PFSIZE_MASK                    0xF000000u
N#define SIM_FCFG1_PFSIZE_SHIFT                   24
N#define SIM_FCFG1_PFSIZE(x)                      (((uint32_t)(((uint32_t)(x))<<SIM_FCFG1_PFSIZE_SHIFT))&SIM_FCFG1_PFSIZE_MASK)
N/* FCFG2 Bit Fields */
N#define SIM_FCFG2_MAXADDR0_MASK                  0x7F000000u
N#define SIM_FCFG2_MAXADDR0_SHIFT                 24
N#define SIM_FCFG2_MAXADDR0(x)                    (((uint32_t)(((uint32_t)(x))<<SIM_FCFG2_MAXADDR0_SHIFT))&SIM_FCFG2_MAXADDR0_MASK)
N/* UIDMH Bit Fields */
N#define SIM_UIDMH_UID_MASK                       0xFFFFu
N#define SIM_UIDMH_UID_SHIFT                      0
N#define SIM_UIDMH_UID(x)                         (((uint32_t)(((uint32_t)(x))<<SIM_UIDMH_UID_SHIFT))&SIM_UIDMH_UID_MASK)
N/* UIDML Bit Fields */
N#define SIM_UIDML_UID_MASK                       0xFFFFFFFFu
N#define SIM_UIDML_UID_SHIFT                      0
N#define SIM_UIDML_UID(x)                         (((uint32_t)(((uint32_t)(x))<<SIM_UIDML_UID_SHIFT))&SIM_UIDML_UID_MASK)
N/* UIDL Bit Fields */
N#define SIM_UIDL_UID_MASK                        0xFFFFFFFFu
N#define SIM_UIDL_UID_SHIFT                       0
N#define SIM_UIDL_UID(x)                          (((uint32_t)(((uint32_t)(x))<<SIM_UIDL_UID_SHIFT))&SIM_UIDL_UID_MASK)
N/* COPC Bit Fields */
N#define SIM_COPC_COPW_MASK                       0x1u
N#define SIM_COPC_COPW_SHIFT                      0
N#define SIM_COPC_COPCLKS_MASK                    0x2u
N#define SIM_COPC_COPCLKS_SHIFT                   1
N#define SIM_COPC_COPT_MASK                       0xCu
N#define SIM_COPC_COPT_SHIFT                      2
N#define SIM_COPC_COPT(x)                         (((uint32_t)(((uint32_t)(x))<<SIM_COPC_COPT_SHIFT))&SIM_COPC_COPT_MASK)
N/* SRVCOP Bit Fields */
N#define SIM_SRVCOP_SRVCOP_MASK                   0xFFu
N#define SIM_SRVCOP_SRVCOP_SHIFT                  0
N#define SIM_SRVCOP_SRVCOP(x)                     (((uint32_t)(((uint32_t)(x))<<SIM_SRVCOP_SRVCOP_SHIFT))&SIM_SRVCOP_SRVCOP_MASK)
N
N/**
N * @}
N */ /* end of group SIM_Register_Masks */
N
N
N/* SIM - Peripheral instance base addresses */
N/** Peripheral SIM base address */
N#define SIM_BASE                                 (0x40047000u)
N/** Peripheral SIM base pointer */
N#define SIM                                      ((SIM_Type *)SIM_BASE)
N/** Array initializer of SIM peripheral base pointers */
N#define SIM_BASES                                { SIM }
N
N/**
N * @}
N */ /* end of group SIM_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- SMC Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup SMC_Peripheral_Access_Layer SMC Peripheral Access Layer
N * @{
N */
N
N/** SMC - Register Layout Typedef */
Ntypedef struct {
N  __IO uint8_t PMPROT;                             /**< Power Mode Protection register, offset: 0x0 */
X  volatile uint8_t PMPROT;                              
N  __IO uint8_t PMCTRL;                             /**< Power Mode Control register, offset: 0x1 */
X  volatile uint8_t PMCTRL;                              
N  __IO uint8_t STOPCTRL;                           /**< Stop Control Register, offset: 0x2 */
X  volatile uint8_t STOPCTRL;                            
N  __I  uint8_t PMSTAT;                             /**< Power Mode Status register, offset: 0x3 */
X  volatile const  uint8_t PMSTAT;                              
N} SMC_Type;
N
N/* ----------------------------------------------------------------------------
N   -- SMC Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup SMC_Register_Masks SMC Register Masks
N * @{
N */
N
N/* PMPROT Bit Fields */
N#define SMC_PMPROT_AVLLS_MASK                    0x2u
N#define SMC_PMPROT_AVLLS_SHIFT                   1
N#define SMC_PMPROT_ALLS_MASK                     0x8u
N#define SMC_PMPROT_ALLS_SHIFT                    3
N#define SMC_PMPROT_AVLP_MASK                     0x20u
N#define SMC_PMPROT_AVLP_SHIFT                    5
N/* PMCTRL Bit Fields */
N#define SMC_PMCTRL_STOPM_MASK                    0x7u
N#define SMC_PMCTRL_STOPM_SHIFT                   0
N#define SMC_PMCTRL_STOPM(x)                      (((uint8_t)(((uint8_t)(x))<<SMC_PMCTRL_STOPM_SHIFT))&SMC_PMCTRL_STOPM_MASK)
N#define SMC_PMCTRL_STOPA_MASK                    0x8u
N#define SMC_PMCTRL_STOPA_SHIFT                   3
N#define SMC_PMCTRL_RUNM_MASK                     0x60u
N#define SMC_PMCTRL_RUNM_SHIFT                    5
N#define SMC_PMCTRL_RUNM(x)                       (((uint8_t)(((uint8_t)(x))<<SMC_PMCTRL_RUNM_SHIFT))&SMC_PMCTRL_RUNM_MASK)
N/* STOPCTRL Bit Fields */
N#define SMC_STOPCTRL_VLLSM_MASK                  0x7u
N#define SMC_STOPCTRL_VLLSM_SHIFT                 0
N#define SMC_STOPCTRL_VLLSM(x)                    (((uint8_t)(((uint8_t)(x))<<SMC_STOPCTRL_VLLSM_SHIFT))&SMC_STOPCTRL_VLLSM_MASK)
N#define SMC_STOPCTRL_PORPO_MASK                  0x20u
N#define SMC_STOPCTRL_PORPO_SHIFT                 5
N#define SMC_STOPCTRL_PSTOPO_MASK                 0xC0u
N#define SMC_STOPCTRL_PSTOPO_SHIFT                6
N#define SMC_STOPCTRL_PSTOPO(x)                   (((uint8_t)(((uint8_t)(x))<<SMC_STOPCTRL_PSTOPO_SHIFT))&SMC_STOPCTRL_PSTOPO_MASK)
N/* PMSTAT Bit Fields */
N#define SMC_PMSTAT_PMSTAT_MASK                   0x7Fu
N#define SMC_PMSTAT_PMSTAT_SHIFT                  0
N#define SMC_PMSTAT_PMSTAT(x)                     (((uint8_t)(((uint8_t)(x))<<SMC_PMSTAT_PMSTAT_SHIFT))&SMC_PMSTAT_PMSTAT_MASK)
N
N/**
N * @}
N */ /* end of group SMC_Register_Masks */
N
N
N/* SMC - Peripheral instance base addresses */
N/** Peripheral SMC base address */
N#define SMC_BASE                                 (0x4007E000u)
N/** Peripheral SMC base pointer */
N#define SMC                                      ((SMC_Type *)SMC_BASE)
N/** Array initializer of SMC peripheral base pointers */
N#define SMC_BASES                                { SMC }
N
N/**
N * @}
N */ /* end of group SMC_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- SPI Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup SPI_Peripheral_Access_Layer SPI Peripheral Access Layer
N * @{
N */
N
N/** SPI - Register Layout Typedef */
Ntypedef struct {
N  __IO uint8_t C1;                                 /**< SPI control register 1, offset: 0x0 */
X  volatile uint8_t C1;                                  
N  __IO uint8_t C2;                                 /**< SPI control register 2, offset: 0x1 */
X  volatile uint8_t C2;                                  
N  __IO uint8_t BR;                                 /**< SPI baud rate register, offset: 0x2 */
X  volatile uint8_t BR;                                  
N  __I  uint8_t S;                                  /**< SPI status register, offset: 0x3 */
X  volatile const  uint8_t S;                                   
N       uint8_t RESERVED_0[1];
N  __IO uint8_t D;                                  /**< SPI data register, offset: 0x5 */
X  volatile uint8_t D;                                   
N       uint8_t RESERVED_1[1];
N  __IO uint8_t M;                                  /**< SPI match register, offset: 0x7 */
X  volatile uint8_t M;                                   
N} SPI_Type;
N
N/* ----------------------------------------------------------------------------
N   -- SPI Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup SPI_Register_Masks SPI Register Masks
N * @{
N */
N
N/* C1 Bit Fields */
N#define SPI_C1_LSBFE_MASK                        0x1u
N#define SPI_C1_LSBFE_SHIFT                       0
N#define SPI_C1_SSOE_MASK                         0x2u
N#define SPI_C1_SSOE_SHIFT                        1
N#define SPI_C1_CPHA_MASK                         0x4u
N#define SPI_C1_CPHA_SHIFT                        2
N#define SPI_C1_CPOL_MASK                         0x8u
N#define SPI_C1_CPOL_SHIFT                        3
N#define SPI_C1_MSTR_MASK                         0x10u
N#define SPI_C1_MSTR_SHIFT                        4
N#define SPI_C1_SPTIE_MASK                        0x20u
N#define SPI_C1_SPTIE_SHIFT                       5
N#define SPI_C1_SPE_MASK                          0x40u
N#define SPI_C1_SPE_SHIFT                         6
N#define SPI_C1_SPIE_MASK                         0x80u
N#define SPI_C1_SPIE_SHIFT                        7
N/* C2 Bit Fields */
N#define SPI_C2_SPC0_MASK                         0x1u
N#define SPI_C2_SPC0_SHIFT                        0
N#define SPI_C2_SPISWAI_MASK                      0x2u
N#define SPI_C2_SPISWAI_SHIFT                     1
N#define SPI_C2_RXDMAE_MASK                       0x4u
N#define SPI_C2_RXDMAE_SHIFT                      2
N#define SPI_C2_BIDIROE_MASK                      0x8u
N#define SPI_C2_BIDIROE_SHIFT                     3
N#define SPI_C2_MODFEN_MASK                       0x10u
N#define SPI_C2_MODFEN_SHIFT                      4
N#define SPI_C2_TXDMAE_MASK                       0x20u
N#define SPI_C2_TXDMAE_SHIFT                      5
N#define SPI_C2_SPMIE_MASK                        0x80u
N#define SPI_C2_SPMIE_SHIFT                       7
N/* BR Bit Fields */
N#define SPI_BR_SPR_MASK                          0xFu
N#define SPI_BR_SPR_SHIFT                         0
N#define SPI_BR_SPR(x)                            (((uint8_t)(((uint8_t)(x))<<SPI_BR_SPR_SHIFT))&SPI_BR_SPR_MASK)
N#define SPI_BR_SPPR_MASK                         0x70u
N#define SPI_BR_SPPR_SHIFT                        4
N#define SPI_BR_SPPR(x)                           (((uint8_t)(((uint8_t)(x))<<SPI_BR_SPPR_SHIFT))&SPI_BR_SPPR_MASK)
N/* S Bit Fields */
N#define SPI_S_MODF_MASK                          0x10u
N#define SPI_S_MODF_SHIFT                         4
N#define SPI_S_SPTEF_MASK                         0x20u
N#define SPI_S_SPTEF_SHIFT                        5
N#define SPI_S_SPMF_MASK                          0x40u
N#define SPI_S_SPMF_SHIFT                         6
N#define SPI_S_SPRF_MASK                          0x80u
N#define SPI_S_SPRF_SHIFT                         7
N/* D Bit Fields */
N#define SPI_D_Bits_MASK                          0xFFu
N#define SPI_D_Bits_SHIFT                         0
N#define SPI_D_Bits(x)                            (((uint8_t)(((uint8_t)(x))<<SPI_D_Bits_SHIFT))&SPI_D_Bits_MASK)
N/* M Bit Fields */
N#define SPI_M_Bits_MASK                          0xFFu
N#define SPI_M_Bits_SHIFT                         0
N#define SPI_M_Bits(x)                            (((uint8_t)(((uint8_t)(x))<<SPI_M_Bits_SHIFT))&SPI_M_Bits_MASK)
N
N/**
N * @}
N */ /* end of group SPI_Register_Masks */
N
N
N/* SPI - Peripheral instance base addresses */
N/** Peripheral SPI0 base address */
N#define SPI0_BASE                                (0x40076000u)
N/** Peripheral SPI0 base pointer */
N#define SPI0                                     ((SPI_Type *)SPI0_BASE)
N/** Peripheral SPI1 base address */
N#define SPI1_BASE                                (0x40077000u)
N/** Peripheral SPI1 base pointer */
N#define SPI1                                     ((SPI_Type *)SPI1_BASE)
N/** Array initializer of SPI peripheral base pointers */
N#define SPI_BASES                                { SPI0, SPI1 }
N
N/**
N * @}
N */ /* end of group SPI_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- TPM Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup TPM_Peripheral_Access_Layer TPM Peripheral Access Layer
N * @{
N */
N
N/** TPM - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t SC;                                /**< Status and Control, offset: 0x0 */
X  volatile uint32_t SC;                                 
N  __IO uint32_t CNT;                               /**< Counter, offset: 0x4 */
X  volatile uint32_t CNT;                                
N  __IO uint32_t MOD;                               /**< Modulo, offset: 0x8 */
X  volatile uint32_t MOD;                                
N  struct {                                         /* offset: 0xC, array step: 0x8 */
N    __IO uint32_t CnSC;                              /**< Channel (n) Status and Control, array offset: 0xC, array step: 0x8 */
X    volatile uint32_t CnSC;                               
N    __IO uint32_t CnV;                               /**< Channel (n) Value, array offset: 0x10, array step: 0x8 */
X    volatile uint32_t CnV;                                
N  } CONTROLS[6];
N       uint8_t RESERVED_0[20];
N  __IO uint32_t STATUS;                            /**< Capture and Compare Status, offset: 0x50 */
X  volatile uint32_t STATUS;                             
N       uint8_t RESERVED_1[48];
N  __IO uint32_t CONF;                              /**< Configuration, offset: 0x84 */
X  volatile uint32_t CONF;                               
N} TPM_Type;
N
N/* ----------------------------------------------------------------------------
N   -- TPM Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup TPM_Register_Masks TPM Register Masks
N * @{
N */
N
N/* SC Bit Fields */
N#define TPM_SC_PS_MASK                           0x7u
N#define TPM_SC_PS_SHIFT                          0
N#define TPM_SC_PS(x)                             (((uint32_t)(((uint32_t)(x))<<TPM_SC_PS_SHIFT))&TPM_SC_PS_MASK)
N#define TPM_SC_CMOD_MASK                         0x18u
N#define TPM_SC_CMOD_SHIFT                        3
N#define TPM_SC_CMOD(x)                           (((uint32_t)(((uint32_t)(x))<<TPM_SC_CMOD_SHIFT))&TPM_SC_CMOD_MASK)
N#define TPM_SC_CPWMS_MASK                        0x20u
N#define TPM_SC_CPWMS_SHIFT                       5
N#define TPM_SC_TOIE_MASK                         0x40u
N#define TPM_SC_TOIE_SHIFT                        6
N#define TPM_SC_TOF_MASK                          0x80u
N#define TPM_SC_TOF_SHIFT                         7
N#define TPM_SC_DMA_MASK                          0x100u
N#define TPM_SC_DMA_SHIFT                         8
N/* CNT Bit Fields */
N#define TPM_CNT_COUNT_MASK                       0xFFFFu
N#define TPM_CNT_COUNT_SHIFT                      0
N#define TPM_CNT_COUNT(x)                         (((uint32_t)(((uint32_t)(x))<<TPM_CNT_COUNT_SHIFT))&TPM_CNT_COUNT_MASK)
N/* MOD Bit Fields */
N#define TPM_MOD_MOD_MASK                         0xFFFFu
N#define TPM_MOD_MOD_SHIFT                        0
N#define TPM_MOD_MOD(x)                           (((uint32_t)(((uint32_t)(x))<<TPM_MOD_MOD_SHIFT))&TPM_MOD_MOD_MASK)
N/* CnSC Bit Fields */
N#define TPM_CnSC_DMA_MASK                        0x1u
N#define TPM_CnSC_DMA_SHIFT                       0
N#define TPM_CnSC_ELSA_MASK                       0x4u
N#define TPM_CnSC_ELSA_SHIFT                      2
N#define TPM_CnSC_ELSB_MASK                       0x8u
N#define TPM_CnSC_ELSB_SHIFT                      3
N#define TPM_CnSC_MSA_MASK                        0x10u
N#define TPM_CnSC_MSA_SHIFT                       4
N#define TPM_CnSC_MSB_MASK                        0x20u
N#define TPM_CnSC_MSB_SHIFT                       5
N#define TPM_CnSC_CHIE_MASK                       0x40u
N#define TPM_CnSC_CHIE_SHIFT                      6
N#define TPM_CnSC_CHF_MASK                        0x80u
N#define TPM_CnSC_CHF_SHIFT                       7
N/* CnV Bit Fields */
N#define TPM_CnV_VAL_MASK                         0xFFFFu
N#define TPM_CnV_VAL_SHIFT                        0
N#define TPM_CnV_VAL(x)                           (((uint32_t)(((uint32_t)(x))<<TPM_CnV_VAL_SHIFT))&TPM_CnV_VAL_MASK)
N/* STATUS Bit Fields */
N#define TPM_STATUS_CH0F_MASK                     0x1u
N#define TPM_STATUS_CH0F_SHIFT                    0
N#define TPM_STATUS_CH1F_MASK                     0x2u
N#define TPM_STATUS_CH1F_SHIFT                    1
N#define TPM_STATUS_CH2F_MASK                     0x4u
N#define TPM_STATUS_CH2F_SHIFT                    2
N#define TPM_STATUS_CH3F_MASK                     0x8u
N#define TPM_STATUS_CH3F_SHIFT                    3
N#define TPM_STATUS_CH4F_MASK                     0x10u
N#define TPM_STATUS_CH4F_SHIFT                    4
N#define TPM_STATUS_CH5F_MASK                     0x20u
N#define TPM_STATUS_CH5F_SHIFT                    5
N#define TPM_STATUS_TOF_MASK                      0x100u
N#define TPM_STATUS_TOF_SHIFT                     8
N/* CONF Bit Fields */
N#define TPM_CONF_DOZEEN_MASK                     0x20u
N#define TPM_CONF_DOZEEN_SHIFT                    5
N#define TPM_CONF_DBGMODE_MASK                    0xC0u
N#define TPM_CONF_DBGMODE_SHIFT                   6
N#define TPM_CONF_DBGMODE(x)                      (((uint32_t)(((uint32_t)(x))<<TPM_CONF_DBGMODE_SHIFT))&TPM_CONF_DBGMODE_MASK)
N#define TPM_CONF_GTBEEN_MASK                     0x200u
N#define TPM_CONF_GTBEEN_SHIFT                    9
N#define TPM_CONF_CSOT_MASK                       0x10000u
N#define TPM_CONF_CSOT_SHIFT                      16
N#define TPM_CONF_CSOO_MASK                       0x20000u
N#define TPM_CONF_CSOO_SHIFT                      17
N#define TPM_CONF_CROT_MASK                       0x40000u
N#define TPM_CONF_CROT_SHIFT                      18
N#define TPM_CONF_TRGSEL_MASK                     0xF000000u
N#define TPM_CONF_TRGSEL_SHIFT                    24
N#define TPM_CONF_TRGSEL(x)                       (((uint32_t)(((uint32_t)(x))<<TPM_CONF_TRGSEL_SHIFT))&TPM_CONF_TRGSEL_MASK)
N
N/**
N * @}
N */ /* end of group TPM_Register_Masks */
N
N
N/* TPM - Peripheral instance base addresses */
N/** Peripheral TPM0 base address */
N#define TPM0_BASE                                (0x40038000u)
N/** Peripheral TPM0 base pointer */
N#define TPM0                                     ((TPM_Type *)TPM0_BASE)
N/** Peripheral TPM1 base address */
N#define TPM1_BASE                                (0x40039000u)
N/** Peripheral TPM1 base pointer */
N#define TPM1                                     ((TPM_Type *)TPM1_BASE)
N/** Peripheral TPM2 base address */
N#define TPM2_BASE                                (0x4003A000u)
N/** Peripheral TPM2 base pointer */
N#define TPM2                                     ((TPM_Type *)TPM2_BASE)
N/** Array initializer of TPM peripheral base pointers */
N#define TPM_BASES                                { TPM0, TPM1, TPM2 }
N
N/**
N * @}
N */ /* end of group TPM_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- TSI Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup TSI_Peripheral_Access_Layer TSI Peripheral Access Layer
N * @{
N */
N
N/** TSI - Register Layout Typedef */
Ntypedef struct {
N  __IO uint32_t GENCS;                             /**< TSI General Control and Status Register, offset: 0x0 */
X  volatile uint32_t GENCS;                              
N  __IO uint32_t DATA;                              /**< TSI DATA Register, offset: 0x4 */
X  volatile uint32_t DATA;                               
N  __IO uint32_t TSHD;                              /**< TSI Threshold Register, offset: 0x8 */
X  volatile uint32_t TSHD;                               
N} TSI_Type;
N
N/* ----------------------------------------------------------------------------
N   -- TSI Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup TSI_Register_Masks TSI Register Masks
N * @{
N */
N
N/* GENCS Bit Fields */
N#define TSI_GENCS_CURSW_MASK                     0x2u
N#define TSI_GENCS_CURSW_SHIFT                    1
N#define TSI_GENCS_EOSF_MASK                      0x4u
N#define TSI_GENCS_EOSF_SHIFT                     2
N#define TSI_GENCS_SCNIP_MASK                     0x8u
N#define TSI_GENCS_SCNIP_SHIFT                    3
N#define TSI_GENCS_STM_MASK                       0x10u
N#define TSI_GENCS_STM_SHIFT                      4
N#define TSI_GENCS_STPE_MASK                      0x20u
N#define TSI_GENCS_STPE_SHIFT                     5
N#define TSI_GENCS_TSIIEN_MASK                    0x40u
N#define TSI_GENCS_TSIIEN_SHIFT                   6
N#define TSI_GENCS_TSIEN_MASK                     0x80u
N#define TSI_GENCS_TSIEN_SHIFT                    7
N#define TSI_GENCS_NSCN_MASK                      0x1F00u
N#define TSI_GENCS_NSCN_SHIFT                     8
N#define TSI_GENCS_NSCN(x)                        (((uint32_t)(((uint32_t)(x))<<TSI_GENCS_NSCN_SHIFT))&TSI_GENCS_NSCN_MASK)
N#define TSI_GENCS_PS_MASK                        0xE000u
N#define TSI_GENCS_PS_SHIFT                       13
N#define TSI_GENCS_PS(x)                          (((uint32_t)(((uint32_t)(x))<<TSI_GENCS_PS_SHIFT))&TSI_GENCS_PS_MASK)
N#define TSI_GENCS_EXTCHRG_MASK                   0x70000u
N#define TSI_GENCS_EXTCHRG_SHIFT                  16
N#define TSI_GENCS_EXTCHRG(x)                     (((uint32_t)(((uint32_t)(x))<<TSI_GENCS_EXTCHRG_SHIFT))&TSI_GENCS_EXTCHRG_MASK)
N#define TSI_GENCS_DVOLT_MASK                     0x180000u
N#define TSI_GENCS_DVOLT_SHIFT                    19
N#define TSI_GENCS_DVOLT(x)                       (((uint32_t)(((uint32_t)(x))<<TSI_GENCS_DVOLT_SHIFT))&TSI_GENCS_DVOLT_MASK)
N#define TSI_GENCS_REFCHRG_MASK                   0xE00000u
N#define TSI_GENCS_REFCHRG_SHIFT                  21
N#define TSI_GENCS_REFCHRG(x)                     (((uint32_t)(((uint32_t)(x))<<TSI_GENCS_REFCHRG_SHIFT))&TSI_GENCS_REFCHRG_MASK)
N#define TSI_GENCS_MODE_MASK                      0xF000000u
N#define TSI_GENCS_MODE_SHIFT                     24
N#define TSI_GENCS_MODE(x)                        (((uint32_t)(((uint32_t)(x))<<TSI_GENCS_MODE_SHIFT))&TSI_GENCS_MODE_MASK)
N#define TSI_GENCS_ESOR_MASK                      0x10000000u
N#define TSI_GENCS_ESOR_SHIFT                     28
N#define TSI_GENCS_OUTRGF_MASK                    0x80000000u
N#define TSI_GENCS_OUTRGF_SHIFT                   31
N/* DATA Bit Fields */
N#define TSI_DATA_TSICNT_MASK                     0xFFFFu
N#define TSI_DATA_TSICNT_SHIFT                    0
N#define TSI_DATA_TSICNT(x)                       (((uint32_t)(((uint32_t)(x))<<TSI_DATA_TSICNT_SHIFT))&TSI_DATA_TSICNT_MASK)
N#define TSI_DATA_SWTS_MASK                       0x400000u
N#define TSI_DATA_SWTS_SHIFT                      22
N#define TSI_DATA_DMAEN_MASK                      0x800000u
N#define TSI_DATA_DMAEN_SHIFT                     23
N#define TSI_DATA_TSICH_MASK                      0xF0000000u
N#define TSI_DATA_TSICH_SHIFT                     28
N#define TSI_DATA_TSICH(x)                        (((uint32_t)(((uint32_t)(x))<<TSI_DATA_TSICH_SHIFT))&TSI_DATA_TSICH_MASK)
N/* TSHD Bit Fields */
N#define TSI_TSHD_THRESL_MASK                     0xFFFFu
N#define TSI_TSHD_THRESL_SHIFT                    0
N#define TSI_TSHD_THRESL(x)                       (((uint32_t)(((uint32_t)(x))<<TSI_TSHD_THRESL_SHIFT))&TSI_TSHD_THRESL_MASK)
N#define TSI_TSHD_THRESH_MASK                     0xFFFF0000u
N#define TSI_TSHD_THRESH_SHIFT                    16
N#define TSI_TSHD_THRESH(x)                       (((uint32_t)(((uint32_t)(x))<<TSI_TSHD_THRESH_SHIFT))&TSI_TSHD_THRESH_MASK)
N
N/**
N * @}
N */ /* end of group TSI_Register_Masks */
N
N
N/* TSI - Peripheral instance base addresses */
N/** Peripheral TSI0 base address */
N#define TSI0_BASE                                (0x40045000u)
N/** Peripheral TSI0 base pointer */
N#define TSI0                                     ((TSI_Type *)TSI0_BASE)
N/** Array initializer of TSI peripheral base pointers */
N#define TSI_BASES                                { TSI0 }
N
N/**
N * @}
N */ /* end of group TSI_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- UART Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup UART_Peripheral_Access_Layer UART Peripheral Access Layer
N * @{
N */
N
N/** UART - Register Layout Typedef */
Ntypedef struct {
N  __IO uint8_t BDH;                                /**< UART Baud Rate Register: High, offset: 0x0 */
X  volatile uint8_t BDH;                                 
N  __IO uint8_t BDL;                                /**< UART Baud Rate Register: Low, offset: 0x1 */
X  volatile uint8_t BDL;                                 
N  __IO uint8_t C1;                                 /**< UART Control Register 1, offset: 0x2 */
X  volatile uint8_t C1;                                  
N  __IO uint8_t C2;                                 /**< UART Control Register 2, offset: 0x3 */
X  volatile uint8_t C2;                                  
N  __I  uint8_t S1;                                 /**< UART Status Register 1, offset: 0x4 */
X  volatile const  uint8_t S1;                                  
N  __IO uint8_t S2;                                 /**< UART Status Register 2, offset: 0x5 */
X  volatile uint8_t S2;                                  
N  __IO uint8_t C3;                                 /**< UART Control Register 3, offset: 0x6 */
X  volatile uint8_t C3;                                  
N  __IO uint8_t D;                                  /**< UART Data Register, offset: 0x7 */
X  volatile uint8_t D;                                   
N  __IO uint8_t C4;                                 /**< UART Control Register 4, offset: 0x8 */
X  volatile uint8_t C4;                                  
N} UART_Type;
N
N/* ----------------------------------------------------------------------------
N   -- UART Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup UART_Register_Masks UART Register Masks
N * @{
N */
N
N/* BDH Bit Fields */
N#define UART_BDH_SBR_MASK                        0x1Fu
N#define UART_BDH_SBR_SHIFT                       0
N#define UART_BDH_SBR(x)                          (((uint8_t)(((uint8_t)(x))<<UART_BDH_SBR_SHIFT))&UART_BDH_SBR_MASK)
N#define UART_BDH_SBNS_MASK                       0x20u
N#define UART_BDH_SBNS_SHIFT                      5
N#define UART_BDH_RXEDGIE_MASK                    0x40u
N#define UART_BDH_RXEDGIE_SHIFT                   6
N#define UART_BDH_LBKDIE_MASK                     0x80u
N#define UART_BDH_LBKDIE_SHIFT                    7
N/* BDL Bit Fields */
N#define UART_BDL_SBR_MASK                        0xFFu
N#define UART_BDL_SBR_SHIFT                       0
N#define UART_BDL_SBR(x)                          (((uint8_t)(((uint8_t)(x))<<UART_BDL_SBR_SHIFT))&UART_BDL_SBR_MASK)
N/* C1 Bit Fields */
N#define UART_C1_PT_MASK                          0x1u
N#define UART_C1_PT_SHIFT                         0
N#define UART_C1_PE_MASK                          0x2u
N#define UART_C1_PE_SHIFT                         1
N#define UART_C1_ILT_MASK                         0x4u
N#define UART_C1_ILT_SHIFT                        2
N#define UART_C1_WAKE_MASK                        0x8u
N#define UART_C1_WAKE_SHIFT                       3
N#define UART_C1_M_MASK                           0x10u
N#define UART_C1_M_SHIFT                          4
N#define UART_C1_RSRC_MASK                        0x20u
N#define UART_C1_RSRC_SHIFT                       5
N#define UART_C1_UARTSWAI_MASK                    0x40u
N#define UART_C1_UARTSWAI_SHIFT                   6
N#define UART_C1_LOOPS_MASK                       0x80u
N#define UART_C1_LOOPS_SHIFT                      7
N/* C2 Bit Fields */
N#define UART_C2_SBK_MASK                         0x1u
N#define UART_C2_SBK_SHIFT                        0
N#define UART_C2_RWU_MASK                         0x2u
N#define UART_C2_RWU_SHIFT                        1
N#define UART_C2_RE_MASK                          0x4u
N#define UART_C2_RE_SHIFT                         2
N#define UART_C2_TE_MASK                          0x8u
N#define UART_C2_TE_SHIFT                         3
N#define UART_C2_ILIE_MASK                        0x10u
N#define UART_C2_ILIE_SHIFT                       4
N#define UART_C2_RIE_MASK                         0x20u
N#define UART_C2_RIE_SHIFT                        5
N#define UART_C2_TCIE_MASK                        0x40u
N#define UART_C2_TCIE_SHIFT                       6
N#define UART_C2_TIE_MASK                         0x80u
N#define UART_C2_TIE_SHIFT                        7
N/* S1 Bit Fields */
N#define UART_S1_PF_MASK                          0x1u
N#define UART_S1_PF_SHIFT                         0
N#define UART_S1_FE_MASK                          0x2u
N#define UART_S1_FE_SHIFT                         1
N#define UART_S1_NF_MASK                          0x4u
N#define UART_S1_NF_SHIFT                         2
N#define UART_S1_OR_MASK                          0x8u
N#define UART_S1_OR_SHIFT                         3
N#define UART_S1_IDLE_MASK                        0x10u
N#define UART_S1_IDLE_SHIFT                       4
N#define UART_S1_RDRF_MASK                        0x20u
N#define UART_S1_RDRF_SHIFT                       5
N#define UART_S1_TC_MASK                          0x40u
N#define UART_S1_TC_SHIFT                         6
N#define UART_S1_TDRE_MASK                        0x80u
N#define UART_S1_TDRE_SHIFT                       7
N/* S2 Bit Fields */
N#define UART_S2_RAF_MASK                         0x1u
N#define UART_S2_RAF_SHIFT                        0
N#define UART_S2_LBKDE_MASK                       0x2u
N#define UART_S2_LBKDE_SHIFT                      1
N#define UART_S2_BRK13_MASK                       0x4u
N#define UART_S2_BRK13_SHIFT                      2
N#define UART_S2_RWUID_MASK                       0x8u
N#define UART_S2_RWUID_SHIFT                      3
N#define UART_S2_RXINV_MASK                       0x10u
N#define UART_S2_RXINV_SHIFT                      4
N#define UART_S2_RXEDGIF_MASK                     0x40u
N#define UART_S2_RXEDGIF_SHIFT                    6
N#define UART_S2_LBKDIF_MASK                      0x80u
N#define UART_S2_LBKDIF_SHIFT                     7
N/* C3 Bit Fields */
N#define UART_C3_PEIE_MASK                        0x1u
N#define UART_C3_PEIE_SHIFT                       0
N#define UART_C3_FEIE_MASK                        0x2u
N#define UART_C3_FEIE_SHIFT                       1
N#define UART_C3_NEIE_MASK                        0x4u
N#define UART_C3_NEIE_SHIFT                       2
N#define UART_C3_ORIE_MASK                        0x8u
N#define UART_C3_ORIE_SHIFT                       3
N#define UART_C3_TXINV_MASK                       0x10u
N#define UART_C3_TXINV_SHIFT                      4
N#define UART_C3_TXDIR_MASK                       0x20u
N#define UART_C3_TXDIR_SHIFT                      5
N#define UART_C3_T8_MASK                          0x40u
N#define UART_C3_T8_SHIFT                         6
N#define UART_C3_R8_MASK                          0x80u
N#define UART_C3_R8_SHIFT                         7
N/* D Bit Fields */
N#define UART_D_R0T0_MASK                         0x1u
N#define UART_D_R0T0_SHIFT                        0
N#define UART_D_R1T1_MASK                         0x2u
N#define UART_D_R1T1_SHIFT                        1
N#define UART_D_R2T2_MASK                         0x4u
N#define UART_D_R2T2_SHIFT                        2
N#define UART_D_R3T3_MASK                         0x8u
N#define UART_D_R3T3_SHIFT                        3
N#define UART_D_R4T4_MASK                         0x10u
N#define UART_D_R4T4_SHIFT                        4
N#define UART_D_R5T5_MASK                         0x20u
N#define UART_D_R5T5_SHIFT                        5
N#define UART_D_R6T6_MASK                         0x40u
N#define UART_D_R6T6_SHIFT                        6
N#define UART_D_R7T7_MASK                         0x80u
N#define UART_D_R7T7_SHIFT                        7
N/* C4 Bit Fields */
N#define UART_C4_RDMAS_MASK                       0x20u
N#define UART_C4_RDMAS_SHIFT                      5
N#define UART_C4_TDMAS_MASK                       0x80u
N#define UART_C4_TDMAS_SHIFT                      7
N
N/**
N * @}
N */ /* end of group UART_Register_Masks */
N
N
N/* UART - Peripheral instance base addresses */
N/** Peripheral UART1 base address */
N#define UART1_BASE                               (0x4006B000u)
N/** Peripheral UART1 base pointer */
N#define UART1                                    ((UART_Type *)UART1_BASE)
N/** Peripheral UART2 base address */
N#define UART2_BASE                               (0x4006C000u)
N/** Peripheral UART2 base pointer */
N#define UART2                                    ((UART_Type *)UART2_BASE)
N/** Array initializer of UART peripheral base pointers */
N#define UART_BASES                               { UART1, UART2 }
N
N/**
N * @}
N */ /* end of group UART_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- UART0 Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup UART0_Peripheral_Access_Layer UART0 Peripheral Access Layer
N * @{
N */
N
N/** UART0 - Register Layout Typedef */
Ntypedef struct {
N  __IO uint8_t BDH;                                /**< UART Baud Rate Register High, offset: 0x0 */
X  volatile uint8_t BDH;                                 
N  __IO uint8_t BDL;                                /**< UART Baud Rate Register Low, offset: 0x1 */
X  volatile uint8_t BDL;                                 
N  __IO uint8_t C1;                                 /**< UART Control Register 1, offset: 0x2 */
X  volatile uint8_t C1;                                  
N  __IO uint8_t C2;                                 /**< UART Control Register 2, offset: 0x3 */
X  volatile uint8_t C2;                                  
N  __IO uint8_t S1;                                 /**< UART Status Register 1, offset: 0x4 */
X  volatile uint8_t S1;                                  
N  __IO uint8_t S2;                                 /**< UART Status Register 2, offset: 0x5 */
X  volatile uint8_t S2;                                  
N  __IO uint8_t C3;                                 /**< UART Control Register 3, offset: 0x6 */
X  volatile uint8_t C3;                                  
N  __IO uint8_t D;                                  /**< UART Data Register, offset: 0x7 */
X  volatile uint8_t D;                                   
N  __IO uint8_t MA1;                                /**< UART Match Address Registers 1, offset: 0x8 */
X  volatile uint8_t MA1;                                 
N  __IO uint8_t MA2;                                /**< UART Match Address Registers 2, offset: 0x9 */
X  volatile uint8_t MA2;                                 
N  __IO uint8_t C4;                                 /**< UART Control Register 4, offset: 0xA */
X  volatile uint8_t C4;                                  
N  __IO uint8_t C5;                                 /**< UART Control Register 5, offset: 0xB */
X  volatile uint8_t C5;                                  
N} UART0_Type;
N
N/* ----------------------------------------------------------------------------
N   -- UART0 Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup UART0_Register_Masks UART0 Register Masks
N * @{
N */
N
N/* BDH Bit Fields */
N#define UART0_BDH_SBR_MASK                       0x1Fu
N#define UART0_BDH_SBR_SHIFT                      0
N#define UART0_BDH_SBR(x)                         (((uint8_t)(((uint8_t)(x))<<UART0_BDH_SBR_SHIFT))&UART0_BDH_SBR_MASK)
N#define UART0_BDH_SBNS_MASK                      0x20u
N#define UART0_BDH_SBNS_SHIFT                     5
N#define UART0_BDH_RXEDGIE_MASK                   0x40u
N#define UART0_BDH_RXEDGIE_SHIFT                  6
N#define UART0_BDH_LBKDIE_MASK                    0x80u
N#define UART0_BDH_LBKDIE_SHIFT                   7
N/* BDL Bit Fields */
N#define UART0_BDL_SBR_MASK                       0xFFu
N#define UART0_BDL_SBR_SHIFT                      0
N#define UART0_BDL_SBR(x)                         (((uint8_t)(((uint8_t)(x))<<UART0_BDL_SBR_SHIFT))&UART0_BDL_SBR_MASK)
N/* C1 Bit Fields */
N#define UART0_C1_PT_MASK                         0x1u
N#define UART0_C1_PT_SHIFT                        0
N#define UART0_C1_PE_MASK                         0x2u
N#define UART0_C1_PE_SHIFT                        1
N#define UART0_C1_ILT_MASK                        0x4u
N#define UART0_C1_ILT_SHIFT                       2
N#define UART0_C1_WAKE_MASK                       0x8u
N#define UART0_C1_WAKE_SHIFT                      3
N#define UART0_C1_M_MASK                          0x10u
N#define UART0_C1_M_SHIFT                         4
N#define UART0_C1_RSRC_MASK                       0x20u
N#define UART0_C1_RSRC_SHIFT                      5
N#define UART0_C1_DOZEEN_MASK                     0x40u
N#define UART0_C1_DOZEEN_SHIFT                    6
N#define UART0_C1_LOOPS_MASK                      0x80u
N#define UART0_C1_LOOPS_SHIFT                     7
N/* C2 Bit Fields */
N#define UART0_C2_SBK_MASK                        0x1u
N#define UART0_C2_SBK_SHIFT                       0
N#define UART0_C2_RWU_MASK                        0x2u
N#define UART0_C2_RWU_SHIFT                       1
N#define UART0_C2_RE_MASK                         0x4u
N#define UART0_C2_RE_SHIFT                        2
N#define UART0_C2_TE_MASK                         0x8u
N#define UART0_C2_TE_SHIFT                        3
N#define UART0_C2_ILIE_MASK                       0x10u
N#define UART0_C2_ILIE_SHIFT                      4
N#define UART0_C2_RIE_MASK                        0x20u
N#define UART0_C2_RIE_SHIFT                       5
N#define UART0_C2_TCIE_MASK                       0x40u
N#define UART0_C2_TCIE_SHIFT                      6
N#define UART0_C2_TIE_MASK                        0x80u
N#define UART0_C2_TIE_SHIFT                       7
N/* S1 Bit Fields */
N#define UART0_S1_PF_MASK                         0x1u
N#define UART0_S1_PF_SHIFT                        0
N#define UART0_S1_FE_MASK                         0x2u
N#define UART0_S1_FE_SHIFT                        1
N#define UART0_S1_NF_MASK                         0x4u
N#define UART0_S1_NF_SHIFT                        2
N#define UART0_S1_OR_MASK                         0x8u
N#define UART0_S1_OR_SHIFT                        3
N#define UART0_S1_IDLE_MASK                       0x10u
N#define UART0_S1_IDLE_SHIFT                      4
N#define UART0_S1_RDRF_MASK                       0x20u
N#define UART0_S1_RDRF_SHIFT                      5
N#define UART0_S1_TC_MASK                         0x40u
N#define UART0_S1_TC_SHIFT                        6
N#define UART0_S1_TDRE_MASK                       0x80u
N#define UART0_S1_TDRE_SHIFT                      7
N/* S2 Bit Fields */
N#define UART0_S2_RAF_MASK                        0x1u
N#define UART0_S2_RAF_SHIFT                       0
N#define UART0_S2_LBKDE_MASK                      0x2u
N#define UART0_S2_LBKDE_SHIFT                     1
N#define UART0_S2_BRK13_MASK                      0x4u
N#define UART0_S2_BRK13_SHIFT                     2
N#define UART0_S2_RWUID_MASK                      0x8u
N#define UART0_S2_RWUID_SHIFT                     3
N#define UART0_S2_RXINV_MASK                      0x10u
N#define UART0_S2_RXINV_SHIFT                     4
N#define UART0_S2_MSBF_MASK                       0x20u
N#define UART0_S2_MSBF_SHIFT                      5
N#define UART0_S2_RXEDGIF_MASK                    0x40u
N#define UART0_S2_RXEDGIF_SHIFT                   6
N#define UART0_S2_LBKDIF_MASK                     0x80u
N#define UART0_S2_LBKDIF_SHIFT                    7
N/* C3 Bit Fields */
N#define UART0_C3_PEIE_MASK                       0x1u
N#define UART0_C3_PEIE_SHIFT                      0
N#define UART0_C3_FEIE_MASK                       0x2u
N#define UART0_C3_FEIE_SHIFT                      1
N#define UART0_C3_NEIE_MASK                       0x4u
N#define UART0_C3_NEIE_SHIFT                      2
N#define UART0_C3_ORIE_MASK                       0x8u
N#define UART0_C3_ORIE_SHIFT                      3
N#define UART0_C3_TXINV_MASK                      0x10u
N#define UART0_C3_TXINV_SHIFT                     4
N#define UART0_C3_TXDIR_MASK                      0x20u
N#define UART0_C3_TXDIR_SHIFT                     5
N#define UART0_C3_R9T8_MASK                       0x40u
N#define UART0_C3_R9T8_SHIFT                      6
N#define UART0_C3_R8T9_MASK                       0x80u
N#define UART0_C3_R8T9_SHIFT                      7
N/* D Bit Fields */
N#define UART0_D_R0T0_MASK                        0x1u
N#define UART0_D_R0T0_SHIFT                       0
N#define UART0_D_R1T1_MASK                        0x2u
N#define UART0_D_R1T1_SHIFT                       1
N#define UART0_D_R2T2_MASK                        0x4u
N#define UART0_D_R2T2_SHIFT                       2
N#define UART0_D_R3T3_MASK                        0x8u
N#define UART0_D_R3T3_SHIFT                       3
N#define UART0_D_R4T4_MASK                        0x10u
N#define UART0_D_R4T4_SHIFT                       4
N#define UART0_D_R5T5_MASK                        0x20u
N#define UART0_D_R5T5_SHIFT                       5
N#define UART0_D_R6T6_MASK                        0x40u
N#define UART0_D_R6T6_SHIFT                       6
N#define UART0_D_R7T7_MASK                        0x80u
N#define UART0_D_R7T7_SHIFT                       7
N/* MA1 Bit Fields */
N#define UART0_MA1_MA_MASK                        0xFFu
N#define UART0_MA1_MA_SHIFT                       0
N#define UART0_MA1_MA(x)                          (((uint8_t)(((uint8_t)(x))<<UART0_MA1_MA_SHIFT))&UART0_MA1_MA_MASK)
N/* MA2 Bit Fields */
N#define UART0_MA2_MA_MASK                        0xFFu
N#define UART0_MA2_MA_SHIFT                       0
N#define UART0_MA2_MA(x)                          (((uint8_t)(((uint8_t)(x))<<UART0_MA2_MA_SHIFT))&UART0_MA2_MA_MASK)
N/* C4 Bit Fields */
N#define UART0_C4_OSR_MASK                        0x1Fu
N#define UART0_C4_OSR_SHIFT                       0
N#define UART0_C4_OSR(x)                          (((uint8_t)(((uint8_t)(x))<<UART0_C4_OSR_SHIFT))&UART0_C4_OSR_MASK)
N#define UART0_C4_M10_MASK                        0x20u
N#define UART0_C4_M10_SHIFT                       5
N#define UART0_C4_MAEN2_MASK                      0x40u
N#define UART0_C4_MAEN2_SHIFT                     6
N#define UART0_C4_MAEN1_MASK                      0x80u
N#define UART0_C4_MAEN1_SHIFT                     7
N/* C5 Bit Fields */
N#define UART0_C5_RESYNCDIS_MASK                  0x1u
N#define UART0_C5_RESYNCDIS_SHIFT                 0
N#define UART0_C5_BOTHEDGE_MASK                   0x2u
N#define UART0_C5_BOTHEDGE_SHIFT                  1
N#define UART0_C5_RDMAE_MASK                      0x20u
N#define UART0_C5_RDMAE_SHIFT                     5
N#define UART0_C5_TDMAE_MASK                      0x80u
N#define UART0_C5_TDMAE_SHIFT                     7
N
N/**
N * @}
N */ /* end of group UART0_Register_Masks */
N
N
N/* UART0 - Peripheral instance base addresses */
N/** Peripheral UART0 base address */
N#define UART0_BASE                               (0x4006A000u)
N/** Peripheral UART0 base pointer */
N#define UART0                                    ((UART0_Type *)UART0_BASE)
N/** Array initializer of UART0 peripheral base pointers */
N#define UART0_BASES                              { UART0 }
N
N/**
N * @}
N */ /* end of group UART0_Peripheral_Access_Layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- USB Peripheral Access Layer
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup USB_Peripheral_Access_Layer USB Peripheral Access Layer
N * @{
N */
N
N/** USB - Register Layout Typedef */
Ntypedef struct {
N  __I  uint8_t PERID;                              /**< Peripheral ID register, offset: 0x0 */
X  volatile const  uint8_t PERID;                               
N       uint8_t RESERVED_0[3];
N  __I  uint8_t IDCOMP;                             /**< Peripheral ID Complement register, offset: 0x4 */
X  volatile const  uint8_t IDCOMP;                              
N       uint8_t RESERVED_1[3];
N  __I  uint8_t REV;                                /**< Peripheral Revision register, offset: 0x8 */
X  volatile const  uint8_t REV;                                 
N       uint8_t RESERVED_2[3];
N  __I  uint8_t ADDINFO;                            /**< Peripheral Additional Info register, offset: 0xC */
X  volatile const  uint8_t ADDINFO;                             
N       uint8_t RESERVED_3[3];
N  __IO uint8_t OTGISTAT;                           /**< OTG Interrupt Status register, offset: 0x10 */
X  volatile uint8_t OTGISTAT;                            
N       uint8_t RESERVED_4[3];
N  __IO uint8_t OTGICR;                             /**< OTG Interrupt Control Register, offset: 0x14 */
X  volatile uint8_t OTGICR;                              
N       uint8_t RESERVED_5[3];
N  __IO uint8_t OTGSTAT;                            /**< OTG Status register, offset: 0x18 */
X  volatile uint8_t OTGSTAT;                             
N       uint8_t RESERVED_6[3];
N  __IO uint8_t OTGCTL;                             /**< OTG Control register, offset: 0x1C */
X  volatile uint8_t OTGCTL;                              
N       uint8_t RESERVED_7[99];
N  __IO uint8_t ISTAT;                              /**< Interrupt Status register, offset: 0x80 */
X  volatile uint8_t ISTAT;                               
N       uint8_t RESERVED_8[3];
N  __IO uint8_t INTEN;                              /**< Interrupt Enable register, offset: 0x84 */
X  volatile uint8_t INTEN;                               
N       uint8_t RESERVED_9[3];
N  __IO uint8_t ERRSTAT;                            /**< Error Interrupt Status register, offset: 0x88 */
X  volatile uint8_t ERRSTAT;                             
N       uint8_t RESERVED_10[3];
N  __IO uint8_t ERREN;                              /**< Error Interrupt Enable register, offset: 0x8C */
X  volatile uint8_t ERREN;                               
N       uint8_t RESERVED_11[3];
N  __I  uint8_t STAT;                               /**< Status register, offset: 0x90 */
X  volatile const  uint8_t STAT;                                
N       uint8_t RESERVED_12[3];
N  __IO uint8_t CTL;                                /**< Control register, offset: 0x94 */
X  volatile uint8_t CTL;                                 
N       uint8_t RESERVED_13[3];
N  __IO uint8_t ADDR;                               /**< Address register, offset: 0x98 */
X  volatile uint8_t ADDR;                                
N       uint8_t RESERVED_14[3];
N  __IO uint8_t BDTPAGE1;                           /**< BDT Page Register 1, offset: 0x9C */
X  volatile uint8_t BDTPAGE1;                            
N       uint8_t RESERVED_15[3];
N  __IO uint8_t FRMNUML;                            /**< Frame Number Register Low, offset: 0xA0 */
X  volatile uint8_t FRMNUML;                             
N       uint8_t RESERVED_16[3];
N  __IO uint8_t FRMNUMH;                            /**< Frame Number Register High, offset: 0xA4 */
X  volatile uint8_t FRMNUMH;                             
N       uint8_t RESERVED_17[3];
N  __IO uint8_t TOKEN;                              /**< Token register, offset: 0xA8 */
X  volatile uint8_t TOKEN;                               
N       uint8_t RESERVED_18[3];
N  __IO uint8_t SOFTHLD;                            /**< SOF Threshold Register, offset: 0xAC */
X  volatile uint8_t SOFTHLD;                             
N       uint8_t RESERVED_19[3];
N  __IO uint8_t BDTPAGE2;                           /**< BDT Page Register 2, offset: 0xB0 */
X  volatile uint8_t BDTPAGE2;                            
N       uint8_t RESERVED_20[3];
N  __IO uint8_t BDTPAGE3;                           /**< BDT Page Register 3, offset: 0xB4 */
X  volatile uint8_t BDTPAGE3;                            
N       uint8_t RESERVED_21[11];
N  struct {                                         /* offset: 0xC0, array step: 0x4 */
N    __IO uint8_t ENDPT;                              /**< Endpoint Control register, array offset: 0xC0, array step: 0x4 */
X    volatile uint8_t ENDPT;                               
N         uint8_t RESERVED_0[3];
N  } ENDPOINT[16];
N  __IO uint8_t USBCTRL;                            /**< USB Control register, offset: 0x100 */
X  volatile uint8_t USBCTRL;                             
N       uint8_t RESERVED_22[3];
N  __I  uint8_t OBSERVE;                            /**< USB OTG Observe register, offset: 0x104 */
X  volatile const  uint8_t OBSERVE;                             
N       uint8_t RESERVED_23[3];
N  __IO uint8_t CONTROL;                            /**< USB OTG Control register, offset: 0x108 */
X  volatile uint8_t CONTROL;                             
N       uint8_t RESERVED_24[3];
N  __IO uint8_t USBTRC0;                            /**< USB Transceiver Control Register 0, offset: 0x10C */
X  volatile uint8_t USBTRC0;                             
N       uint8_t RESERVED_25[7];
N  __IO uint8_t USBFRMADJUST;                       /**< Frame Adjust Register, offset: 0x114 */
X  volatile uint8_t USBFRMADJUST;                        
N} USB_Type;
N
N/* ----------------------------------------------------------------------------
N   -- USB Register Masks
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup USB_Register_Masks USB Register Masks
N * @{
N */
N
N/* PERID Bit Fields */
N#define USB_PERID_ID_MASK                        0x3Fu
N#define USB_PERID_ID_SHIFT                       0
N#define USB_PERID_ID(x)                          (((uint8_t)(((uint8_t)(x))<<USB_PERID_ID_SHIFT))&USB_PERID_ID_MASK)
N/* IDCOMP Bit Fields */
N#define USB_IDCOMP_NID_MASK                      0x3Fu
N#define USB_IDCOMP_NID_SHIFT                     0
N#define USB_IDCOMP_NID(x)                        (((uint8_t)(((uint8_t)(x))<<USB_IDCOMP_NID_SHIFT))&USB_IDCOMP_NID_MASK)
N/* REV Bit Fields */
N#define USB_REV_REV_MASK                         0xFFu
N#define USB_REV_REV_SHIFT                        0
N#define USB_REV_REV(x)                           (((uint8_t)(((uint8_t)(x))<<USB_REV_REV_SHIFT))&USB_REV_REV_MASK)
N/* ADDINFO Bit Fields */
N#define USB_ADDINFO_IEHOST_MASK                  0x1u
N#define USB_ADDINFO_IEHOST_SHIFT                 0
N#define USB_ADDINFO_IRQNUM_MASK                  0xF8u
N#define USB_ADDINFO_IRQNUM_SHIFT                 3
N#define USB_ADDINFO_IRQNUM(x)                    (((uint8_t)(((uint8_t)(x))<<USB_ADDINFO_IRQNUM_SHIFT))&USB_ADDINFO_IRQNUM_MASK)
N/* OTGISTAT Bit Fields */
N#define USB_OTGISTAT_AVBUSCHG_MASK               0x1u
N#define USB_OTGISTAT_AVBUSCHG_SHIFT              0
N#define USB_OTGISTAT_B_SESS_CHG_MASK             0x4u
N#define USB_OTGISTAT_B_SESS_CHG_SHIFT            2
N#define USB_OTGISTAT_SESSVLDCHG_MASK             0x8u
N#define USB_OTGISTAT_SESSVLDCHG_SHIFT            3
N#define USB_OTGISTAT_LINE_STATE_CHG_MASK         0x20u
N#define USB_OTGISTAT_LINE_STATE_CHG_SHIFT        5
N#define USB_OTGISTAT_ONEMSEC_MASK                0x40u
N#define USB_OTGISTAT_ONEMSEC_SHIFT               6
N#define USB_OTGISTAT_IDCHG_MASK                  0x80u
N#define USB_OTGISTAT_IDCHG_SHIFT                 7
N/* OTGICR Bit Fields */
N#define USB_OTGICR_AVBUSEN_MASK                  0x1u
N#define USB_OTGICR_AVBUSEN_SHIFT                 0
N#define USB_OTGICR_BSESSEN_MASK                  0x4u
N#define USB_OTGICR_BSESSEN_SHIFT                 2
N#define USB_OTGICR_SESSVLDEN_MASK                0x8u
N#define USB_OTGICR_SESSVLDEN_SHIFT               3
N#define USB_OTGICR_LINESTATEEN_MASK              0x20u
N#define USB_OTGICR_LINESTATEEN_SHIFT             5
N#define USB_OTGICR_ONEMSECEN_MASK                0x40u
N#define USB_OTGICR_ONEMSECEN_SHIFT               6
N#define USB_OTGICR_IDEN_MASK                     0x80u
N#define USB_OTGICR_IDEN_SHIFT                    7
N/* OTGSTAT Bit Fields */
N#define USB_OTGSTAT_AVBUSVLD_MASK                0x1u
N#define USB_OTGSTAT_AVBUSVLD_SHIFT               0
N#define USB_OTGSTAT_BSESSEND_MASK                0x4u
N#define USB_OTGSTAT_BSESSEND_SHIFT               2
N#define USB_OTGSTAT_SESS_VLD_MASK                0x8u
N#define USB_OTGSTAT_SESS_VLD_SHIFT               3
N#define USB_OTGSTAT_LINESTATESTABLE_MASK         0x20u
N#define USB_OTGSTAT_LINESTATESTABLE_SHIFT        5
N#define USB_OTGSTAT_ONEMSECEN_MASK               0x40u
N#define USB_OTGSTAT_ONEMSECEN_SHIFT              6
N#define USB_OTGSTAT_ID_MASK                      0x80u
N#define USB_OTGSTAT_ID_SHIFT                     7
N/* OTGCTL Bit Fields */
N#define USB_OTGCTL_OTGEN_MASK                    0x4u
N#define USB_OTGCTL_OTGEN_SHIFT                   2
N#define USB_OTGCTL_DMLOW_MASK                    0x10u
N#define USB_OTGCTL_DMLOW_SHIFT                   4
N#define USB_OTGCTL_DPLOW_MASK                    0x20u
N#define USB_OTGCTL_DPLOW_SHIFT                   5
N#define USB_OTGCTL_DPHIGH_MASK                   0x80u
N#define USB_OTGCTL_DPHIGH_SHIFT                  7
N/* ISTAT Bit Fields */
N#define USB_ISTAT_USBRST_MASK                    0x1u
N#define USB_ISTAT_USBRST_SHIFT                   0
N#define USB_ISTAT_ERROR_MASK                     0x2u
N#define USB_ISTAT_ERROR_SHIFT                    1
N#define USB_ISTAT_SOFTOK_MASK                    0x4u
N#define USB_ISTAT_SOFTOK_SHIFT                   2
N#define USB_ISTAT_TOKDNE_MASK                    0x8u
N#define USB_ISTAT_TOKDNE_SHIFT                   3
N#define USB_ISTAT_SLEEP_MASK                     0x10u
N#define USB_ISTAT_SLEEP_SHIFT                    4
N#define USB_ISTAT_RESUME_MASK                    0x20u
N#define USB_ISTAT_RESUME_SHIFT                   5
N#define USB_ISTAT_ATTACH_MASK                    0x40u
N#define USB_ISTAT_ATTACH_SHIFT                   6
N#define USB_ISTAT_STALL_MASK                     0x80u
N#define USB_ISTAT_STALL_SHIFT                    7
N/* INTEN Bit Fields */
N#define USB_INTEN_USBRSTEN_MASK                  0x1u
N#define USB_INTEN_USBRSTEN_SHIFT                 0
N#define USB_INTEN_ERROREN_MASK                   0x2u
N#define USB_INTEN_ERROREN_SHIFT                  1
N#define USB_INTEN_SOFTOKEN_MASK                  0x4u
N#define USB_INTEN_SOFTOKEN_SHIFT                 2
N#define USB_INTEN_TOKDNEEN_MASK                  0x8u
N#define USB_INTEN_TOKDNEEN_SHIFT                 3
N#define USB_INTEN_SLEEPEN_MASK                   0x10u
N#define USB_INTEN_SLEEPEN_SHIFT                  4
N#define USB_INTEN_RESUMEEN_MASK                  0x20u
N#define USB_INTEN_RESUMEEN_SHIFT                 5
N#define USB_INTEN_ATTACHEN_MASK                  0x40u
N#define USB_INTEN_ATTACHEN_SHIFT                 6
N#define USB_INTEN_STALLEN_MASK                   0x80u
N#define USB_INTEN_STALLEN_SHIFT                  7
N/* ERRSTAT Bit Fields */
N#define USB_ERRSTAT_PIDERR_MASK                  0x1u
N#define USB_ERRSTAT_PIDERR_SHIFT                 0
N#define USB_ERRSTAT_CRC5EOF_MASK                 0x2u
N#define USB_ERRSTAT_CRC5EOF_SHIFT                1
N#define USB_ERRSTAT_CRC16_MASK                   0x4u
N#define USB_ERRSTAT_CRC16_SHIFT                  2
N#define USB_ERRSTAT_DFN8_MASK                    0x8u
N#define USB_ERRSTAT_DFN8_SHIFT                   3
N#define USB_ERRSTAT_BTOERR_MASK                  0x10u
N#define USB_ERRSTAT_BTOERR_SHIFT                 4
N#define USB_ERRSTAT_DMAERR_MASK                  0x20u
N#define USB_ERRSTAT_DMAERR_SHIFT                 5
N#define USB_ERRSTAT_BTSERR_MASK                  0x80u
N#define USB_ERRSTAT_BTSERR_SHIFT                 7
N/* ERREN Bit Fields */
N#define USB_ERREN_PIDERREN_MASK                  0x1u
N#define USB_ERREN_PIDERREN_SHIFT                 0
N#define USB_ERREN_CRC5EOFEN_MASK                 0x2u
N#define USB_ERREN_CRC5EOFEN_SHIFT                1
N#define USB_ERREN_CRC16EN_MASK                   0x4u
N#define USB_ERREN_CRC16EN_SHIFT                  2
N#define USB_ERREN_DFN8EN_MASK                    0x8u
N#define USB_ERREN_DFN8EN_SHIFT                   3
N#define USB_ERREN_BTOERREN_MASK                  0x10u
N#define USB_ERREN_BTOERREN_SHIFT                 4
N#define USB_ERREN_DMAERREN_MASK                  0x20u
N#define USB_ERREN_DMAERREN_SHIFT                 5
N#define USB_ERREN_BTSERREN_MASK                  0x80u
N#define USB_ERREN_BTSERREN_SHIFT                 7
N/* STAT Bit Fields */
N#define USB_STAT_ODD_MASK                        0x4u
N#define USB_STAT_ODD_SHIFT                       2
N#define USB_STAT_TX_MASK                         0x8u
N#define USB_STAT_TX_SHIFT                        3
N#define USB_STAT_ENDP_MASK                       0xF0u
N#define USB_STAT_ENDP_SHIFT                      4
N#define USB_STAT_ENDP(x)                         (((uint8_t)(((uint8_t)(x))<<USB_STAT_ENDP_SHIFT))&USB_STAT_ENDP_MASK)
N/* CTL Bit Fields */
N#define USB_CTL_USBENSOFEN_MASK                  0x1u
N#define USB_CTL_USBENSOFEN_SHIFT                 0
N#define USB_CTL_ODDRST_MASK                      0x2u
N#define USB_CTL_ODDRST_SHIFT                     1
N#define USB_CTL_RESUME_MASK                      0x4u
N#define USB_CTL_RESUME_SHIFT                     2
N#define USB_CTL_HOSTMODEEN_MASK                  0x8u
N#define USB_CTL_HOSTMODEEN_SHIFT                 3
N#define USB_CTL_RESET_MASK                       0x10u
N#define USB_CTL_RESET_SHIFT                      4
N#define USB_CTL_TXSUSPENDTOKENBUSY_MASK          0x20u
N#define USB_CTL_TXSUSPENDTOKENBUSY_SHIFT         5
N#define USB_CTL_SE0_MASK                         0x40u
N#define USB_CTL_SE0_SHIFT                        6
N#define USB_CTL_JSTATE_MASK                      0x80u
N#define USB_CTL_JSTATE_SHIFT                     7
N/* ADDR Bit Fields */
N#define USB_ADDR_ADDR_MASK                       0x7Fu
N#define USB_ADDR_ADDR_SHIFT                      0
N#define USB_ADDR_ADDR(x)                         (((uint8_t)(((uint8_t)(x))<<USB_ADDR_ADDR_SHIFT))&USB_ADDR_ADDR_MASK)
N#define USB_ADDR_LSEN_MASK                       0x80u
N#define USB_ADDR_LSEN_SHIFT                      7
N/* BDTPAGE1 Bit Fields */
N#define USB_BDTPAGE1_BDTBA_MASK                  0xFEu
N#define USB_BDTPAGE1_BDTBA_SHIFT                 1
N#define USB_BDTPAGE1_BDTBA(x)                    (((uint8_t)(((uint8_t)(x))<<USB_BDTPAGE1_BDTBA_SHIFT))&USB_BDTPAGE1_BDTBA_MASK)
N/* FRMNUML Bit Fields */
N#define USB_FRMNUML_FRM_MASK                     0xFFu
N#define USB_FRMNUML_FRM_SHIFT                    0
N#define USB_FRMNUML_FRM(x)                       (((uint8_t)(((uint8_t)(x))<<USB_FRMNUML_FRM_SHIFT))&USB_FRMNUML_FRM_MASK)
N/* FRMNUMH Bit Fields */
N#define USB_FRMNUMH_FRM_MASK                     0x7u
N#define USB_FRMNUMH_FRM_SHIFT                    0
N#define USB_FRMNUMH_FRM(x)                       (((uint8_t)(((uint8_t)(x))<<USB_FRMNUMH_FRM_SHIFT))&USB_FRMNUMH_FRM_MASK)
N/* TOKEN Bit Fields */
N#define USB_TOKEN_TOKENENDPT_MASK                0xFu
N#define USB_TOKEN_TOKENENDPT_SHIFT               0
N#define USB_TOKEN_TOKENENDPT(x)                  (((uint8_t)(((uint8_t)(x))<<USB_TOKEN_TOKENENDPT_SHIFT))&USB_TOKEN_TOKENENDPT_MASK)
N#define USB_TOKEN_TOKENPID_MASK                  0xF0u
N#define USB_TOKEN_TOKENPID_SHIFT                 4
N#define USB_TOKEN_TOKENPID(x)                    (((uint8_t)(((uint8_t)(x))<<USB_TOKEN_TOKENPID_SHIFT))&USB_TOKEN_TOKENPID_MASK)
N/* SOFTHLD Bit Fields */
N#define USB_SOFTHLD_CNT_MASK                     0xFFu
N#define USB_SOFTHLD_CNT_SHIFT                    0
N#define USB_SOFTHLD_CNT(x)                       (((uint8_t)(((uint8_t)(x))<<USB_SOFTHLD_CNT_SHIFT))&USB_SOFTHLD_CNT_MASK)
N/* BDTPAGE2 Bit Fields */
N#define USB_BDTPAGE2_BDTBA_MASK                  0xFFu
N#define USB_BDTPAGE2_BDTBA_SHIFT                 0
N#define USB_BDTPAGE2_BDTBA(x)                    (((uint8_t)(((uint8_t)(x))<<USB_BDTPAGE2_BDTBA_SHIFT))&USB_BDTPAGE2_BDTBA_MASK)
N/* BDTPAGE3 Bit Fields */
N#define USB_BDTPAGE3_BDTBA_MASK                  0xFFu
N#define USB_BDTPAGE3_BDTBA_SHIFT                 0
N#define USB_BDTPAGE3_BDTBA(x)                    (((uint8_t)(((uint8_t)(x))<<USB_BDTPAGE3_BDTBA_SHIFT))&USB_BDTPAGE3_BDTBA_MASK)
N/* ENDPT Bit Fields */
N#define USB_ENDPT_EPHSHK_MASK                    0x1u
N#define USB_ENDPT_EPHSHK_SHIFT                   0
N#define USB_ENDPT_EPSTALL_MASK                   0x2u
N#define USB_ENDPT_EPSTALL_SHIFT                  1
N#define USB_ENDPT_EPTXEN_MASK                    0x4u
N#define USB_ENDPT_EPTXEN_SHIFT                   2
N#define USB_ENDPT_EPRXEN_MASK                    0x8u
N#define USB_ENDPT_EPRXEN_SHIFT                   3
N#define USB_ENDPT_EPCTLDIS_MASK                  0x10u
N#define USB_ENDPT_EPCTLDIS_SHIFT                 4
N#define USB_ENDPT_RETRYDIS_MASK                  0x40u
N#define USB_ENDPT_RETRYDIS_SHIFT                 6
N#define USB_ENDPT_HOSTWOHUB_MASK                 0x80u
N#define USB_ENDPT_HOSTWOHUB_SHIFT                7
N/* USBCTRL Bit Fields */
N#define USB_USBCTRL_PDE_MASK                     0x40u
N#define USB_USBCTRL_PDE_SHIFT                    6
N#define USB_USBCTRL_SUSP_MASK                    0x80u
N#define USB_USBCTRL_SUSP_SHIFT                   7
N/* OBSERVE Bit Fields */
N#define USB_OBSERVE_DMPD_MASK                    0x10u
N#define USB_OBSERVE_DMPD_SHIFT                   4
N#define USB_OBSERVE_DPPD_MASK                    0x40u
N#define USB_OBSERVE_DPPD_SHIFT                   6
N#define USB_OBSERVE_DPPU_MASK                    0x80u
N#define USB_OBSERVE_DPPU_SHIFT                   7
N/* CONTROL Bit Fields */
N#define USB_CONTROL_DPPULLUPNONOTG_MASK          0x10u
N#define USB_CONTROL_DPPULLUPNONOTG_SHIFT         4
N/* USBTRC0 Bit Fields */
N#define USB_USBTRC0_USB_RESUME_INT_MASK          0x1u
N#define USB_USBTRC0_USB_RESUME_INT_SHIFT         0
N#define USB_USBTRC0_SYNC_DET_MASK                0x2u
N#define USB_USBTRC0_SYNC_DET_SHIFT               1
N#define USB_USBTRC0_USBRESMEN_MASK               0x20u
N#define USB_USBTRC0_USBRESMEN_SHIFT              5
N#define USB_USBTRC0_USBRESET_MASK                0x80u
N#define USB_USBTRC0_USBRESET_SHIFT               7
N/* USBFRMADJUST Bit Fields */
N#define USB_USBFRMADJUST_ADJ_MASK                0xFFu
N#define USB_USBFRMADJUST_ADJ_SHIFT               0
N#define USB_USBFRMADJUST_ADJ(x)                  (((uint8_t)(((uint8_t)(x))<<USB_USBFRMADJUST_ADJ_SHIFT))&USB_USBFRMADJUST_ADJ_MASK)
N
N/**
N * @}
N */ /* end of group USB_Register_Masks */
N
N
N/* USB - Peripheral instance base addresses */
N/** Peripheral USB0 base address */
N#define USB0_BASE                                (0x40072000u)
N/** Peripheral USB0 base pointer */
N#define USB0                                     ((USB_Type *)USB0_BASE)
N/** Array initializer of USB peripheral base pointers */
N#define USB_BASES                                { USB0 }
N
N/**
N * @}
N */ /* end of group USB_Peripheral_Access_Layer */
N
N
N/*
N** End of section using anonymous unions
N*/
N
N#if defined(__ARMCC_VERSION)
X#if 1L
N  #pragma pop
N#elif defined(__CWCC__)
S  #pragma pop
S#elif defined(__GNUC__)
S  /* leave anonymous unions enabled */
S#elif defined(__IAR_SYSTEMS_ICC__)
S  #pragma language=default
S#else
S  #error Not supported compiler type
N#endif
N
N/**
N * @}
N */ /* end of group Peripheral_access_layer */
N
N
N/* ----------------------------------------------------------------------------
N   -- Backward Compatibility
N   ---------------------------------------------------------------------------- */
N
N/**
N * @addtogroup Backward_Compatibility_Symbols Backward Compatibility
N * @{
N */
N
N#define DMA_REQC_ARR_DMAC_MASK                   This_symbol_has_been_deprecated
N#define DMA_REQC_ARR_DMAC_SHIFT                  This_symbol_has_been_deprecated
N#define DMA_REQC_ARR_DMAC(x)                     This_symbol_has_been_deprecated
N#define DMA_REQC_ARR_CFSM_MASK                   This_symbol_has_been_deprecated
N#define DMA_REQC_ARR_CFSM_SHIFT                  This_symbol_has_been_deprecated
N#define DMA_REQC0                                This_symbol_has_been_deprecated
N#define DMA_REQC1                                This_symbol_has_been_deprecated
N#define DMA_REQC2                                This_symbol_has_been_deprecated
N#define DMA_REQC3                                This_symbol_has_been_deprecated
N#define MCG_S_LOLS_MASK                          MCG_S_LOLS0_MASK
N#define MCG_S_LOLS_SHIFT                         MCG_S_LOLS0_SHIFT
N#define SIM_FCFG2_MAXADDR_MASK                   SIM_FCFG2_MAXADDR0_MASK
N#define SIM_FCFG2_MAXADDR_SHIFT                  SIM_FCFG2_MAXADDR0_SHIFT
N#define SIM_FCFG2_MAXADDR                        SIM_FCFG2_MAXADDR0
N#define SPI_C2_SPLPIE_MASK                       This_symbol_has_been_deprecated
N#define SPI_C2_SPLPIE_SHIFT                      This_symbol_has_been_deprecated
N#define UART_C4_LBKDDMAS_MASK                    This_symbol_has_been_deprecated
N#define UART_C4_LBKDDMAS_SHIFT                   This_symbol_has_been_deprecated
N#define UART_C4_ILDMAS_MASK                      This_symbol_has_been_deprecated
N#define UART_C4_ILDMAS_SHIFT                     This_symbol_has_been_deprecated
N#define UART_C4_TCDMAS_MASK                      This_symbol_has_been_deprecated
N#define UART_C4_TCDMAS_SHIFT                     This_symbol_has_been_deprecated
N#define UARTLP_Type                              UART0_Type
N#define UARTLP_BDH_REG                           UART0_BDH_REG
N#define UARTLP_BDL_REG                           UART0_BDL_REG
N#define UARTLP_C1_REG                            UART0_C1_REG
N#define UARTLP_C2_REG                            UART0_C2_REG
N#define UARTLP_S1_REG                            UART0_S1_REG
N#define UARTLP_S2_REG                            UART0_S2_REG
N#define UARTLP_C3_REG                            UART0_C3_REG
N#define UARTLP_D_REG                             UART0_D_REG
N#define UARTLP_MA1_REG                           UART0_MA1_REG
N#define UARTLP_MA2_REG                           UART0_MA2_REG
N#define UARTLP_C4_REG                            UART0_C4_REG
N#define UARTLP_C5_REG                            UART0_C5_REG
N#define UARTLP_BDH_SBR_MASK                      UART0_BDH_SBR_MASK
N#define UARTLP_BDH_SBR_SHIFT                     UART0_BDH_SBR_SHIFT
N#define UARTLP_BDH_SBR(x)                        UART0_BDH_SBR(x)
N#define UARTLP_BDH_SBNS_MASK                     UART0_BDH_SBNS_MASK
N#define UARTLP_BDH_SBNS_SHIFT                    UART0_BDH_SBNS_SHIFT
N#define UARTLP_BDH_RXEDGIE_MASK                  UART0_BDH_RXEDGIE_MASK
N#define UARTLP_BDH_RXEDGIE_SHIFT                 UART0_BDH_RXEDGIE_SHIFT
N#define UARTLP_BDH_LBKDIE_MASK                   UART0_BDH_LBKDIE_MASK
N#define UARTLP_BDH_LBKDIE_SHIFT                  UART0_BDH_LBKDIE_SHIFT
N#define UARTLP_BDL_SBR_MASK                      UART0_BDL_SBR_MASK
N#define UARTLP_BDL_SBR_SHIFT                     UART0_BDL_SBR_SHIFT
N#define UARTLP_BDL_SBR(x)                        UART0_BDL_SBR(x)
N#define UARTLP_C1_PT_MASK                        UART0_C1_PT_MASK
N#define UARTLP_C1_PT_SHIFT                       UART0_C1_PT_SHIFT
N#define UARTLP_C1_PE_MASK                        UART0_C1_PE_MASK
N#define UARTLP_C1_PE_SHIFT                       UART0_C1_PE_SHIFT
N#define UARTLP_C1_ILT_MASK                       UART0_C1_ILT_MASK
N#define UARTLP_C1_ILT_SHIFT                      UART0_C1_ILT_SHIFT
N#define UARTLP_C1_WAKE_MASK                      UART0_C1_WAKE_MASK
N#define UARTLP_C1_WAKE_SHIFT                     UART0_C1_WAKE_SHIFT
N#define UARTLP_C1_M_MASK                         UART0_C1_M_MASK
N#define UARTLP_C1_M_SHIFT                        UART0_C1_M_SHIFT
N#define UARTLP_C1_RSRC_MASK                      UART0_C1_RSRC_MASK
N#define UARTLP_C1_RSRC_SHIFT                     UART0_C1_RSRC_SHIFT
N#define UARTLP_C1_DOZEEN_MASK                    UART0_C1_DOZEEN_MASK
N#define UARTLP_C1_DOZEEN_SHIFT                   UART0_C1_DOZEEN_SHIFT
N#define UARTLP_C1_LOOPS_MASK                     UART0_C1_LOOPS_MASK
N#define UARTLP_C1_LOOPS_SHIFT                    UART0_C1_LOOPS_SHIFT
N#define UARTLP_C2_SBK_MASK                       UART0_C2_SBK_MASK
N#define UARTLP_C2_SBK_SHIFT                      UART0_C2_SBK_SHIFT
N#define UARTLP_C2_RWU_MASK                       UART0_C2_RWU_MASK
N#define UARTLP_C2_RWU_SHIFT                      UART0_C2_RWU_SHIFT
N#define UARTLP_C2_RE_MASK                        UART0_C2_RE_MASK
N#define UARTLP_C2_RE_SHIFT                       UART0_C2_RE_SHIFT
N#define UARTLP_C2_TE_MASK                        UART0_C2_TE_MASK
N#define UARTLP_C2_TE_SHIFT                       UART0_C2_TE_SHIFT
N#define UARTLP_C2_ILIE_MASK                      UART0_C2_ILIE_MASK
N#define UARTLP_C2_ILIE_SHIFT                     UART0_C2_ILIE_SHIFT
N#define UARTLP_C2_RIE_MASK                       UART0_C2_RIE_MASK
N#define UARTLP_C2_RIE_SHIFT                      UART0_C2_RIE_SHIFT
N#define UARTLP_C2_TCIE_MASK                      UART0_C2_TCIE_MASK
N#define UARTLP_C2_TCIE_SHIFT                     UART0_C2_TCIE_SHIFT
N#define UARTLP_C2_TIE_MASK                       UART0_C2_TIE_MASK
N#define UARTLP_C2_TIE_SHIFT                      UART0_C2_TIE_SHIFT
N#define UARTLP_S1_PF_MASK                        UART0_S1_PF_MASK
N#define UARTLP_S1_PF_SHIFT                       UART0_S1_PF_SHIFT
N#define UARTLP_S1_FE_MASK                        UART0_S1_FE_MASK
N#define UARTLP_S1_FE_SHIFT                       UART0_S1_FE_SHIFT
N#define UARTLP_S1_NF_MASK                        UART0_S1_NF_MASK
N#define UARTLP_S1_NF_SHIFT                       UART0_S1_NF_SHIFT
N#define UARTLP_S1_OR_MASK                        UART0_S1_OR_MASK
N#define UARTLP_S1_OR_SHIFT                       UART0_S1_OR_SHIFT
N#define UARTLP_S1_IDLE_MASK                      UART0_S1_IDLE_MASK
N#define UARTLP_S1_IDLE_SHIFT                     UART0_S1_IDLE_SHIFT
N#define UARTLP_S1_RDRF_MASK                      UART0_S1_RDRF_MASK
N#define UARTLP_S1_RDRF_SHIFT                     UART0_S1_RDRF_SHIFT
N#define UARTLP_S1_TC_MASK                        UART0_S1_TC_MASK
N#define UARTLP_S1_TC_SHIFT                       UART0_S1_TC_SHIFT
N#define UARTLP_S1_TDRE_MASK                      UART0_S1_TDRE_MASK
N#define UARTLP_S1_TDRE_SHIFT                     UART0_S1_TDRE_SHIFT
N#define UARTLP_S2_RAF_MASK                       UART0_S2_RAF_MASK
N#define UARTLP_S2_RAF_SHIFT                      UART0_S2_RAF_SHIFT
N#define UARTLP_S2_LBKDE_MASK                     UART0_S2_LBKDE_MASK
N#define UARTLP_S2_LBKDE_SHIFT                    UART0_S2_LBKDE_SHIFT
N#define UARTLP_S2_BRK13_MASK                     UART0_S2_BRK13_MASK
N#define UARTLP_S2_BRK13_SHIFT                    UART0_S2_BRK13_SHIFT
N#define UARTLP_S2_RWUID_MASK                     UART0_S2_RWUID_MASK
N#define UARTLP_S2_RWUID_SHIFT                    UART0_S2_RWUID_SHIFT
N#define UARTLP_S2_RXINV_MASK                     UART0_S2_RXINV_MASK
N#define UARTLP_S2_RXINV_SHIFT                    UART0_S2_RXINV_SHIFT
N#define UARTLP_S2_MSBF_MASK                      UART0_S2_MSBF_MASK
N#define UARTLP_S2_MSBF_SHIFT                     UART0_S2_MSBF_SHIFT
N#define UARTLP_S2_RXEDGIF_MASK                   UART0_S2_RXEDGIF_MASK
N#define UARTLP_S2_RXEDGIF_SHIFT                  UART0_S2_RXEDGIF_SHIFT
N#define UARTLP_S2_LBKDIF_MASK                    UART0_S2_LBKDIF_MASK
N#define UARTLP_S2_LBKDIF_SHIFT                   UART0_S2_LBKDIF_SHIFT
N#define UARTLP_C3_PEIE_MASK                      UART0_C3_PEIE_MASK
N#define UARTLP_C3_PEIE_SHIFT                     UART0_C3_PEIE_SHIFT
N#define UARTLP_C3_FEIE_MASK                      UART0_C3_FEIE_MASK
N#define UARTLP_C3_FEIE_SHIFT                     UART0_C3_FEIE_SHIFT
N#define UARTLP_C3_NEIE_MASK                      UART0_C3_NEIE_MASK
N#define UARTLP_C3_NEIE_SHIFT                     UART0_C3_NEIE_SHIFT
N#define UARTLP_C3_ORIE_MASK                      UART0_C3_ORIE_MASK
N#define UARTLP_C3_ORIE_SHIFT                     UART0_C3_ORIE_SHIFT
N#define UARTLP_C3_TXINV_MASK                     UART0_C3_TXINV_MASK
N#define UARTLP_C3_TXINV_SHIFT                    UART0_C3_TXINV_SHIFT
N#define UARTLP_C3_TXDIR_MASK                     UART0_C3_TXDIR_MASK
N#define UARTLP_C3_TXDIR_SHIFT                    UART0_C3_TXDIR_SHIFT
N#define UARTLP_C3_R9T8_MASK                      UART0_C3_R9T8_MASK
N#define UARTLP_C3_R9T8_SHIFT                     UART0_C3_R9T8_SHIFT
N#define UARTLP_C3_R8T9_MASK                      UART0_C3_R8T9_MASK
N#define UARTLP_C3_R8T9_SHIFT                     UART0_C3_R8T9_SHIFT
N#define UARTLP_D_R0T0_MASK                       UART0_D_R0T0_MASK
N#define UARTLP_D_R0T0_SHIFT                      UART0_D_R0T0_SHIFT
N#define UARTLP_D_R1T1_MASK                       UART0_D_R1T1_MASK
N#define UARTLP_D_R1T1_SHIFT                      UART0_D_R1T1_SHIFT
N#define UARTLP_D_R2T2_MASK                       UART0_D_R2T2_MASK
N#define UARTLP_D_R2T2_SHIFT                      UART0_D_R2T2_SHIFT
N#define UARTLP_D_R3T3_MASK                       UART0_D_R3T3_MASK
N#define UARTLP_D_R3T3_SHIFT                      UART0_D_R3T3_SHIFT
N#define UARTLP_D_R4T4_MASK                       UART0_D_R4T4_MASK
N#define UARTLP_D_R4T4_SHIFT                      UART0_D_R4T4_SHIFT
N#define UARTLP_D_R5T5_MASK                       UART0_D_R5T5_MASK
N#define UARTLP_D_R5T5_SHIFT                      UART0_D_R5T5_SHIFT
N#define UARTLP_D_R6T6_MASK                       UART0_D_R6T6_MASK
N#define UARTLP_D_R6T6_SHIFT                      UART0_D_R6T6_SHIFT
N#define UARTLP_D_R7T7_MASK                       UART0_D_R7T7_MASK
N#define UARTLP_D_R7T7_SHIFT                      UART0_D_R7T7_SHIFT
N#define UARTLP_MA1_MA_MASK                       UART0_MA1_MA_MASK
N#define UARTLP_MA1_MA_SHIFT                      UART0_MA1_MA_SHIFT
N#define UARTLP_MA1_MA(x)                         UART0_MA1_MA(x)
N#define UARTLP_MA2_MA_MASK                       UART0_MA2_MA_MASK
N#define UARTLP_MA2_MA_SHIFT                      UART0_MA2_MA_SHIFT
N#define UARTLP_MA2_MA(x)                         UART0_MA2_MA(x)
N#define UARTLP_C4_OSR_MASK                       UART0_C4_OSR_MASK
N#define UARTLP_C4_OSR_SHIFT                      UART0_C4_OSR_SHIFT
N#define UARTLP_C4_OSR(x)                         UART0_C4_OSR(x)
N#define UARTLP_C4_M10_MASK                       UART0_C4_M10_MASK
N#define UARTLP_C4_M10_SHIFT                      UART0_C4_M10_SHIFT
N#define UARTLP_C4_MAEN2_MASK                     UART0_C4_MAEN2_MASK
N#define UARTLP_C4_MAEN2_SHIFT                    UART0_C4_MAEN2_SHIFT
N#define UARTLP_C4_MAEN1_MASK                     UART0_C4_MAEN1_MASK
N#define UARTLP_C4_MAEN1_SHIFT                    UART0_C4_MAEN1_SHIFT
N#define UARTLP_C5_RESYNCDIS_MASK                 UART0_C5_RESYNCDIS_MASK
N#define UARTLP_C5_RESYNCDIS_SHIFT                UART0_C5_RESYNCDIS_SHIFT
N#define UARTLP_C5_BOTHEDGE_MASK                  UART0_C5_BOTHEDGE_MASK
N#define UARTLP_C5_BOTHEDGE_SHIFT                 UART0_C5_BOTHEDGE_SHIFT
N#define UARTLP_C5_RDMAE_MASK                     UART0_C5_RDMAE_MASK
N#define UARTLP_C5_RDMAE_SHIFT                    UART0_C5_RDMAE_SHIFT
N#define UARTLP_C5_TDMAE_MASK                     UART0_C5_TDMAE_MASK
N#define UARTLP_C5_TDMAE_SHIFT                    UART0_C5_TDMAE_SHIFT
N#define UARTLP_BASES                             UARTLP_BASES
N#define NV_FOPT_EZPORT_DIS_MASK                  This_symbol_has_been_deprecated
N#define NV_FOPT_EZPORT_DIS_SHIFT                 This_symbol_has_been_deprecated
N
N/**
N * @}
N */ /* end of group Backward_Compatibility_Symbols */
N
N
N#endif  /* #if !defined(MKL25Z4_H_) */
N
N/* MKL25Z4.h, eof. */
L 4 "src\main.c" 2
N#include <stdio.h>
L 1 "C:\Keil_v4\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5030076
N
N
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 5 "src\main.c" 2
N#include <math.h>
L 1 "C:\Keil_v4\ARM\ARMCC\bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision: 178085 $ Codemist 0.03
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5030076
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X  #if 0L || (1L && 199901L <= 199409L)
S    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_SOFTFP __declspec(__nothrow) __softfp
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __pure
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
S#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF static inline
N#else
N#define _ARMABI_INLINE __inline
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#ifdef __BIG_ENDIAN
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* ndef __BIG_ENDIAN */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* ndef __BIG_ENDIAN */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern __softfp unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Nextern __softfp unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __softfp int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __softfp int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
X__inline __declspec(__nothrow) __softfp int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
X__inline __declspec(__nothrow) __softfp int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#define HUGE_VAL ((double)__INFINITY__)
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __pure double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __pure double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    __inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
N    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
X    __inline float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __pure double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __pure double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __pure double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
X__inline __declspec(__nothrow) __pure double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
X__inline __declspec(__nothrow) __pure float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __pure double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __pure float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
X__inline __declspec(__nothrow) __pure float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __pure float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __pure float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#ifdef __USE_C99_MATH
S/*
S * Functions new in C99.
S */
Sextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Sextern _ARMABI float exp2f(float /*x*/);
S_ARMDEFLD1(exp2);
Sextern _ARMABI double fdim(double /*x*/, double /*y*/);
Sextern _ARMABI float fdimf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fdim);
S#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
S#endif
S#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
S#endif
S#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
S#endif
Sextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Sextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
S_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
S    { return (long double)fma((double)__x, (double)__y, (double)__z); }
X_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
Sextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmax);
Sextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmin);
Sextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Sextern _ARMABI float log2f(float /*x*/);
S_ARMDEFLD1(log2);
Sextern _ARMABI long lrint(double /*x*/);
Sextern _ARMABI long lrintf(float /*x*/);
S_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
S    { return lrint((double)__x); }
X_ARMABI_INLINE _ARMABI long lrintl(long double __x)     { return lrint((double)__x); }
Sextern _ARMABI __int64 llrint(double /*x*/);
Sextern _ARMABI __int64 llrintf(float /*x*/);
S_ARMABI_INLINE _ARMABI __int64 llrintl(long double __x) \
S    { return llrint((double)__x); }
X_ARMABI_INLINE _ARMABI __int64 llrintl(long double __x)     { return llrint((double)__x); }
Sextern _ARMABI long lround(double /*x*/);
Sextern _ARMABI long lroundf(float /*x*/);
S_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
S    { return lround((double)__x); }
X_ARMABI_INLINE _ARMABI long lroundl(long double __x)     { return lround((double)__x); }
Sextern _ARMABI __int64 llround(double /*x*/);
Sextern _ARMABI __int64 llroundf(float /*x*/);
S_ARMABI_INLINE _ARMABI __int64 llroundl(long double __x) \
S    { return llround((double)__x); }
X_ARMABI_INLINE _ARMABI __int64 llroundl(long double __x)     { return llround((double)__x); }
Sextern _ARMABI_PURE double nan(const char */*tagp*/);
Sextern _ARMABI_PURE float nanf(const char */*tagp*/);
S_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
S    { return (long double)nan(__t); }
X_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t)     { return (long double)nan(__t); }
S#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif 
Sextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Sextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
S_ARMDEFLD1(nearbyint);
Sextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Sextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
S_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
S    { return (long double)remquo((double)__x, (double)__y, __q); }
X_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
Sextern _ARMABI_FPEXCEPT double round(double /*x*/);
Sextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
S_ARMDEFLD1(round);
Sextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Sextern _ARMABI float tgammaf(float /*x*/);
S_ARMDEFLD1(tgamma);
Sextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Sextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
S_ARMDEFLD1(trunc);
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#ifdef __cplusplus
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __int64 llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __int64 llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __int64 llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __int64 llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    using ::std::abs;
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S    #endif
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which appear in C99 or non-strict mode */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #ifdef __USE_C99_MATH
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S      using ::std::fmal;
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S      using ::std::lrintl;
S      using ::std::llrint;
S      using ::std::llrintf;
S      using ::std::llrintl;
S      using ::std::lround;
S      using ::std::lroundf;
S      using ::std::lroundl;
S      using ::std::llround;
S      using ::std::llroundf;
S      using ::std::llroundl;
S      using ::std::nan;
S      using ::std::nanf;
S      using ::std::nanl;
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S      using ::std::remquol;
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
N  #endif
N
N#endif /* __math_h */
N
N/* end of math.h */
N
L 6 "src\main.c" 2
N#include "gpio_defs.h"
L 1 "inc\gpio_defs.h" 1
N#ifndef GPIO_DEFS_H
N#define GPIO_DEFS_H
N
N// basic light switch 
N#define LED1_POS (1)	// on port A
N#define LED2_POS (2)	// on port A
N#define SW1_POS (5)		// on port A
N
N#define MASK(x) (1UL << (x))
N
N// Speaker output
N#define SPKR_POS (0) 	// on port C
N
N#endif
L 7 "src\main.c" 2
N#include "LEDs.h"
L 1 "inc\LEDs.h" 1
N#ifndef LEDS_H
N#define LEDS_H
N
N// Freedom KL25Z LEDs
N#define RED_LED_POS (18)		// on port B
N#define GREEN_LED_POS (19)	// on port B
N#define BLUE_LED_POS (1)		// on port D
N
N// function prototypes
Nvoid Init_RGB_LEDs(void);
Nvoid Control_RGB_LEDs(unsigned int red_on, unsigned int green_on, unsigned int blue_on);
N
N#endif
L 8 "src\main.c" 2
N#include "i2c.h"
L 1 "inc\i2c.h" 1
N//configure I2C control register 1; I2C0->C1 to select master mode  
N//(for details, see I2C register mask in mkl25z4.h file)
N#define I2C_M_START 	I2C0->C1 |= I2C_C1_MST_MASK                     // Select Mater Mode (Start) logic '1' indicates START otherwise STOP
N//#define I2C_M_STOP HERE  	                                          // Select Master Mode (Stop) 
N#define I2C_M_RSTART 	I2C0->C1 |= I2C_C1_RSTA_MASK                    // Select Repeat Start
N
N//configure I2C register "I2C_C1_TX_MASK" to allow I2C bus to transmit sensor data; logic '1' to transmit mode, otherwise receiving mode 
N#define I2C_TRAN			I2C0->C1 |= I2C_C1_TX_MASK                      // I2C bus to Transmit
N
N#define I2C_REC 			I2C0->C1 &= ~I2C_C1_TX_MASK		                                          //I2C bus to receive
N
N#define BUSY_ACK 	    while(I2C0->S & 0x01)                            //I2C Bus Busy
N#define TRANS_COMP		while(!(I2C0->S & 0x80))                         //I2C Bus data transafer Complete
N																																			 //Enable Interrupt waiting flag
N#define I2C_WAIT			while((I2C0->S & I2C_S_IICIF_MASK)==0) {} \
N                                 I2C0->S |= I2C_S_IICIF_MASK;
X#define I2C_WAIT			while((I2C0->S & I2C_S_IICIF_MASK)==0) {}                                  I2C0->S |= I2C_S_IICIF_MASK;
N	
N#define NACK 	        I2C0->C1 |= I2C_C1_TXAK_MASK                      //Acknolegement of data NOT received
N#define ACK           I2C0->C1 &= ~I2C_C1_TXAK_MASK                     //Acknolegement of data received
N
Nvoid i2c_init(void);                                                    //function definition for i2c_init
N
Nvoid i2c_start(void);                                                   //function definition for i2c_start 
N	
N//void i2c_read_setup(uint8_t dev, uint8_t address);                      //function definition for i2c_read_setup
N	
Nuint8_t i2c_repeated_read(uint8_t);                                     //function definition for i2c_repeated_read
N	
Nuint8_t i2c_read_byte(uint8_t dev, uint8_t address);                    //function definition for i2c_read_byte
N
Nvoid i2c_write_byte(uint8_t dev, uint8_t address, uint8_t data);        //function definition for i2c_write_byte
L 9 "src\main.c" 2
N#include "mma8451.h"
L 1 "inc\mma8451.h" 1
N#ifndef MMA8451_H
N#define MMA8451_H
N
N#define MMA_ADDR 0x3A //Accel. device address
N
N#define REG_XHI 0x01
N#define REG_XLO 0x02
N#define REG_YHI 0x03
N#define REG_YLO 0x04
N#define REG_ZHI	0x05
N#define REG_ZLO 0x06
N
N#define REG_WHOAMI 0x0D //Accel read address
N#define REG_CTRL1  0x2A
N#define REG_CTRL4  0x2D
N
N#define WHOAMI 0x1A
N
N#define COUNTS_PER_G (4096.0)
N#define M_PI (3.14159265)
N
Nint init_mma(void);
Nvoid read_full_xyz(void);
Nvoid read_xyz(void);
Nvoid convert_xyz_to_roll_pitch(void);
N
Nextern float roll, pitch;
Nextern int16_t acc_X, acc_Y, acc_Z;
N
N#endif
L 10 "src\main.c" 2
N#include "delay.h"
L 1 "inc\delay.h" 1
N#ifndef DELAY_H
N#define DELAY_H
Nextern void Delay(uint32_t dlyTicks);                //function definition for Delay
N
N#endif
L 11 "src\main.c" 2
N
N/*----------------------------------------------------------------------------
N  MAIN function
N *----------------------------------------------------------------------------*/
Nint main (void) {
N	//initiliaze RGB LED
N	Init_RGB_LEDs();
N
Nif (init_mma() == 0)
N{ 
N  Control_RGB_LEDs(1,0,0);
N  while (1); //stay in the infinite loop to indicate the error with the RED LED
N}	
N	
N//Add Delay (1000); here	
N	Delay(1000);
N	
N	while (1) {
N		//Read the data on x, y, and z axis; // Use function call to read the axes data
N		//Convert x, y, and z axis to roll and pitch as described in the class 
N		// use function call to convert the data
N		
N		// Light green LED if pitch > 10 ; pick a pitch angle between 10 and 15 degrees
N		// Light blue LED if roll > 10 ; pick a roll angle between 10 to 15 degrees
N		
N		// use LED function call "Control_RGB_LEDs" from previous labs and display  
N		// roll and pitch angles using the tri-color LED; you may
N		//ignore the yaw angle; for details, see lab manual for roll, pitch, and yaw
N		//definitions
N		
N	}
N}
N
