; generated by ARM C/C++ Compiler, 4.1 [Build 894]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\mma8451.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\mma8451.d --cpu=Cortex-M0 --apcs=interwork -O0 -Iinc -IC:\Keil\ARM\RV31\Inc -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Freescale\Kinetis -D__MICROLIB --omf_browse=.\obj\mma8451.crf src\mma8451.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  init_mma PROC
;;;16     //i2c has to already be enabled
;;;17     int init_mma()
000000  b510              PUSH     {r4,lr}
;;;18     {
;;;19     	  //check for device
;;;20     		if(i2c_read_byte(MMA_ADDR, REG_WHOAMI) == WHOAMI)	{
000002  210d              MOVS     r1,#0xd
000004  203a              MOVS     r0,#0x3a
000006  f7fffffe          BL       i2c_read_byte
00000a  281a              CMP      r0,#0x1a
00000c  d109              BNE      |L1.34|
;;;21       		Delay(10);
00000e  200a              MOVS     r0,#0xa
000010  f7fffffe          BL       Delay
;;;22     			//set active mode, 14 bit samples and 100 Hz ODR (0x19)
;;;23     			i2c_write_byte(MMA_ADDR, REG_CTRL1, 0x01);
000014  2201              MOVS     r2,#1
000016  212a              MOVS     r1,#0x2a
000018  203a              MOVS     r0,#0x3a
00001a  f7fffffe          BL       i2c_write_byte
;;;24     			return 1;
00001e  2001              MOVS     r0,#1
                  |L1.32|
;;;25     		}
;;;26     		//else error
;;;27     		return 0;
;;;28     }
000020  bd10              POP      {r4,pc}
                  |L1.34|
000022  2000              MOVS     r0,#0                 ;27
000024  e7fc              B        |L1.32|
;;;29     
                          ENDP

                  read_full_xyz PROC
;;;30     void read_full_xyz()
000026  b51f              PUSH     {r0-r4,lr}
;;;31     {
;;;32     	int i;
;;;33     	uint8_t data[6];
;;;34     	int16_t temp[3];
;;;35     	
;;;36     	i2c_start();
000028  f7fffffe          BL       i2c_start
;;;37     	i2c_read_setup(MMA_ADDR , REG_XHI);
00002c  2101              MOVS     r1,#1
00002e  203a              MOVS     r0,#0x3a
000030  f7fffffe          BL       i2c_read_setup
;;;38     	
;;;39     	// Read five bytes in repeated mode
;;;40     	for( i=0; i<5; i++)	{
000034  2400              MOVS     r4,#0
000036  e005              B        |L1.68|
                  |L1.56|
;;;41     		data[i] = i2c_repeated_read(0);
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       i2c_repeated_read
00003e  a902              ADD      r1,sp,#8
000040  5508              STRB     r0,[r1,r4]
000042  1c64              ADDS     r4,r4,#1              ;40
                  |L1.68|
000044  2c05              CMP      r4,#5                 ;40
000046  dbf7              BLT      |L1.56|
;;;42     	}
;;;43     	// Read last byte ending repeated mode
;;;44     	data[i] = i2c_repeated_read(1);
000048  2001              MOVS     r0,#1
00004a  f7fffffe          BL       i2c_repeated_read
00004e  a902              ADD      r1,sp,#8
000050  5508              STRB     r0,[r1,r4]
;;;45     	
;;;46     	for ( i=0; i<3; i++ ) {
000052  2400              MOVS     r4,#0
000054  e00d              B        |L1.114|
                  |L1.86|
;;;47     		temp[i] = (int16_t) ((data[2*i]<<8) | data[2*i+1]);
000056  0060              LSLS     r0,r4,#1
000058  a902              ADD      r1,sp,#8
00005a  5c08              LDRB     r0,[r1,r0]
00005c  0200              LSLS     r0,r0,#8
00005e  0061              LSLS     r1,r4,#1
000060  1c49              ADDS     r1,r1,#1
000062  aa02              ADD      r2,sp,#8
000064  5c51              LDRB     r1,[r2,r1]
000066  4308              ORRS     r0,r0,r1
000068  b200              SXTH     r0,r0
00006a  0061              LSLS     r1,r4,#1
00006c  466a              MOV      r2,sp
00006e  5250              STRH     r0,[r2,r1]
000070  1c64              ADDS     r4,r4,#1              ;46
                  |L1.114|
000072  2c03              CMP      r4,#3                 ;46
000074  dbef              BLT      |L1.86|
;;;48     	}
;;;49     
;;;50     	// Align for 14 bits
;;;51     	acc_X = temp[0]/4;
000076  4669              MOV      r1,sp
000078  2000              MOVS     r0,#0
00007a  5e08              LDRSH    r0,[r1,r0]
00007c  17c1              ASRS     r1,r0,#31
00007e  0f89              LSRS     r1,r1,#30
000080  1809              ADDS     r1,r1,r0
000082  1089              ASRS     r1,r1,#2
000084  4a59              LDR      r2,|L1.492|
000086  8011              STRH     r1,[r2,#0]
;;;52     	acc_Y = temp[1]/4;
000088  4669              MOV      r1,sp
00008a  2002              MOVS     r0,#2
00008c  5e08              LDRSH    r0,[r1,r0]
00008e  17c1              ASRS     r1,r0,#31
000090  0f89              LSRS     r1,r1,#30
000092  1809              ADDS     r1,r1,r0
000094  1089              ASRS     r1,r1,#2
000096  4a56              LDR      r2,|L1.496|
000098  8011              STRH     r1,[r2,#0]
;;;53     	acc_Z = temp[2]/4;
00009a  4669              MOV      r1,sp
00009c  2004              MOVS     r0,#4
00009e  5e08              LDRSH    r0,[r1,r0]
0000a0  17c1              ASRS     r1,r0,#31
0000a2  0f89              LSRS     r1,r1,#30
0000a4  1809              ADDS     r1,r1,r0
0000a6  1089              ASRS     r1,r1,#2
0000a8  4a52              LDR      r2,|L1.500|
0000aa  8011              STRH     r1,[r2,#0]
;;;54     }
0000ac  bd1f              POP      {r0-r4,pc}
;;;55     
                          ENDP

                  read_xyz PROC
;;;56     
;;;57     void read_xyz(void)
0000ae  b510              PUSH     {r4,lr}
;;;58     {
;;;59     	// sign extend byte to 16 bits - need to cast to signed since function
;;;60     	// returns uint8_t which is unsigned
;;;61     	acc_X = (int8_t) i2c_read_byte(MMA_ADDR, REG_XHI);
0000b0  2101              MOVS     r1,#1
0000b2  203a              MOVS     r0,#0x3a
0000b4  f7fffffe          BL       i2c_read_byte
0000b8  b240              SXTB     r0,r0
0000ba  494c              LDR      r1,|L1.492|
0000bc  8008              STRH     r0,[r1,#0]
;;;62     	Delay(100);
0000be  2064              MOVS     r0,#0x64
0000c0  f7fffffe          BL       Delay
;;;63     	acc_Y = (int8_t) i2c_read_byte(MMA_ADDR, REG_YHI);
0000c4  2103              MOVS     r1,#3
0000c6  203a              MOVS     r0,#0x3a
0000c8  f7fffffe          BL       i2c_read_byte
0000cc  b240              SXTB     r0,r0
0000ce  4948              LDR      r1,|L1.496|
0000d0  8008              STRH     r0,[r1,#0]
;;;64     	Delay(100);
0000d2  2064              MOVS     r0,#0x64
0000d4  f7fffffe          BL       Delay
;;;65     	acc_Z = (int8_t) i2c_read_byte(MMA_ADDR, REG_ZHI);
0000d8  2105              MOVS     r1,#5
0000da  203a              MOVS     r0,#0x3a
0000dc  f7fffffe          BL       i2c_read_byte
0000e0  b240              SXTB     r0,r0
0000e2  4944              LDR      r1,|L1.500|
0000e4  8008              STRH     r0,[r1,#0]
;;;66     
;;;67     }
0000e6  bd10              POP      {r4,pc}
;;;68     
                          ENDP

                  convert_xyz_to_roll_pitch PROC
;;;69     void convert_xyz_to_roll_pitch(void) {
0000e8  b5f0              PUSH     {r4-r7,lr}
0000ea  b08f              SUB      sp,sp,#0x3c
;;;70     	float ax = acc_X/COUNTS_PER_G,
0000ec  493f              LDR      r1,|L1.492|
0000ee  2000              MOVS     r0,#0
0000f0  5e08              LDRSH    r0,[r1,r0]  ; acc_X
0000f2  f7fffffe          BL       __aeabi_i2d
0000f6  4606              MOV      r6,r0
0000f8  2200              MOVS     r2,#0
0000fa  4b3f              LDR      r3,|L1.504|
0000fc  f7fffffe          BL       __aeabi_ddiv
000100  910d              STR      r1,[sp,#0x34]
000102  900c              STR      r0,[sp,#0x30]
000104  f7fffffe          BL       __aeabi_d2f
000108  900e              STR      r0,[sp,#0x38]
;;;71     				ay = acc_Y/COUNTS_PER_G,
00010a  4939              LDR      r1,|L1.496|
00010c  2000              MOVS     r0,#0
00010e  5e08              LDRSH    r0,[r1,r0]  ; acc_Y
000110  f7fffffe          BL       __aeabi_i2d
000114  4606              MOV      r6,r0
000116  2200              MOVS     r2,#0
000118  4b37              LDR      r3,|L1.504|
00011a  f7fffffe          BL       __aeabi_ddiv
00011e  910d              STR      r1,[sp,#0x34]
000120  900c              STR      r0,[sp,#0x30]
000122  f7fffffe          BL       __aeabi_d2f
000126  4604              MOV      r4,r0
;;;72     				az = acc_Z/COUNTS_PER_G;
000128  4932              LDR      r1,|L1.500|
00012a  2000              MOVS     r0,#0
00012c  5e08              LDRSH    r0,[r1,r0]  ; acc_Z
00012e  f7fffffe          BL       __aeabi_i2d
000132  2200              MOVS     r2,#0
000134  4b30              LDR      r3,|L1.504|
000136  910d              STR      r1,[sp,#0x34]
000138  900c              STR      r0,[sp,#0x30]
00013a  f7fffffe          BL       __aeabi_ddiv
00013e  4606              MOV      r6,r0
000140  f7fffffe          BL       __aeabi_d2f
000144  4605              MOV      r5,r0
;;;73     	
;;;74     	roll = atan2(ay, az)*180/M_PI;
000146  4628              MOV      r0,r5
000148  f7fffffe          BL       __aeabi_f2d
00014c  4606              MOV      r6,r0
00014e  460f              MOV      r7,r1
000150  4620              MOV      r0,r4
000152  f7fffffe          BL       __aeabi_f2d
000156  4632              MOV      r2,r6
000158  463b              MOV      r3,r7
00015a  9107              STR      r1,[sp,#0x1c]
00015c  9006              STR      r0,[sp,#0x18]
00015e  f7fffffe          BL       atan2
000162  2200              MOVS     r2,#0
000164  4b25              LDR      r3,|L1.508|
000166  9109              STR      r1,[sp,#0x24]
000168  9008              STR      r0,[sp,#0x20]
00016a  f7fffffe          BL       __aeabi_dmul
00016e  4a24              LDR      r2,|L1.512|
000170  4b24              LDR      r3,|L1.516|
000172  910b              STR      r1,[sp,#0x2c]
000174  900a              STR      r0,[sp,#0x28]
000176  f7fffffe          BL       __aeabi_ddiv
00017a  910d              STR      r1,[sp,#0x34]
00017c  900c              STR      r0,[sp,#0x30]
00017e  f7fffffe          BL       __aeabi_d2f
000182  4921              LDR      r1,|L1.520|
000184  6008              STR      r0,[r1,#0]  ; roll
;;;75     	pitch = atan2(ax, sqrt(ay*ay + az*az))*180/M_PI;
000186  4629              MOV      r1,r5
000188  4628              MOV      r0,r5
00018a  f7fffffe          BL       __aeabi_fmul
00018e  4621              MOV      r1,r4
000190  9002              STR      r0,[sp,#8]
000192  4620              MOV      r0,r4
000194  f7fffffe          BL       __aeabi_fmul
000198  9001              STR      r0,[sp,#4]
00019a  9902              LDR      r1,[sp,#8]
00019c  f7fffffe          BL       __aeabi_fadd
0001a0  9003              STR      r0,[sp,#0xc]
0001a2  f7fffffe          BL       __aeabi_f2d
0001a6  9105              STR      r1,[sp,#0x14]
0001a8  9004              STR      r0,[sp,#0x10]
0001aa  f7fffffe          BL       sqrt
0001ae  4606              MOV      r6,r0
0001b0  460f              MOV      r7,r1
0001b2  980e              LDR      r0,[sp,#0x38]
0001b4  f7fffffe          BL       __aeabi_f2d
0001b8  4632              MOV      r2,r6
0001ba  463b              MOV      r3,r7
0001bc  9107              STR      r1,[sp,#0x1c]
0001be  9006              STR      r0,[sp,#0x18]
0001c0  f7fffffe          BL       atan2
0001c4  2200              MOVS     r2,#0
0001c6  4b0d              LDR      r3,|L1.508|
0001c8  9109              STR      r1,[sp,#0x24]
0001ca  9008              STR      r0,[sp,#0x20]
0001cc  f7fffffe          BL       __aeabi_dmul
0001d0  4a0b              LDR      r2,|L1.512|
0001d2  4b0c              LDR      r3,|L1.516|
0001d4  910b              STR      r1,[sp,#0x2c]
0001d6  900a              STR      r0,[sp,#0x28]
0001d8  f7fffffe          BL       __aeabi_ddiv
0001dc  910d              STR      r1,[sp,#0x34]
0001de  900c              STR      r0,[sp,#0x30]
0001e0  f7fffffe          BL       __aeabi_d2f
0001e4  4909              LDR      r1,|L1.524|
0001e6  6008              STR      r0,[r1,#0]  ; pitch
;;;76     	
;;;77     }
0001e8  b00f              ADD      sp,sp,#0x3c
0001ea  bdf0              POP      {r4-r7,pc}
;;;78     
                          ENDP

                  |L1.492|
                          DCD      acc_X
                  |L1.496|
                          DCD      acc_Y
                  |L1.500|
                          DCD      acc_Z
                  |L1.504|
                          DCD      0x40b00000
                  |L1.508|
                          DCD      0x40668000
                  |L1.512|
                          DCD      0x53c8d4f1
                  |L1.516|
                          DCD      0x400921fb
                  |L1.520|
                          DCD      roll
                  |L1.524|
                          DCD      pitch

                          AREA ||.data||, DATA, ALIGN=2

                  acc_X
000000  0000              DCW      0x0000
                  acc_Y
000002  0000              DCW      0x0000
                  acc_Z
000004  0000              DCW      0x0000
000006  0000              DCB      0x00,0x00
                  roll
000008  00000000          DCFS     0x00000000 ; 0
                  pitch
00000c  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "src\\mma8451.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_mma8451_c_acc_X____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_mma8451_c_acc_X____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_mma8451_c_acc_X____REVSH|
#line 130
|__asm___9_mma8451_c_acc_X____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
